

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="RCWA1ä»‹ç»$\boldsymbol{E}{top}^{inc}exp\left(i\big(k_x^{inc}x+k{z~top}^{inc}(z-h)\big)\right)$ $a&#x3D;a+b$ RCWAï¼ˆRigorous Coupled Wave Analysisï¼‰å…¨åæ˜¯ä¸¥æ ¼è€¦åˆæ³¢åˆ†æï¼Œæ˜¯ä¸€ç§ç”¨äºè®¾è®¡ã€åˆ†æåŠä¼˜åŒ–å‘¨æœŸæ€§ç»“æ„çš„æ•°å€¼è®¡ç®—æ–¹æ³•ã€‚å®ƒå¯ä»¥ç”¨æ¥æ¨¡æ‹Ÿå„ç§å‘¨æœŸæ€§ç»“æ„ï¼Œæ¯”å¦‚å…‰å­¦å…ƒå™¨ä»¶">
<meta property="og:type" content="article">
<meta property="og:title" content="RCWA ç›¸å…³1">
<meta property="og:url" content="http://example.com/2023/11/08/RCWA/RCWA%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RCWA1ä»‹ç»$\boldsymbol{E}{top}^{inc}exp\left(i\big(k_x^{inc}x+k{z~top}^{inc}(z-h)\big)\right)$ $a&#x3D;a+b$ RCWAï¼ˆRigorous Coupled Wave Analysisï¼‰å…¨åæ˜¯ä¸¥æ ¼è€¦åˆæ³¢åˆ†æï¼Œæ˜¯ä¸€ç§ç”¨äºè®¾è®¡ã€åˆ†æåŠä¼˜åŒ–å‘¨æœŸæ€§ç»“æ„çš„æ•°å€¼è®¡ç®—æ–¹æ³•ã€‚å®ƒå¯ä»¥ç”¨æ¥æ¨¡æ‹Ÿå„ç§å‘¨æœŸæ€§ç»“æ„ï¼Œæ¯”å¦‚å…‰å­¦å…ƒå™¨ä»¶">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403163538201.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403164752176.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403165245428.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403170721968.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403230539759.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230419103659141.png">
<meta property="article:published_time" content="2023-11-08T01:57:50.071Z">
<meta property="article:modified_time" content="2023-06-27T02:26:51.575Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="RCWA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>RCWA ç›¸å…³1 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- ä¸»é¢˜ä¾èµ–çš„å›¾æ ‡åº“ï¼Œä¸è¦è‡ªè¡Œä¿®æ”¹ -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wbupt</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>é¦–é¡µ</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>å½’æ¡£</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>åˆ†ç±»</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>æ ‡ç­¾</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>å‹é“¾</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">RCWA ç›¸å…³1</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-08 09:57" pubdate>
          2023å¹´11æœˆ8æ—¥ ä¸Šåˆ
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          66k å­—
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          548 åˆ†é’Ÿ
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> æ¬¡
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>ç›®å½•</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RCWA ç›¸å…³1</h1>
            
              <p class="note note-info">
                
                  
                    æœ¬æ–‡æœ€åæ›´æ–°äºï¼š10 ä¸ªæœˆå‰
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="RCWA1"><a href="#RCWA1" class="headerlink" title="RCWA1"></a>RCWA1</h1><h2 id="ä»‹ç»"><a href="#ä»‹ç»" class="headerlink" title="ä»‹ç»"></a>ä»‹ç»</h2><p>$\boldsymbol{E}<em>{top}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z~top}^{inc}(z-h)\big)\right)$</p>
<p>$a&#x3D;a+b$</p>
<p>RCWAï¼ˆRigorous Coupled Wave Analysisï¼‰å…¨åæ˜¯<code>ä¸¥æ ¼è€¦åˆæ³¢åˆ†æ</code>ï¼Œæ˜¯ä¸€ç§ç”¨äºè®¾è®¡ã€åˆ†æåŠä¼˜åŒ–å‘¨æœŸæ€§ç»“æ„çš„æ•°å€¼è®¡ç®—æ–¹æ³•ã€‚å®ƒå¯ä»¥ç”¨æ¥æ¨¡æ‹Ÿå„ç§å‘¨æœŸæ€§ç»“æ„ï¼Œæ¯”å¦‚å…‰å­¦å…ƒå™¨ä»¶ä¸­çš„å…‰æ …ã€å…‰çº¤å…‰æ …ã€å…‰å­æ™¶ä½“ç­‰ï¼Œä¹Ÿå¯ä»¥ç”¨äºæ¨¡æ‹Ÿç”µç£ç»“æ„ä¸­çš„ç”µç£æ³¢å¯¼ã€ç”µç£éšœç¢ç‰©ã€äº’è”çº¿ç­‰ã€‚</p>
<p>RCWAæ–¹æ³•åˆ©ç”¨<code>å‚…é‡Œå¶å˜æ¢</code>å°†<strong>å‘¨æœŸç›¸å¹²åœº</strong>åˆ†è§£ä¸º<strong>å‚…é‡Œå¶å˜æ¢</strong>çš„æ¨¡å¼ï¼Œç„¶ååˆ©ç”¨æ¨¡å¼çš„è€¦åˆå…³ç³»æ±‚è§£å‡ºè¿™äº›æ¨¡å¼çš„åå°„ã€é€å°„ã€æ•£å°„ç­‰ç‰©ç†é‡ã€‚ç”±äºRCWAæ˜¯ä¸€ç§ä¸¥æ ¼çš„å…¨æ³¢æ–¹æ³•ï¼Œå› æ­¤å®ƒå¯ä»¥è€ƒè™‘å„ç§æ•ˆåº”ï¼Œæ¯”å¦‚å¤šæ¬¡åå°„ã€å…¨æ¯æ•ˆåº”ç­‰ï¼Œå¯¹äºå¯¹åœºåˆ†å¸ƒæœ‰ç²¾ç»†è¦æ±‚çš„é—®é¢˜æœ‰å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚</p>
<p>RCWAå…·æœ‰é«˜ç²¾åº¦ã€é«˜æ•ˆèƒ½ã€çµæ´»æ€§ç­‰ç‰¹ç‚¹ï¼Œå› æ­¤å®ƒå·²ç»æˆä¸ºç°ä»£å…‰å­¦å’Œç”µç£å­¦ä¸­ä¸€ç§å¸¸ç”¨çš„è®¾è®¡å’Œåˆ†æå‘¨æœŸæ€§ç»“æ„çš„å·¥å…·ã€‚</p>
<hr>
<h1 id="RETICOLO-ç½‘çŠ¶çš„"><a href="#RETICOLO-ç½‘çŠ¶çš„" class="headerlink" title="RETICOLO ç½‘çŠ¶çš„"></a>RETICOLO ç½‘çŠ¶çš„</h1><p>Authors: J.P. Hugonin and P. Lalanne</p>
<p>â€¢ Reticolo 1Dä»£ç ç”¨äºåˆ†æä¼ ç»Ÿå®‰è£…ä¸­çš„1Då…‰æ …ã€‚</p>
<p>arXiv: 2101:00901</p>
<p>â€¢ Reticolo 1D-conicalä»£ç ç”¨äºåˆ†æä¼ ç»Ÿå’Œé”¥å½¢å®‰è£…ä¸­çš„1Då…‰æ …ã€‚</p>
<p>â€¢ Reticolo 2Dä»£ç ç”¨äºåˆ†æ2Däº¤å‰å…‰æ …ã€‚</p>
<p>åˆ†æäºŒç»´äº¤å‰å…‰æ …ã€‚</p>
<p>å®ƒä»¬æ˜¯åœ¨Matlabä¸‹è¿è¡Œçš„å…è´¹è½¯ä»¶ã€‚è¦å®‰è£…å®ƒä»¬ï¼Œè¯·å¤åˆ¶é™„å¸¦çš„æ–‡ä»¶å¤¹â€œreticolo_allegeâ€ï¼Œå¹¶å°†æ–‡ä»¶å¤¹æ·»åŠ åˆ°Matlabè·¯å¾„ä¸­ã€‚è½¯ä»¶å¯ä»¥åœ¨æ­¤å¤„ä¸‹è½½ã€‚</p>
<h3 id="This-technical-note-is-composed-of-three-parts"><a href="#This-technical-note-is-composed-of-three-parts" class="headerlink" title="This technical note is composed of three parts:"></a>This technical note is composed of three parts:</h3><p>æœ¬æŠ€æœ¯è¯´æ˜ç”±ä¸‰éƒ¨åˆ†ç»„æˆ:</p>
<ol>
<li>Reticolo code 1D for analyzing 1D gratings in classical mountings Reticolo ä»£ç 1Dç”¨äºåˆ†æç»å…¸å®‰è£…ä¸­çš„ä¸€ç»´å…‰æ …</li>
<li>Reticolo code 1D-conical for analyzing 1D gratings in classical and conical mountings ç”¨äºåˆ†æç»å…¸å’Œé”¥å½¢è£…ç½®ä¸­çš„ä¸€ç»´å…‰æ …çš„ Reticolo ç¨‹åº1Dé”¥å½¢</li>
<li>Reticolo code 2D for analyzing 2D crossed grating Reticolo ä»£ç 2Dç”¨äºåˆ†æäºŒç»´äº¤å‰å…‰æ …</li>
</ol>
<p>They are free software that operate under Matlab. To install them, copy the companion folder â€œreticolo_allegeâ€ and add the folder in the Matlab path. The software can be downloaded here.</p>
<p>å®ƒä»¬æ˜¯åœ¨ Matlab ä¸‹è¿è¡Œçš„è‡ªç”±è½¯ä»¶ã€‚è¦å®‰è£…å®ƒä»¬ï¼Œå¤åˆ¶ç›¸å…³æ–‡ä»¶å¤¹â€œ reticolo _ allegeâ€ï¼Œå¹¶å°†è¯¥æ–‡ä»¶å¤¹æ·»åŠ åˆ° Matlab è·¯å¾„ä¸­ã€‚è½¯ä»¶å¯ä»¥åœ¨è¿™é‡Œä¸‹è½½</p>
<p>The version V9 launched in 01&#x2F;2021 features a few novelties:</p>
<p>2021å¹´1æœˆå‘å¸ƒçš„ v9ç‰ˆæœ¬æœ‰ä¸€äº›æ–°ç‰¹æ€§:</p>
<p>Ã¼ it includes a treatment of stacks of arbitrarily anisotropic multilayered thin-films.1 Be aware that the substrate and superstrate cannot be anisotropic. This part is documented in Reticolo codes 1D-conical (or identically 2D).</p>
<p>å®ƒåŒ…æ‹¬å¯¹ä»»æ„å„å‘å¼‚æ€§çš„å¤šå±‚è–„è†œå †å çš„å¤„ç†ï¼Œ1 Be æ„è¯†åˆ°è¡¬åº•å’Œä¸Šå±‚ä¸èƒ½æ˜¯å„å‘å¼‚æ€§çš„ã€‚è¿™éƒ¨åˆ†è®°å½•åœ¨ Reticolo ä»£ç 1d-é”¥å½¢(æˆ–åŒæ ·çš„2d)ä¸­ã€‚</p>
<p>Ã¼ It features an option to visualize the Bloch modes.</p>
<p>å®ƒæä¾›äº†ä¸€ä¸ªå¯è§†åŒ– Bloch æ¨¡å¼çš„é€‰é¡¹ã€‚</p>
<p>Ã¼ Diagonal anisotropy (ğœºğ’™ğ’™ â‰  ğœºğ’šğ’š â‰  ğœºğ’›ğ’›) can be incorporated in structured grating layers and gratings with uniform layers having arbitrary anisotropy (ğœºğ’™ğ’š â‰  ğŸ â€¦) can also be handled)</p>
<p>å¯¹è§’å„å‘å¼‚æ€§(Îµxx â‰  Îµyâ‰  Îµzz)å¯ä»¥è¢«å¼•å…¥åˆ°ç»“æ„å…‰æ …å±‚ä¸­ï¼Œå…·æœ‰ä»»æ„å„å‘å¼‚æ€§çš„å‡åŒ€å±‚å…‰æ …(Îµxy â‰ 0â€¦)ä¹Ÿå¯ä»¥è¢«å¤„ç†</p>
<p>Ã¼ It is fully compatible with earlier versions.</p>
<p>å®ƒä¸æ—©æœŸç‰ˆæœ¬å®Œå…¨å…¼å®¹ã€‚</p>
<p>2021å¹´1æœˆå‘å¸ƒçš„V9ç‰ˆæœ¬å…·æœ‰ä¸€äº›æ–°åŠŸèƒ½ï¼š å®ƒåŒ…æ‹¬å¯¹ä»»æ„å„å‘å¼‚æ€§å¤šå±‚è–„è†œå †çš„å¤„ç†ã€‚è¯·æ³¨æ„ï¼ŒåŸºæ¿å’Œä¸Šç½®åŸºåº•ä¸èƒ½æ˜¯å„å‘å¼‚æ€§çš„ã€‚æœ¬éƒ¨åˆ†åœ¨Reticoloä»£ç 1D-conicalï¼ˆæˆ–2Dç›¸åŒï¼‰ä¸­æœ‰æ–‡æ¡£è®°å½•ã€‚ å®ƒå…·æœ‰å¯è§†åŒ–å¸ƒæ´›èµ«æ¨¡çš„é€‰é¡¹ã€‚ å¯¹äºå…·æœ‰å¯¹è§’å„å‘å¼‚æ€§ï¼ˆâ‰ â‰ ï¼‰çš„ç»“æ„æ€§å…‰æ …å±‚ä»¥åŠå…·æœ‰ä»»æ„å„å‘å¼‚æ€§ï¼ˆâ‰  â€¦ï¼‰çš„å‡åŒ€å…‰æ …å±‚çš„å…‰æ …ä¹Ÿå¯ä»¥å¤„ç†ã€‚ å®ƒä¸æ—©æœŸç‰ˆæœ¬å®Œå…¨å…¼å®¹ã€‚</p>
<p>2021å¹´1æœˆå‘å±•çš„ v9ç‰ˆæœ¬æœ‰ä¸€äº›æ–°åŠŸèƒ½: å®ƒåŒ…æ‹¬å®ƒåŒ…æ‹¬å®ƒå¯¹ä»»æ„è§’å±‚çš„å…‰æ …çš„æ„ä¹‰ï¼ŒåŸºç¡€æ¿å’Œä¸ŠåŸºåº•æ€§ä¸èƒ½å¤Ÿæ˜¯å„å‘æ€§çš„åˆ†éƒ¨åˆ†åˆ«åœ¨ reticolo ç 1d-é”¥å½¢(æˆ–2d ç›¸å¯¹)ä¸­æœ‰æ–‡æ¡£è®°å½•ã€‚å®ƒä»¥åŠå…·æœ‰å¯è§†åŒ–å¸ƒæ´›èµ«çš„é€‰é¡¹å¯¹äºæœ‰å…·ä½“é¡¹ç›®å…·æœ‰å¯è§†åŒ–å¸ƒæ´›èµ«çš„é€‰é¡¹ã€‚</p>
<p>This is simply achieved by retaining a single Fourier harmonics coefficient in the expansion (nn&#x3D;0). The extension is not optimal from numerical-efficiency perspectives, but has been provided on demand of several users who additionally complained of mistakes in available freeware packages on thin films.</p>
<p>è¿™åªæ˜¯é€šè¿‡åœ¨å±•å¼€å¼ä¸­ä¿ç•™ä¸€ä¸ªå•ä¸€çš„å‚…é‡Œå¶è°æ³¢ç³»æ•°(nn &#x3D; 0)æ¥å®ç°ã€‚ä»æ•°å€¼æ•ˆç‡çš„è§’åº¦æ¥çœ‹ï¼Œè¿™ç§æ‰©å±•å¹¶ä¸æ˜¯æœ€ä½³çš„ï¼Œä½†å®ƒæ˜¯æ ¹æ®ä¸€äº›ç”¨æˆ·çš„è¦æ±‚æä¾›çš„ï¼Œè¿™äº›ç”¨æˆ·è¿˜æŠ±æ€¨å¯ç”¨çš„è–„è†œå…è´¹è½¯ä»¶åŒ…ä¸­å­˜åœ¨é”™è¯¯ã€‚</p>
<p>Note also that we have launched in 2013 the RETICOLOfilm-stack program, a freeware that computes the reflection and transmission of arbitrary stacks of anisotropic thin films. RETICOLOfilm-stack is vectorialized and thus treats several wavelengths and incidences in a single instruction (see <a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710">https://zenodo.org/record/7512710</a>).</p>
<p>è¯·æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨2013å¹´å‘å¸ƒäº† RETICOLOfilm-stack ç¨‹åºï¼Œè¿™æ˜¯ä¸€ä¸ªè®¡ç®—ä»»æ„å †å å„å‘å¼‚æ€§è–„è†œçš„åå°„å’Œé€å°„çš„å…è´¹è½¯ä»¶ã€‚RETICOLOfilm-stack æ˜¯çŸ¢é‡åŒ–çš„ï¼Œå› æ­¤åœ¨ä¸€æ¡æŒ‡ä»¤ä¸­å¤„ç†å¤šä¸ªæ³¢é•¿å’Œå…¥å°„(è§ <a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710)%E3%80%82">https://zenodo.org/record/7512710)ã€‚</a></p>
<p>é€šè¿‡åœ¨å±•å¼€å¼ä¸­ä¿ç•™å•ä¸ªå‚…é‡Œå¶è°æ³¢ç³»æ•°ï¼ˆnn&#x3D;0ï¼‰å³å¯è½»æ¾å®ç°è¯¥ç›®æ ‡ã€‚ä»è®¡ç®—æ•ˆç‡çš„è§’åº¦æ¥çœ‹ï¼Œæ‰©å±•ä¸æ˜¯æœ€ä¼˜çš„ï¼Œä½†æ˜¯ç”±äºå¤šä¸ªç”¨æˆ·è¦æ±‚å¹¶æåˆ°äº†ç°æœ‰å…è´¹è½¯ä»¶ç¨‹åºä¸­çš„é”™è¯¯ï¼Œå› æ­¤æˆ‘ä»¬æä¾›äº†è¿™ä¸ªæ‰©å±•ã€‚ æ­¤å¤–ï¼Œè¯·æ³¨æ„ï¼Œ2013å¹´æˆ‘ä»¬æ¨å‡ºäº†RETICOLOfilm-stackç¨‹åºï¼Œå®ƒæ˜¯ä¸€ä¸ªå…è´¹è½¯ä»¶ï¼Œç”¨äºè®¡ç®—å„å‘å¼‚æ€§è–„è†œçš„ä»»æ„å †æ ˆçš„åå°„å’Œé€å°„ã€‚RETICOLOfilm-stackæ˜¯çŸ¢é‡åŒ–çš„ï¼Œå› æ­¤å¯ä»¥åœ¨å•ä¸ªæŒ‡ä»¤ä¸­å¤„ç†å¤šä¸ªæ³¢é•¿å’Œå…¥å°„è§’åº¦ï¼ˆè¯·å‚è§<a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710%EF%BC%89%E3%80%82">https://zenodo.org/record/7512710ï¼‰ã€‚</a></p>
<p>é€šè¿‡åœ¨æ­¤æˆ‘ä»¬æå‡ºäº† reticolofilm-stackï¼Œå®ƒæ˜¯ä¸€ä¸ªå…è´¹è½¯ä»¶å³å¯è®¡ç®—å †é•¿å’Œåœ¨å„ç§è½»å‘å¼‚å°„è†œç³»ç»Ÿä¸­çš„åå°„é€å°„åº¦è§’çš„è®¾è®¡</p>
<h1 id="RETICOLO-CODE-1D"><a href="#RETICOLO-CODE-1D" class="headerlink" title="RETICOLO CODE 1D"></a>RETICOLO CODE 1D</h1><p>for the diffraction by stacks of lamellar 1D gratings (classical diffraction) ç”¨äºåˆ†æåˆ†å±‚1Då…‰æ …çš„è¡å°„ ï¼ˆç»å…¸è¡å°„ï¼‰</p>
<p>å¯¹äºå±‚çŠ¶ä¸€ç»´å…‰æ …çš„è¡å°„(ç»å…¸è¡å°„) ï¼Œç”¨äºåˆ†æå±‚çŠ¶ä¸€ç»´å…‰æ …çš„è¡å°„(ç»å…¸è¡å°„)</p>
<p>Reticolo code 1D is a free software for analyzing 1D gratings in classical mountings. It operates under Matlab. To install it, copy the companion folder â€œreticolo_allegeâ€ and add the folder in the Matlab path. Reticolo code 1D  æ˜¯ä¸€æ¬¾å…è´¹è½¯ä»¶ï¼Œç”¨äºåˆ†æç»å…¸å®‰è£…çš„ä¸€ç»´å…‰æ …ã€‚å®ƒåœ¨ Matlab ä¸‹è¿è¡Œã€‚è¦å®‰è£…å®ƒï¼Œå¤åˆ¶ä¼´éšæ–‡ä»¶å¤¹â€œ reticolo _ allegeâ€ï¼Œå¹¶å°†è¯¥æ–‡ä»¶å¤¹æ·»åŠ åˆ° Matlab è·¯å¾„ä¸­ã€‚</p>
<h2 id="1-Generality-æ¦‚è¿°"><a href="#1-Generality-æ¦‚è¿°" class="headerlink" title="1. Generality æ¦‚è¿°"></a>1. Generality æ¦‚è¿°</h2><p>å®ƒå¯ä»¥è®¡ç®—ç”±å±‚çŠ¶ç»“æ„ç»„æˆçš„å…‰æ …çš„è¡å°„æ•ˆç‡å’Œè¡å°„å¹…åº¦ã€‚å®ƒåŒ…å«ç”¨äºè®¡ç®—å’Œå¯è§†åŒ–å…‰æ …å†…éƒ¨å’Œå¤–éƒ¨çš„ç”µç£åœºçš„ä¾‹ç¨‹ã€‚åœ¨æ­¤ç‰ˆæœ¬ä¸­ï¼Œæ— æ³•åˆ†æäºŒç»´å‘¨æœŸæ€§çš„ï¼ˆäº¤å‰çš„ï¼‰å…‰æ …ã€‚</p>
<p>RETICOLO is a code written in the language MATLAB 9.0. It computes the diffraction efficiencies and the diffracted amplitudes of gratings composed of stacks of lamellar structures. It incorporates routines for the calculation and visualisation of the electromagnetic fields inside and outside the grating. With this version, 2D periodic (crossed) gratings cannot be analysed.</p>
<p>RETICOLOæ˜¯ç”¨MATLAB 9.0ç¼–å†™çš„ä»£ç ã€‚å®ƒè®¡ç®—ç”±å±‚çŠ¶ç»“æ„ç»„æˆçš„å…‰æ …çš„è¡å°„æ•ˆç‡å’Œè¡å°„æŒ¯å¹…ã€‚å®ƒåŒ…æ‹¬è®¡ç®—å’Œå¯è§†åŒ–å…‰æ …å†…å¤–ç”µç£åœºçš„ä¾‹ç¨‹ã€‚è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæ— æ³•åˆ†æäºŒç»´å‘¨æœŸæ€§ï¼ˆäº¤å‰ï¼‰å…‰æ …ã€‚</p>
<p>As free alternative to MATLAB, RETICOLO can also be run in GNU Octave with minimal code changes. For further information, please contact <a href="mailto:&#116;&#105;&#110;&#97;&#x2e;&#x6d;&#105;&#116;&#x74;&#101;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#x74;">&#116;&#105;&#110;&#97;&#x2e;&#x6d;&#105;&#116;&#x74;&#101;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#x74;</a>.</p>
<p>ä½œä¸ºMATLABçš„å…è´¹æ›¿ä»£å“ï¼ŒRETICOLOä¹Ÿå¯ä»¥åœ¨GNU Octaveä¸­è¿è¡Œï¼Œåªéœ€è¿›è¡Œæœ€å°ç¨‹åº¦çš„ä»£ç æ›´æ”¹ã€‚æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è”ç³»<a href="mailto:&#x74;&#x69;&#110;&#x61;&#46;&#109;&#105;&#x74;&#x74;&#x65;&#114;&#x61;&#x6d;&#x73;&#107;&#x6f;&#103;&#108;&#x65;&#114;&#64;&#x70;&#114;&#111;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#116;">&#x74;&#x69;&#110;&#x61;&#46;&#109;&#105;&#x74;&#x74;&#x65;&#114;&#x61;&#x6d;&#x73;&#107;&#x6f;&#103;&#108;&#x65;&#114;&#64;&#x70;&#114;&#111;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#116;</a>ã€‚</p>
<p>In brief, RETICOLO implements a frequency-domain modal method (known as the Rigorous Coupled wave Analysis&#x2F;RCWA). To get an overview of the RCWA, the interested readers may refer to the following articles:</p>
<p>ç®€è€Œè¨€ä¹‹ï¼ŒRETICOLO å®ç°äº†ä¸€ç§é¢‘åŸŸæ¨¡æ€æ–¹æ³•(ç§°ä¸ºä¸¥æ ¼è€¦åˆæ³¢åˆ†æ&#x2F;RCWA)ã€‚ä¸ºäº†å¾—åˆ° RCWA çš„æ¦‚è¿°ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥å‚è€ƒä»¥ä¸‹æ–‡ç« :</p>
<p><code>1D-classical and conical diffraction</code> 1d-ç»å…¸å’Œåœ†é”¥è¡å°„</p>
<ol>
<li><p>M.G. Moharam et al., JOSAA <strong>12</strong>, 1068 (1995),</p>
</li>
<li><p>M.G. Moharam et al, JOSAA <strong>12</strong>, 1077 (1995),</p>
</li>
<li><p>P. Lalanne and G.M. Morris, JOSAA <strong>13</strong>, 779 (1996),</p>
</li>
<li><p>G. Granet and B. Guizal, JOSAA <strong>13</strong>, 1019 (1996),</p>
</li>
<li><p>L. Li, JOSAA <strong>13</strong>, 1870 (1996), see also C. Sauvan et al., Opt. Quantum Electronics <strong>36</strong>, 271-284 (2004) which simply explains the raison of the convergence-rate improvement of the Fourier-Factorization rules without requiring advanced mathematics on Fourier series and generalizes to other kinds of expansions. å…·ä½“è€Œè¨€ï¼Œå…³äºå‚…é‡Œå¶åˆ†è§£è§„åˆ™çš„æ”¶æ•›é€Ÿç‡ä¼˜åŒ–åŸå› ï¼Œå¯ä»¥å‚è€ƒæçµå®åœ¨1996å¹´å‘è¡¨åœ¨JOSAAæœŸåˆŠä¸Šçš„æ–‡ç« â€œEfficient computation of diffraction in the Rayleigh-Sommerfeld region by exact use of the scalar wave equationâ€ä»¥åŠC. Sauvanç­‰äººåœ¨2004å¹´å‡ºç‰ˆçš„æ–‡ç« â€œTheory of the Fabry-PÃ©rot resonator: A reviewâ€ï¼ˆOpt. Quantum Electronics 36, 271-284ï¼‰ï¼Œä¸¤ç¯‡æ–‡ç« å‡ä¸éœ€è¦å…³äºå‚…é‡Œå¶çº§æ•°å’Œå…¶ä»–æ‰©å±•æ–¹æ³•çš„é«˜çº§æ•°å­¦çŸ¥è¯†ï¼Œå¯ä»¥ç®€å•åœ°è§£é‡Šå‚…é‡Œå¶åˆ†è§£è§„åˆ™çš„æ”¶æ•›é€Ÿç‡ä¼˜åŒ–åŸå› ï¼Œå¹¶æ¨å¹¿è‡³å…¶ä»–ç±»å‹çš„å±•å¼€æ–¹æ³•ã€‚</p>
</li>
</ol>
<p><code>2D-crossed gratings</code> 2d äº¤å‰å…‰æ …</p>
<ol>
<li>L. Li, JOSAA <strong>14</strong>, 2758-2767 (1997),</li>
<li>E. Popov and M. NeviÃ¨re, JOSAA <strong>17</strong>, 1773 (2000)</li>
</ol>
<p>which describe the up-to-date formulation of the approach used in RETICOLO. Note that the formulation used in the last article (which proposes an improvement for analysing metallic gratings with continuous profiles like sinusoidal gratings) is not available in the RETICOLO version of the web. The RCWA relies on the computation of the eigenmodes in all the layers of the grating structure in a Fourier basis (plane-wave basis) and on a scattering matrix approach to recursively relate the mode amplitudes in the different layers.</p>
<p>æè¿°äº† RETICOLO ä¸­ä½¿ç”¨çš„æ–¹æ³•çš„æœ€æ–°å…¬å¼ã€‚è¯·æ³¨æ„ï¼Œä¸Šä¸€ç¯‡æ–‡ç« ä¸­ä½¿ç”¨çš„å…¬å¼(å…¶ä¸­æå‡ºäº†ä¸€ç§æ”¹è¿›æ–¹æ¡ˆï¼Œç”¨äºåˆ†æå…·æœ‰è¿ç»­å‰–é¢çš„é‡‘å±å…‰æ …ï¼Œå¦‚æ­£å¼¦å…‰æ …)åœ¨ RETICOLO ç‰ˆæœ¬çš„ web ä¸­æ˜¯ä¸å¯ç”¨çš„ã€‚RCWA ä¾èµ–äºåœ¨å‚…é‡Œå¶åŸº(å¹³é¢æ³¢åŸº)ä¸Šè®¡ç®—å…‰æ …ç»“æ„å„å±‚çš„æœ¬å¾æ¨¡ï¼Œå¹¶åˆ©ç”¨æ•£å°„çŸ©é˜µæ–¹æ³•å°†ä¸åŒå±‚çš„æ¨¡æŒ¯å¹…é€’æ¨å…³è”èµ·æ¥ã€‚</p>
<p><code>Eigenmode solver</code> For conical diffraction analysis of 1D gratings, the Bloch eigenmode solver used in Reticolo is based on the article â€œP. Lalanne and G.M. Morris, JOSAA <strong>13</strong>, 779 (1996)â€.</p>
<p>æœ¬å¾æ¨¡å¼æ±‚è§£å™¨: å¯¹äºä¸€ç»´å…‰æ …çš„åœ†é”¥è¡å°„åˆ†æï¼ŒReticolo ä¸­ä½¿ç”¨çš„ Bloch æœ¬å¾æ¨¡å¼æ±‚è§£å™¨æ˜¯åŸºäºâ€œ p. Lalanne å’Œ g.m. Morrisï¼ŒJOSAA 13,779(1996)â€ä¸€æ–‡</p>
<p><code>Scattering matrix approach</code> The code incorporates many refinements that we have not published and that we do not plan to publish. For instance, although it is generally admitted that the S-matrix is inconditionnally stable, it is not always the case. We have developed an in-house transfer matrix method which is more stable and accurate. The new transfer matrix approach is also more general and can handle perfect metals. The essence of the method has been rapidly published in â€œJ.-P. Hugonin, M. Besbes and P. Lalanne, Op. Lett. <strong>33</strong>, 1590 (2008)â€.</p>
<p>æ•£å°„çŸ©é˜µæ–¹æ³•: è¯¥ä»£ç åŒ…å«äº†è®¸å¤šæˆ‘ä»¬æ²¡æœ‰å‘è¡¨è¿‡ä¹Ÿä¸æ‰“ç®—å‘è¡¨çš„æ”¹è¿›ã€‚ä¾‹å¦‚ï¼Œå°½ç®¡äººä»¬æ™®éæ‰¿è®¤ s çŸ©é˜µæ˜¯æ— æ¡ä»¶ç¨³å®šçš„ï¼Œä½†äº‹å®å¹¶éæ€»æ˜¯å¦‚æ­¤ã€‚æˆ‘ä»¬å¼€å‘äº†ä¸€ç§æ›´ç¨³å®šå’Œå‡†ç¡®çš„å†…éƒ¨è½¬ç§»çŸ©é˜µæ–¹æ³•ã€‚æ–°çš„è½¬ç§»çŸ©é˜µæ–¹æ³•ä¹Ÿæ›´åŠ é€šç”¨ï¼Œå¯ä»¥å¤„ç†å®Œç¾çš„é‡‘å±ã€‚è¿™ç§æ–¹æ³•çš„ç²¾é«“å·²ç»åœ¨ã€Šæ—¥æŠ¥ã€‹ä¸Šè¿…é€Ÿå‘è¡¨ã€‚ä½œè€…: Hugoninï¼Œm. Besbes and pã€‚è±ç‰¹ã€‚33,1590(2008)â€ã€‚</p>
<p><code>Field calculation</code> The calculation of the near-field electromagnetic fields everywhere in the grating is performed according to the method described in â€œP. Lalanne, M.P. Jurek, JMO <strong>45</strong>, 1357 (1998)â€ and to its generalization to crossed gratings (unpublished). Basically, no Gibbs phenomenon will be visible in the plots of the discontinuous electromagnetic quantities, but field singularities at corners will be correctly handled.</p>
<p><strong>åœºè®¡ç®—: æ ¹æ®â€œ P.Lalanneï¼Œm.p. Jurekï¼ŒJMO 45,1357(1998)â€ä¸­æè¿°çš„æ–¹æ³•åŠå…¶å¯¹äº¤å‰å…‰æ …çš„æ¨å¹¿(æœªå‘è¡¨) ï¼Œè®¡ç®—äº†å…‰æ …å†…å„å¤„çš„è¿‘åœºç”µç£åœºã€‚åŸºæœ¬ä¸Šï¼Œåœ¨ä¸è¿ç»­ç”µç£é‡çš„å›¾ä¸­ä¸ä¼šçœ‹åˆ°å‰å¸ƒæ–¯ç°è±¡ï¼Œä½†æ˜¯åœ¨è§’è½å¤„çš„åœºå¥‡å¼‚æ€§å°†è¢«æ­£ç¡®å¤„ç†ã€‚</strong></p>
<p><code>Acknowledging the use of RETICOLO</code> In publications and reports, acknowledgments have to be provided by referencing to J.P. Hugonin and P. Lalanne, RETICOLO software for grating analysis, Institut dâ€™Optique, Orsay, France (2005), arXiv:2101:00901.</p>
<p>ä½¿ç”¨RETICOLOå£°æ˜: åœ¨å‡ºç‰ˆç‰©å’ŒæŠ¥å‘Šä¸­ï¼Œæ‰¿è®¤å¿…é¡»å‚è€ƒ j.p. Hugonin å’Œ p. Lalanneï¼ŒRETICOLO å…‰æ …åˆ†æè½¯ä»¶ï¼Œæ³•å›½ Orsay å…‰å­¦ç ”ç©¶æ‰€ï¼ŒarXiv: 2101:00901</p>
<p><strong>In addition, one may fairly quote the following references in journal publications</strong>:</p>
<p>æ­¤å¤–ï¼Œäººä»¬å¯ä»¥åœ¨æœŸåˆŠå‡ºç‰ˆç‰©ä¸­å…¬æ­£åœ°å¼•ç”¨ä»¥ä¸‹å‚è€ƒæ–‡çŒ®:</p>
<p>-M.G. Moharam, E.B. Grann, D.A. Pommet and T.K. Gaylord, â€œFormulation for stable and efficient implementation of the rigorous coupled-wave analysis of binary gratingsâ€, J. Opt. Soc. Am. A <strong>12</strong>, 1068-1076 (1995), if TE-polarization efficiency calculations are provided -P. Lalanne and G.M. Morris, â€œHighly improved convergence of the coupled-wave method for TM polarizationâ€,</p>
<p>- m.g. Moharamï¼Œe.b. Grannï¼Œd.a. Pommet å’Œ t.k. Gaylordï¼Œâ€œç¨³å®šå’Œæœ‰æ•ˆåœ°å®æ–½ä¸¥æ ¼çš„äºŒå…ƒå…‰æ …è€¦åˆæ³¢åˆ†æçš„å…¬å¼â€ï¼ŒJ.Optã€‚è¯‘æ³¨:ã€‚è¯‘æ³¨:ã€‚A 12,1068-1076(1995) ï¼Œå¦‚æœæä¾› te åæŒ¯æ•ˆç‡çš„è®¡ç®—-p. Lalanne å’Œ gm. Morrisï¼Œâ€œæå¤§åœ°æ”¹è¿›äº† TM åæŒ¯è€¦åˆæ³¢æ–¹æ³•çš„æ”¶æ•›æ€§â€,</p>
<p>J. Opt. Soc. Am. A <strong>13</strong>, 779-789 (1996) and G. Granet and B. Guizal, â€œEfficient implementation of the coupled- wave method for metallic lamellar gratings in TM polarizationâ€, J. Opt. Soc. Am. A <strong>13</strong>, 1019-1023 (1996), if TM- polarization efficiency calculations are provided, -P. Lalanne and M.P. Jurek, â€œComputation of the near-field pattern with the coupled-wave method for TM polarizationâ€, J. Mod. Opt.45, 1357-1374 (1998), if near-field electromagnetic-field distributions are shown.</p>
<h2 id="2-The-diffraction-problem-considered"><a href="#2-The-diffraction-problem-considered" class="headerlink" title="2 The diffraction problem considered"></a>2 The diffraction problem considered</h2><p>é¢œè‰²é—®é¢˜çš„è€ƒè™‘</p>
<p>In general terms, the code solves the diffraction problem by a grating defined by a stack of layers (in the z- direction) which have all identical periods in the x-direction and are invariant in the y direction, see Fig. 1. In the following, the (x,y) plane and the z-direction will be referred to as the transverse plane and the longitudinal direction, respectively. To define the grating structure, first we have to define a top and a bottom. This is rather arbitrary since the top or the bottom can be the substrate or the cover of a real structure. It is up to the user. Once the top and the bottom of the grating have been defined, the user can choose to illuminate the structure from the top or from the bottom. The z-axis is oriented from bottom to top.</p>
<p>é€šå¸¸æƒ…å†µä¸‹ï¼Œè¯¥ä»£ç é€šè¿‡åœ¨zæ–¹å‘ä¸Šå…·æœ‰ç›¸åŒå‘¨æœŸçš„å±‚æ•°ç»„æˆçš„å…‰æ …æ¥æ±‚è§£è¡å°„é—®é¢˜ï¼Œè¯¥å…‰æ …åœ¨xæ–¹å‘ä¸Šå…·æœ‰ç›¸åŒçš„å‘¨æœŸå¹¶åœ¨yæ–¹å‘ä¸Šä¸å˜ï¼Œè§å›¾1ã€‚æ¥ä¸‹æ¥ï¼Œï¼ˆxï¼Œyï¼‰å¹³é¢å’Œzæ–¹å‘å°†åˆ†åˆ«ç§°ä¸ºæ¨ªå‘å¹³é¢å’Œçºµå‘æ–¹å‘ã€‚ä¸ºäº†å®šä¹‰å…‰æ …ç»“æ„ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å®šä¹‰å…¶é¡¶éƒ¨å’Œåº•éƒ¨ã€‚è¿™ç›¸å½“ä»»æ„ï¼Œå› ä¸ºé¡¶éƒ¨æˆ–åº•éƒ¨å¯ä»¥æ˜¯çœŸå®ç»“æ„çš„è¡¬åº•æˆ–è¦†ç›–å±‚ï¼Œæ ¹æ®ç”¨æˆ·çš„è®¾å®šæ¥é€‰æ‹©ã€‚åœ¨å®šä¹‰äº†å…‰æ …çš„é¡¶éƒ¨å’Œåº•éƒ¨åï¼Œç”¨æˆ·å¯ä»¥ä»é¡¶éƒ¨æˆ–åº•éƒ¨ç…§å°„å…‰ç»“æ„ã€‚zè½´ä»ä¸‹å‘ä¸Šå®šå‘ã€‚</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png" srcset="/img/loading.gif" lazyload alt="image-20230403113229636" style="zoom: 67%;" />



<p> å›¾1. è¡å°„åœºçš„ç‘åˆ©å±•å¼€ã€‚ ç¬¬mé˜¶å…·æœ‰å¹³è¡ŒåŠ¨é‡ç­‰äºğ‘˜ğ‘¥ğ‘–ğ‘›ğ‘+ ğ‘šğ¾ğ‘¥ã€‚æˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªç‚¹Otop &#x3D; (0,0, h)åœ¨å…‰æ …é¡¶éƒ¨ä»¥åŠObottom &#x3D; (0,0,0)åœ¨å…‰æ …åº•éƒ¨ã€‚</p>
<p>RETICOLO is written with the convention for the complex notation of the fields. So, if the materials are absorbant, one expects that all indices have a positive imaginary part. The Maxwellâ€™s equations are of the form<br>RETICOLO æ˜¯ç”¨çº¦å®šä¹¦å†™çš„ï¼Œç”¨äºå­—æ®µçš„å¤æ‚ç¬¦å·ã€‚å› æ­¤ï¼Œå¦‚æœææ–™æ˜¯å¸æ”¶æ€§çš„ï¼Œäººä»¬æœŸæœ›æ‰€æœ‰çš„æŒ‡æ•°éƒ½æœ‰ä¸€ä¸ªæ­£è™šéƒ¨åˆ†ã€‚éº¦å…‹æ–¯éŸ¦æ–¹ç¨‹ç»„æ˜¯è¿™ç§å½¢å¼</p>
<p>å…¶ä¸­ï¼Œğœ€&#x3D; ğ‘›2 æ˜¯ç›¸å¯¹ä»‹ç”µå¸¸æ•°ï¼Œä¸ºä¸€ä¸ªå¤æ•°ï¼Œğœ†æ˜¯çœŸç©ºä¸­çš„æ³¢é•¿ã€‚</p>
<p>æ¥ä¸‹æ¥ï¼Œè€ƒè™‘äº†ä¸¤ç§æƒ…å†µï¼š </p>
<ol>
<li>TEæåŒ–ï¼šç”µåœºEä¸Oyå¹³è¡Œï¼› </li>
<li>TMæåŒ–ï¼šç£åœºHä¸Oyå¹³è¡Œã€‚</li>
</ol>
<p>RETICOLO returns the diffraction efficiencies of the transmitted and reflected orders for a plane wave incident from the top and from the bottom with the same calculation. Of course, these two incident plane waves must have identical x-component of the parallel wave vector: $k_{x}^{inc}$. This possibility which is not mentioned in the literature to our knowledge is important in practice since the user may get, with the same computational loads, the diffraction efficiencies of the grating component illuminated from the substrate or from the cover.</p>
<p>RETICOLOå¯ä»¥è¿”å›ä»é¡¶éƒ¨å’Œåº•éƒ¨å…¥å°„çš„å¹³é¢æ³¢çš„è¡å°„æ•ˆç‡çš„é€å°„å’Œåå°„é˜¶æ•°ï¼Œå¹¶é‡‡ç”¨ç›¸åŒçš„è®¡ç®—ã€‚å½“ç„¶ï¼Œè¿™ä¸¤ä¸ªå…¥å°„å¹³é¢æ³¢çš„å¹³è¡Œæ³¢çŸ¢é‡çš„xåˆ†é‡å¿…é¡»ç›¸åŒï¼š$k_{x}^{inc}$ã€‚åœ¨æˆ‘ä»¬æ‰€çŸ¥çš„æ–‡çŒ®ä¸­æœªæåˆ°è¿™ä¸€å¯èƒ½æ€§ï¼Œä½†åœ¨å®è·µä¸­éå¸¸é‡è¦ï¼Œå› ä¸ºç”¨æˆ·å¯ä»¥åœ¨åŒæ ·çš„è®¡ç®—è´Ÿè½½ä¸‹è·å–ä»è¡¬åº•æˆ–è¦†ç›–å±‚ç…§æ˜çš„å…‰æ …ç»„ä»¶çš„è¡å°„æ•ˆç‡ã€‚</p>
<p> RETICOLO-1D calculates the electric and magnetic fields diffracted by the grating for the following incident plane wave:</p>
<p>RETICOLO-1D è®¡ç®—äº†ä»¥ä¸‹å…¥å°„å¹³é¢æ³¢çš„å…‰æ …è¡å°„çš„ç”µåœºå’Œç£åœº:</p>
<p>$\boldsymbol{E}<em>{top}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z~top}^{inc}(z-h)\big)\right)$</p>
<p>$\textbf{H}^{inc}<em>{top}\textit{exp}\left(i\left(k^{inc}</em>{x}x+k^{inc}_{ztop}(z-h)\right)\right)$ å¦‚æœä»é¡¶éƒ¨å±‚å…¥å°„ï¼Œ</p>
<p>where $<del>k^{inc}_{z</del>top}&#x3D;-\sqrt{\left(2\pi n_{top}&#x2F;\lambda\right)^2-(k^{inc}_x)^2}$</p>
<p>$\boldsymbol{E}<em>{bottom}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z\text{bottom}}^{inc}(z-h)\big)\right)$</p>
<p>$\textbf{H}<em>{bottom}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z\textit{bottom}}^{inc}(z-h)\big)\right)$, å¦‚æœä»åº•éƒ¨å±‚å…¥å°„ï¼Œ</p>
<p>where $k_{Z\textit{bottom}}^{inc}&#x3D;\sqrt{(2\pi n_{bottom}&#x2F;\lambda)^2-(k_x^{inc})^2}$.</p>
<p>The z-component of the Poynting vector of the incident plane wave is Â±0.5.</p>
<p>å…¥å°„å¹³é¢æ³¢çš„æ³¢çŸ¢é‡çš„zåˆ†é‡ä¸ºÂ±0.5ã€‚</p>
<p>The Rayleigh-expansion of the diffracted electric fields are shown in the following figure. </p>
<p>ä¸‹å›¾æ˜¾ç¤ºäº†è¡å°„ç”µåœºçš„ç‘åˆ©å±•å¼€ç»“æœï¼š</p>
<p> $\boldsymbol{E}^{diff}<em>{top}&#x3D;\sum_m\boldsymbol{E}^{m}</em>{top}\exp\left[i((k^{inc}<em>x+mK_x)x+k^{m}</em>{z\text{top}}(z-h)\right]$</p>
<p>$\boldsymbol{H}<em>{top}^{d i f}&#x3D;\sum_m\boldsymbol{H}^{m}</em>{top}\exp\left[i((k^{inc}<em>x+mK_x)x+k^{m}</em>{ztop}(z-h)\right]$</p>
<p>where $k^m_{z~top}&#x3D;\sqrt{\left(2\pi n_{top}&#x2F;\lambda\right)^2-(k^inc_x+m K_x)^2}$</p>
<p>$\begin{array}{rcl}\boldsymbol{E}^{diff}<em>{bottom}&amp;&#x3D;\sum_m\boldsymbol{E}^{m}</em>{bottom}exp\left[i((k_x^{inc}+mK_x)x+k^{m}_{\text{z bottom}}z\right]\end{array}$</p>
<p>$\begin{array}{r l}\boldsymbol H_{bottom}^{diff}&amp;&#x3D;\sum_m\boldsymbol H_{bottom}^m exp[i((k_x^{inc}+mK_x)x+k_{z\text{bottom}}^m z]\end{array}$</p>
<p>where $k^m_z\text{bottom}&#x3D;\sqrt{(2\pi n_{bottom}&#x2F;\lambda)^2-(k^inc_x+mK_x)^2}$</p>
<p>They are shown in the following figure. å®ƒä»¬å¦‚å›¾1æ‰€ç¤ºã€‚</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png" srcset="/img/loading.gif" lazyload alt="image-20230403113229636" style="zoom: 67%;" />



<p>Fig. 1. Rayleigh expansion for the diffracted fields. $K_x&#x3D;(2\pi)&#x2F;period$. The $m^{\text{th}}$ order has a parallel momentum equal to $\quad k_{x}^{inc}+m K_{x}$. We define two points $\text{O}<em>{\text{top}}&#x3D;(0,0,\text{h})$ at the top of the grating, and $\text{O}</em>{\text{bottom}}&#x3D;(0,0,0)$ at the bottom of the grating .</p>
<p> å›¾1. è¡å°„åœºçš„ç‘åˆ©å±•å¼€ã€‚ ğ¾ğ‘¥&#x3D;(2ğœ‹)&#x2F;ğ‘ğ‘’ğ‘Ÿğ‘–ğ‘œğ‘‘ã€‚ç¬¬mé˜¶å…·æœ‰å¹³è¡ŒåŠ¨é‡ç­‰äºğ‘˜ğ‘¥ğ‘–ğ‘›ğ‘+ ğ‘šğ¾ğ‘¥ã€‚æˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªç‚¹Otop &#x3D; (0,0, h)åœ¨å…‰æ …é¡¶éƒ¨ä»¥åŠObottom &#x3D; (0,0,0)åœ¨å…‰æ …åº•éƒ¨ã€‚</p>
<p>The following is organized so that one can straightforwardly write a code using the software ä»¥ä¸‹å†…å®¹æ—¨åœ¨å¸®åŠ©ç”¨æˆ·ç›´æ¥ä½¿ç”¨è¯¥è½¯ä»¶ç¼–å†™ä»£ç .</p>
<h2 id="Preliminary-input-parameters-åˆæ­¥è¾“å…¥å‚æ•°"><a href="#Preliminary-input-parameters-åˆæ­¥è¾“å…¥å‚æ•°" class="headerlink" title="Preliminary input parameters åˆæ­¥è¾“å…¥å‚æ•°"></a>Preliminary input parameters åˆæ­¥è¾“å…¥å‚æ•°</h2><p>The name of the following parameters are given as examples. The user may define his own parameter vocabulary. ä¸‹åˆ—å‚æ•°çš„åç§°ä½œä¸ºç¤ºä¾‹ç»™å‡ºã€‚ç”¨æˆ·å¯ä»¥å®šä¹‰è‡ªå·±çš„å‚æ•°è¯æ±‡è¡¨ã€‚</p>
<p><strong>wavelength &#x3D; 3</strong>; % wavelength (l) in a vacuum. It might be 3 nm or 3 Âµm. You do not need to specify the unit but all other dimensions are of course in the same unit as the wavelength.</p>
<p>åœ¨çœŸç©ºä¸­ï¼Œwavelength &#x3D; 3;% wavelength ()ã€‚å®ƒå¯èƒ½æ˜¯3 nm æˆ–3 Î¼mã€‚ä½ ä¸éœ€è¦æŒ‡å®šå•ä½ï¼Œä½†æ‰€æœ‰å…¶ä»–ç»´åº¦å½“ç„¶æ˜¯åœ¨åŒä¸€ä¸ªå•ä½ä½œä¸ºæ³¢é•¿ã€‚</p>
<p>period &#x3D; in the x-direction.  å‘¨æœŸ &#x3D; åœ¨ x æ–¹å‘</p>
<p><code>nn = 20</code>; % this define the set of Fourier harmonics retained for the computation. More specifically, 2Â´nn+1 represent the number of Fourier harmonics retained from â€“nn to nn. This is a very important parameter ; for large n values, a high accuracy for the calculated data is achieved, but the computational time and memory is also large. If all the textures are homogeneous (case of a thin-film stack), we may set nn&#x3D;1 and the period may be arbitrarily set to any value, 1 for example. NB: Because of our normalization (Poynting vector equal to 1), the computed reflected and transmitted amplitude coefficients are not identical to those provided by the classical Fresnel formulas found in textbooks.</p>
<p><code>nn = 20</code>  ï¼…è¿™å®šä¹‰äº†è®¡ç®—ä¸­ä¿ç•™çš„å‚…é‡Œå¶è°æ³¢é›†åˆã€‚æ›´å…·ä½“åœ°è¯´ï¼Œ2Ã—nn+1ä»£è¡¨ä»-nnåˆ°nnä¿ç•™çš„å‚…é‡Œå¶è°æ³¢æ•°é‡ã€‚è¿™æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„å‚æ•°ï¼›å¯¹äºå¤§çš„nå€¼ï¼Œå¯ä»¥å®ç°è®¡ç®—æ•°æ®çš„é«˜ç²¾åº¦ï¼Œä½†è®¡ç®—æ—¶é—´å’Œå†…å­˜ä¹Ÿå¾ˆå¤§ã€‚å¦‚æœæ‰€æœ‰çš„çº¹ç†éƒ½æ˜¯å‡åŒ€çš„ï¼ˆå¦‚è–„è†œå †ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å°†nnè®¾ç½®ä¸º1ï¼Œå‘¨æœŸå¯ä»¥ä»»æ„è®¾ç½®ä¸ºä»»ä½•å€¼ï¼Œä¾‹å¦‚1ã€‚æ³¨æ„ï¼šç”±äºæˆ‘ä»¬çš„å½’ä¸€åŒ–ï¼ˆæ³Šæ¾çŸ¢é‡ç­‰äº1ï¼‰ï¼Œè®¡ç®—å¾—åˆ°çš„åå°„å’Œé€å°„å¹…åº¦ç³»æ•°ä¸æ•™ç§‘ä¹¦ä¸­çš„ç»å…¸Fresnelå…¬å¼æä¾›çš„ç³»æ•°ä¸åŒã€‚</p>
<p><code>parm = res0(1)</code> for TE polarization;  å¯¹äº TE æåŒ–ï¼Œparm &#x3D; res0(1) ;</p>
<p><code>parm = res0(-1)</code> for TM polarization; å¯¹äº TM æåŒ–ï¼Œparm &#x3D; res0(- 1) ;</p>
<p>% res0.m is a function that set default values to all parameters used by the code and determine the polarisation. res0.mæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒä¸ºä»£ç ä½¿ç”¨çš„æ‰€æœ‰å‚æ•°è®¾ç½®é»˜è®¤å€¼ï¼Œå¹¶ç¡®å®šæåŒ–ã€‚</p>
<p><code>k_parallel</code> &#x3D;$\boldsymbol{k_x^{inc}}$(ğŸğ…&#x2F;ğ€) is the normalised parallel momentum of the incident plane wave. å…¥å°„å¹³é¢æ³¢çš„å½’ä¸€åŒ–å¹³è¡ŒåŠ¨é‡. </p>
<p>If the grating is illuminated from the top region (or from the bottom region) under an incident angle Î¸, one has: å¦‚æœå…‰æ …åœ¨å…¥å°„è§’ä¸ºÎ¸çš„æƒ…å†µä¸‹ä»é¡¶éƒ¨åŒºåŸŸï¼ˆæˆ–åº•éƒ¨åŒºåŸŸï¼‰ç…§å°„ï¼Œåˆ™æœ‰ï¼š</p>
<p><code>k_parallel=n_inc\*sin(Î¸)</code></p>
<p><code>K _ parallel = n _ inc \* sin (Î¸) </code></p>
<p>where n_inc is the refractive index of the top (or bottom) layer. One expects that it is a positive real number and that the texture (see Section 4.1) associated to the top (or the bottom) layer has a background with a uniform refractive index â€œn_incâ€.</p>
<p>å…¶ä¸­ï¼Œn_incæ˜¯é¡¶éƒ¨ï¼ˆæˆ–åº•éƒ¨ï¼‰å±‚çš„æŠ˜å°„ç‡ã€‚äººä»¬æœŸæœ›å®ƒæ˜¯ä¸€ä¸ªæ­£å®æ•°ï¼Œå¹¶ä¸”ä¸é¡¶éƒ¨ï¼ˆæˆ–åº•éƒ¨ï¼‰å±‚ç›¸å…³è”çš„çº¹ç†ï¼ˆè§ç¬¬4.1èŠ‚ï¼‰å…·æœ‰å…·æœ‰å‡åŒ€æŠ˜å°„ç‡â€œn_incâ€çš„èƒŒæ™¯ã€‚ </p>
<p>(Note that the â€œk_parallelâ€ variable is defined <strong>without</strong> the factor ğŸğ…&#x2F;ğ€.)  </p>
<p>ï¼ˆè¯·æ³¨æ„ï¼Œâ€œk_parallelâ€å˜é‡çš„å®šä¹‰æ²¡æœ‰å› å­2Ï€&#x2F;Î»ã€‚ï¼‰</p>
<p> It is very important to keep in mind that wether one defines the incident plane wave in the top layer or in the bottom layer, the calculation will be done for both an incident wave from the top and an incident wave from the bottom, with an identical parallel momentum k_parallel. </p>
<p>éœ€è¦ç‰¢è®°çš„æ˜¯ï¼Œä¸ç®¡æ˜¯åœ¨é¡¶éƒ¨å±‚è¿˜æ˜¯åº•éƒ¨å±‚ä¸­å®šä¹‰å…¥å°„å¹³é¢æ³¢ï¼Œè®¡ç®—éƒ½å°†é’ˆå¯¹ä»é¡¶éƒ¨å…¥å°„çš„æ³¢å’Œä»åº•éƒ¨å…¥å°„çš„æ³¢è¿›è¡Œï¼Œå¹¶å…·æœ‰ç›¸åŒçš„å¹³è¡ŒåŠ¨é‡k_parallelã€‚</p>
<p>These 5 parameters (â€œwavelength, nn, parm and k_parallel) are required by the code. Some other parameters can additionally be defined. For example, the default parameters do not take the symmetry of the problem into account. So if one wants to use symmetries, a new parameter has to be defined: â€œparm.sym.xâ€, (see section 7). If one wants to calculate accurately the electromagnetics fields, one has to define: â€ parm.res1.champ&#x3D;1â€, but this increases the calculation time and memory loads (see section 8)</p>
<p>è¿™5ä¸ªå‚æ•°ï¼ˆâ€œæ³¢é•¿ã€nnã€parmå’Œk_parallel)â€æ˜¯ä»£ç æ‰€éœ€çš„ã€‚è¿˜å¯ä»¥å®šä¹‰å…¶ä»–ä¸€äº›å‚æ•°ã€‚ä¾‹å¦‚ï¼Œç¼ºçœå‚æ•°æ²¡æœ‰è€ƒè™‘é—®é¢˜çš„å¯¹ç§°æ€§ã€‚å› æ­¤ï¼Œå¦‚æœæƒ³è¦ä½¿ç”¨å¯¹ç§°æ€§ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªæ–°çš„å‚æ•°ï¼šâ€œparm.sym.xâ€ï¼ˆå‚è§ç¬¬7èŠ‚ï¼‰ã€‚å¦‚æœæƒ³è¦ç²¾ç¡®è®¡ç®—ç”µç£åœºï¼Œåˆ™å¿…é¡»å®šä¹‰ï¼šâ€œparm.res1.champ&#x3D;1â€ï¼Œä½†è¿™å°†å¢åŠ è®¡ç®—æ—¶é—´å’Œå†…å­˜è´Ÿè½½ï¼ˆè¯·å‚è§ç¬¬8èŠ‚ï¼‰ã€‚</p>
<h2 id="Structure-definition-grating-parameters"><a href="#Structure-definition-grating-parameters" class="headerlink" title="Structure definition (grating parameters)"></a>Structure definition (grating parameters)</h2><p>ç»“æ„å®šä¹‰ï¼ˆå…‰æ …å‚æ•°ï¼‰</p>
<p>The grating encompasses a uniform upperstrate, called the top in the following, a uniform substrate, called the bottom in the following, and many layers which define the grating, which is defined by a stack of layers. Every layer is defined by a â€œtextureâ€ and by its thickness. Two different layers may be identical (identical texture and thickness), may have different thicknesses with identical texture, may have different thicknesses and textures. To define the diffraction geometry, we need to define the different textures and then the different layers.</p>
<p>å…‰æ …åŒ…æ‹¬ä¸€ä¸ªç»Ÿä¸€çš„ä¸Šå±‚åŸºæ¿ï¼Œä»¥ä¸‹ç§°ä¸ºé¡¶éƒ¨ï¼Œåœ¨ä»¥ä¸‹ç§°ä¸ºåº•éƒ¨çš„ç»Ÿä¸€åŸºæ¿ä¸Šï¼Œä»¥åŠå®šä¹‰å…‰æ …çš„è®¸å¤šå±‚ï¼Œå®ƒç”±ä¸€ç»„å±‚å®šä¹‰ã€‚æ¯å±‚ç”±ä¸€ä¸ªâ€œçº¹ç†â€å’Œå®ƒçš„åšåº¦æ¥å®šä¹‰ã€‚ä¸¤ä¸ªä¸åŒçš„å±‚å¯ä»¥ç›¸åŒï¼ˆç›¸åŒçš„çº¹ç†å’Œåšåº¦ï¼‰ï¼Œå¯ä»¥å…·æœ‰ä¸åŒåšåº¦ç›¸åŒçš„çº¹ç†ï¼Œä¹Ÿå¯ä»¥å…·æœ‰ä¸åŒåšåº¦å’Œçº¹ç†ã€‚ä¸ºäº†å®šä¹‰è¡å°„å‡ ä½•ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸åŒçš„çº¹ç†ï¼Œç„¶åæ˜¯ä¸åŒçš„å±‚ã€‚</p>
<h3 id="How-to-define-a-texture"><a href="#How-to-define-a-texture" class="headerlink" title="How to define a texture?"></a>How to define a texture?</h3><p>å¦‚ä½•å®šä¹‰çº¹ç†ï¼Ÿ</p>
<p> Every texture is defined by a cell-array composed of two line-vectors of identical length. The first vector, let us say [x1 x2 â€¦ xp â€¦xN], contains all the x-values of the discontinuities. One <em>must</em> have :</p>
<p>æ¯ä¸ªçº¹ç†éƒ½ç”±ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªç›¸åŒé•¿åº¦çš„è¡Œå‘é‡çš„å•å…ƒæ•°ç»„å®šä¹‰ã€‚ç¬¬ä¸€ä¸ªå‘é‡ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º [x1 x2 â€¦ xp â€¦xN]ï¼ŒåŒ…å«æ‰€æœ‰ä¸è¿ç»­ç‚¹çš„xå€¼ã€‚å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š</p>
<ol>
<li>N&gt;1</li>
<li>$x_p&lt;x_{p+1}$ for any p</li>
<li>$x_N-x_1\leq\text{period}$.</li>
</ol>
<p>The second line-vector [n1 n2 â€¦ np â€¦ nN] contains the refractive indices of the material between the discontinuities. More explicitly, we have a refractive index np for xp-1&lt;x&lt;xp. Because of periodicity, note that the refractive index for xN&lt;x&lt;x1+period is equal to n1.</p>
<p>ç¬¬äºŒæ¡çº¿å‘é‡[ n1 n2â€¦ npâ€¦ nN ]åŒ…å«ä»‹äºä¸è¿ç»­é¢ä¹‹é—´çš„ææ–™çš„æŠ˜å°„ç‡ã€‚æ›´æ˜ç¡®åœ°è¯´ï¼Œæˆ‘ä»¬å¯¹ xp-1 &lt; x &lt; xp æœ‰æŠ˜å°„ç‡ npã€‚ç”±äºå‘¨æœŸæ€§ï¼Œè¯·æ³¨æ„ xN &lt; x &lt; x1 + å‘¨æœŸçš„æŠ˜å°„ç‡ç­‰äº n1ã€‚</p>
<p>The specific case of a uniform texture with a refractive index n is easily defined by texture{1}&#x3D;{n}. In that specific case, no need of a second vector since there is no discontinuity.</p>
<p>å…·æœ‰æŠ˜å°„ç‡ n çš„å‡åŒ€ç»‡æ„çš„ç‰¹æ®Šæƒ…å†µå¾ˆå®¹æ˜“ç”±ç»‡æ„{1} &#x3D; { n }æ¥å®šä¹‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸éœ€è¦ç¬¬äºŒä¸ªçŸ¢é‡ï¼Œå› ä¸ºæ²¡æœ‰ä¸è¿ç»­æ€§ã€‚</p>
<p> The textures have all to be to be packed together in a cell array textures&#x3D;{textures{1}, textures{2}, textures{3}} prior calling subroutine <strong>res1.m.</strong></p>
<p>è¿™äº›çº¹ç†å¿…é¡»åœ¨è°ƒç”¨å­ä¾‹ç¨‹ res1.m ä¹‹å‰è¢«æ‰“åŒ…åœ¨ä¸€ä¸ªå•å…ƒæ ¼é˜µåˆ—çº¹ç† &#x3D; {çº¹ç†{1} ï¼Œçº¹ç†{2} ï¼Œçº¹ç†{3}ä¸­ã€‚</p>
<p> Example : ä¾‹å­:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">period=<span class="number">17</span>; # å‘¨æœŸ = <span class="number">17</span>; </span><br><span class="line">textures =cell(<span class="number">1</span>,<span class="number">2</span>); # çº¹ç† = å•å…ƒæ ¼(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line">textures&#123;<span class="number">1</span>&#125;=&#123;<span class="number">1.5</span>&#125;; <span class="comment">%uniform texture # çº¹ç†&#123;1&#125; = &#123;1.5&#125; ;% å‡åŒ€çº¹ç†</span></span><br><span class="line">textures&#123;<span class="number">2</span>&#125;=&#123;[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">1.3</span>,<span class="number">1.5</span>,<span class="number">3</span>]&#125;; <span class="comment">%texture composed of 4 different refractive indices ï¼…ç”±å››ä¸ªä¸åŒæŠ˜å°„ç‡ç»„æˆçš„çº¹ç†</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>The following figure shows the refractive indices of the two textures.ä»¥ä¸‹å›¾æ˜¾ç¤ºäº†è¿™ä¸¤ä¸ªçº¹ç†çš„æŠ˜å°„ç‡ã€‚</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403163538201.png" srcset="/img/loading.gif" lazyload alt="image-20230403163538201" style="zoom: 50%;" />

<p>Fig. 2. Textures{1} and {2}.  å›¾2. çº¹ç†{1}å’Œ{2}ã€‚</p>
<p><code>Slits in perfectly-conducting metallic textures</code>: å®Œç¾å¯¼ä½“é‡‘å±çº¹ç†ä¸­çš„ç¼éš™: </p>
<p>Mixing perfectly-conducting metallic textures and dielectric textures in the same grating structure is possible. We have first to define a background by its refractive index â€œinfâ€ (for infinity). In this uniform background, we can incorporate strip inclusions with a complex or real refractive index â€œninclusionâ€ defined by the position c of its center and its x-width L. The inclusions cannot overlap.</p>
<p>åœ¨åŒä¸€å…‰æ …ç»“æ„ä¸­æ··åˆå®Œç¾å¯¼ä½“é‡‘å±çº¹ç†å’Œä»‹è´¨çº¹ç†æ˜¯å¯èƒ½çš„ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡å…¶æŠ˜å°„ç‡â€œinfâ€ï¼ˆè¡¨ç¤ºæ— ç©·å¤§ï¼‰æ¥å®šä¹‰ä¸€ä¸ªèƒŒæ™¯ã€‚åœ¨è¿™ä¸ªç»Ÿä¸€çš„èƒŒæ™¯ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ’å…¥å¸¦æœ‰å¤æ‚æˆ–å®æŠ˜å°„ç‡â€œninclusionâ€çš„æ¡å½¢åŒ…å«ç‰©ï¼Œè¯¥åŒ…å«ç‰©ç”±å…¶ä¸­å¿ƒä½ç½®cå’Œxå®½åº¦Læ¥å®šä¹‰ã€‚è¿™äº›åŒ…å«ç‰©ä¸èƒ½é‡å ã€‚</p>
<p>For example: ä¾‹å¦‚:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textures &#123;3&#125;= &#123;inf, [c1,L1,ninclusion1],[c2,L2, ninclusion2]&#125;</span><br><span class="line"># çº¹ç†&#123;3&#125; = &#123; infï¼Œ[ c1ï¼ŒL1ï¼Œninclusion 1] ï¼Œ[ c2ï¼ŒL2ï¼Œninclusion 2]</span><br></pre></td></tr></table></figure>



<p><code>Anisotropic layers:</code> å„å‘å¼‚æ€§å±‚:</p>
<p>Grating layers (not the substrate nor the superstrate) can be anisotropic with diagonal tensors (ğœ€ğ‘¥ğ‘¦ &#x3D; ğœ€ğ‘¥ğ‘§ â€¦ &#x3D; 0). å…‰æ …å±‚(ä¸æ˜¯è¡¬åº•ä¹Ÿä¸æ˜¯ä¸Šå±‚)å¯ä»¥æ˜¯å„å‘å¼‚æ€§çš„å¯¹è§’å¼ é‡(Îµxy &#x3D; Îµxzâ€¦ &#x3D; 0)ã€‚</p>
<p>To implement diagonal anisotropy å®ç°å¯¹è§’å„å‘å¼‚æ€§</p>
<p>parm.res1.change_index&#x3D;${\left[n_{\text{prov}}^1,n_{x}^1,n_{y}^1,n_{z}^1\right],\left[n_{\text{prov}}^2,n_{x}^2,n_{y}^2,n_{z}^2\right]}$; % $\mathbf{n}<em>{\text{prov}}^1\neq\mathbf{n}</em>{\text{prov}}^2$</p>
<p>The refractive index nprov1 is then replaced <strong>in all textures</strong> by epsilon&#x3D;diag([(n 1)2, (n 1 )2, (nz1 )2]). Beware if the superstate (or substrate) has a refractive index nprov1, it will also be replaced and this is not allowed. Thus we recommend using an unusual value for nprov1 (e.g. 89.99999 or rand(1)).</p>
<p>ç„¶åï¼ŒæŠ˜å°„ç‡ nprov1åœ¨æ‰€æœ‰çº¹ç†ä¸­è¢« epsilon &#x3D; diag ([(n1)2ï¼Œ(n1)2ï¼Œ(nz1)2])å–ä»£ã€‚å½“å¿ƒï¼Œå¦‚æœè¶…æ€(æˆ–è¡¬åº•)å…·æœ‰æŠ˜å°„ç‡ nprov1ï¼Œå®ƒä¹Ÿå°†è¢«æ›¿æ¢ï¼Œè¿™æ˜¯ä¸å…è®¸çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨ nprov1çš„ä¸å¯»å¸¸å€¼(ä¾‹å¦‚89.99999æˆ–å…°ç‰¹(1))ã€‚</p>
<p>The user may also diagonal permeability tensors ç”¨æˆ·ä¹Ÿå¯ä»¥ä½¿ç”¨å¯¹è§’æ¸—é€å¼ é‡</p>
<p>parm.res1.change_index&#x3D;</p>
<p> ${<del>\left{\left[n_{\text{prov}}^1,</del>n_x^1,n_y^1,n_z^1,m_x^1,m_y^1,m_z^1\right],\left[n_{\text{prov}}^2,~n_x^2,n_y^2,n_z^2\right]\right}$;</p>
<p>â€‹    </p>
<p>Parm.res1.change _ index &#x3D; {[ nprov1ï¼Œn1ï¼Œn1ï¼Œnz1ï¼Œm1ï¼Œm1] ï¼Œ[ nprov2ï¼Œn2ï¼Œn2ï¼Œnz2] ;</p>
<p>The     refractive     index     nprov1  is   then   replaced   <strong>in   all   textures</strong>   by $\text{epsilon&#x3D;diag}([(n_x^1)^2,(n_y^1)^2,(n_z^1)^2]),\text{mu&#x3D;diag}([(m_x^1)^2,(m_y^1)^2,(m_z^1)^2]).$</p>
<p>åœ¨æ‰€æœ‰ç»“æ„ä¸­ï¼ŒæŠ˜å°„ç‡ nprov1ç”± Îµ &#x3D; diag ([(n1)2ï¼Œ(n1)2ï¼Œ(n1)2]) ï¼Œmu &#x3D; diag ([(m1)2ï¼Œ(m1)2ï¼Œ(m1)2])å–ä»£ã€‚</p>
<p>For slits in perfectly-conducting metallic textures, anisotropy cannot be implemented. å¯¹äºå®Œå…¨å¯¼ç”µé‡‘å±ç»‡æ„ä¸­çš„ç¼éš™ï¼Œå„å‘å¼‚æ€§æ˜¯ä¸èƒ½å®ç°çš„ã€‚</p>
<p> In order to check if the set of textures is correctly set up, the user can set the variable parm.res1.trace equal to 1: â€œparm.res1.trace &#x3D; 1;â€. </p>
<p>Then a Matlab figure will show up the refractive-index distribution of all textures. Each</p>
<p>texture is represented with the coordinate x varying from â€“period&#x2F;2 to period&#x2F;2</p>
<p> ä¸ºäº†æ£€æŸ¥çº¹ç†é›†æ˜¯å¦æ­£ç¡®è®¾ç½®ï¼Œç”¨æˆ·å¯ä»¥å°†å˜é‡parm.res1.traceè®¾ç½®ä¸º1ï¼šâ€œparm.res1.trace &#x3D; 1;â€ã€‚ç„¶åï¼Œä¸€ä¸ªMatlabå›¾å°†æ˜¾ç¤ºå‡ºæ‰€æœ‰çº¹ç†çš„æŠ˜å°„ç‡åˆ†å¸ƒã€‚æ¯ä¸ªçº¹ç†éƒ½ç”¨åæ ‡xè¡¨ç¤ºï¼Œå…¶å˜åŒ–èŒƒå›´ä¸º-period&#x2F;2åˆ°period&#x2F;2ã€‚</p>
<h3 id="How-to-define-the-layers-å¦‚ä½•å®šä¹‰å›¾å±‚ï¼Ÿ"><a href="#How-to-define-the-layers-å¦‚ä½•å®šä¹‰å›¾å±‚ï¼Ÿ" class="headerlink" title="How to define the layers? å¦‚ä½•å®šä¹‰å›¾å±‚ï¼Ÿ"></a>How to define the layers? å¦‚ä½•å®šä¹‰å›¾å±‚ï¼Ÿ</h3><p>This is performed by defining the â€œProfileâ€ variable which contains, starting from the top layer and finishing by the bottom layer, the successive information (thickness and texture-label) relative to every layer. Here is an example that illustrates how to set up the â€œProfileâ€ variable:</p>
<p>è¿™æ˜¯é€šè¿‡å®šä¹‰â€œProfileâ€å˜é‡æ¥å®ä¹ çš„ï¼Œè¯¥å˜é‡ä»é¡¶éƒ¨å±‚å¼€å§‹ï¼Œä»¥åº•éƒ¨å±‚ç»“æŸï¼Œç›¸å¯¹äºæ¯ä¸ªå±‚ï¼Œé¡ºåºåŒ…å«è¿ç»­çš„ä¿¡æ¯ï¼ˆåšåº¦å’Œçº¹ç†æ ‡ç­¾ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œæ¼”ç¤ºå¦‚ä½•è®¾ç½®â€œProfileâ€å˜é‡ï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile = &#123;[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]&#125;; </span><br></pre></td></tr></table></figure>

<p>It means that from the top to the bottom we have: the top layer is formed by a thickness 0 of texture 1, then we have twice textures 3, 2 and 4 with depth 1, 0.5 and 0.5 respectively, texture 6 with depth 2, and finally the bottom layer (formed by texture 2) with null thickness. Since textures 1 and 2 correspond to the top and bottom layers, they must be uniform. In this example, the top and bottom layers have a null thickness. However, one may set an arbitrary thickness. Especially, if one needs to plot the electromagnetic fields in the bottom and top layers, the thicknesses hb and hh (see Fig. 4) over which the fields have to be visualized has to be specified. For hb&#x3D;hh&#x3D;0, the Rayleigh expansions of the fields in the top and bottom layers are not plotted.  </p>
<p>è¿™æ„å‘³ç€ä»é¡¶éƒ¨åˆ°åº•éƒ¨ï¼Œæˆ‘ä»¬æœ‰ï¼šé¡¶éƒ¨å±‚ç”±çº¹ç†1çš„åšåº¦ä¸º0ç»„æˆï¼Œç„¶åæˆ‘ä»¬æœ‰ä¸¤æ¬¡æ·±åº¦åˆ†åˆ«ä¸º1ã€0.5å’Œ0.5çš„çº¹ç†3ã€2å’Œ4ï¼Œæ·±åº¦ä¸º2çš„çº¹ç†6ï¼Œæœ€åæ˜¯ç”±çº¹ç†2å½¢æˆçš„åº•éƒ¨å±‚ï¼Œåšåº¦ä¸ºé›¶ã€‚ç”±äºçº¹ç†1å’Œ2å¯¹åº”äºé¡¶éƒ¨å’Œåº•éƒ¨å±‚ï¼Œå®ƒä»¬å¿…é¡»æ˜¯å‡åŒ€çš„ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé¡¶éƒ¨å’Œåº•éƒ¨å±‚çš„åšåº¦éƒ½ä¸ºé›¶ã€‚ç„¶è€Œï¼Œå¯ä»¥è®¾ç½®ä»»æ„åšåº¦ã€‚ç‰¹åˆ«åœ°ï¼Œå¦‚æœéœ€è¦ç»˜åˆ¶åº•éƒ¨å’Œé¡¶éƒ¨å±‚ä¸­çš„ç”µç£åœºï¼Œåˆ™å¿…é¡»æŒ‡å®šè¦å¯è§†åŒ–åœºçš„åšåº¦hbå’Œhhï¼ˆè§å›¾4ï¼‰ã€‚å¯¹äºhb&#x3D;hh&#x3D;0ï¼Œä¸ç»˜åˆ¶é¡¶éƒ¨å’Œåº•éƒ¨å±‚ä¸­åœºçš„Rayleighå±•å¼€ã€‚</p>
<p>In this particular Profile, the structure formed by texture 3 with thickness 1, texture 2 with thickness 0.5 and texture 4 with thickness 0.5 is repeated twice. It is possible to simplify the instruction defining the â€œProfileâ€ variable in order to take into account the repetitions:  </p>
<p>åœ¨è¿™ä¸ªç‰¹å®šçš„â€œProfileâ€ä¸­ï¼Œç”±çº¹ç†3ï¼ˆåšåº¦ä¸º1ï¼‰ã€çº¹ç†2ï¼ˆåšåº¦ä¸º0.5ï¼‰å’Œçº¹ç†4ï¼ˆåšåº¦ä¸º0.5ï¼‰å½¢æˆçš„ç»“æ„é‡å¤äº†ä¸¤æ¬¡ã€‚å¯ä»¥ç®€åŒ–å®šä¹‰â€œProfileâ€å˜é‡çš„æŒ‡ä»¤ï¼Œå› ä¸ºè®¡ç®—ä¼šè€ƒè™‘åˆ°é‡å¤æ€§ï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;[<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>], [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], <span class="number">2</span>&#125;,&#123;[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">2</span>]&#125;&#125;;  </span><br></pre></td></tr></table></figure>

<p> If a structure is repeated many times, the above â€œfactorizedâ€ instruction of Eq. 2 is better than the â€œexpandedâ€ one of Eq. 1, in terms off computational speed, because the calculation will take into account the repetitions.</p>
<p>The profile is shown below.  å¦‚æœä¸€ä¸ªç»“æ„éœ€è¦å¤šæ¬¡é‡å¤ï¼Œé‚£ä¹ˆä¸Šè¿°å¼å­2çš„â€œå› å¼åˆ†è§£â€æŒ‡ä»¤æ¯”å¼å­1çš„â€œå±•å¼€â€æŒ‡ä»¤åœ¨è®¡ç®—é€Ÿåº¦ä¸Šæ›´å¥½ï¼Œå› ä¸ºè®¡ç®—å°†è€ƒè™‘åˆ°è¿™äº›é‡å¤ã€‚</p>
<p> The profile is shown below. ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å˜é‡â€œProfileâ€çš„å…·ä½“æƒ…å†µã€‚</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403164752176.png" srcset="/img/loading.gif" lazyload alt="image-20230403164752176" style="zoom:50%;" />

<p> Fig. 3. Texture stacks. The example corresponds to a profile defined by Profile &#x3D;  {[hh,1,0.5,0.5,1,0.5,0.5,2, hb],[1,3,2,4,3,2,4,6,2]}; . The top and bottom layers have uniform textures.  </p>
<p>å›¾3. çº¹ç†å †æ ˆã€‚è¯¥ç¤ºä¾‹å¯¹åº”äºä¸€ä¸ªç”±Profile &#x3D; {[hh,1,0.5,0.5,1,0.5,0.5,2, hb],[1,3,2,4,3,2,4,6,2]}å®šä¹‰çš„é…ç½®æ–‡ä»¶ã€‚é¡¶éƒ¨å’Œåº•éƒ¨å±‚å…·æœ‰å‡åŒ€çš„çº¹ç†ã€‚</p>
<h3 id="Solving-the-eigenmode-problem-for-every-texture"><a href="#Solving-the-eigenmode-problem-for-every-texture" class="headerlink" title="Solving the eigenmode problem for every texture"></a>Solving the eigenmode problem for every texture</h3><p>æ±‚è§£æ¯ä¸ªçº¹ç†çš„ç‰¹å¾æ¨¡æ€é—®é¢˜</p>
<p>The first computation with the RCWA consists in calculating the eigenmodes associated to all textures. This is done by the subroutine â€œres1.mâ€, following the instruction:</p>
<p>RCWA çš„ç¬¬ä¸€ä¸ªè®¡ç®—åŒ…æ‹¬è®¡ç®—ä¸æ‰€æœ‰çº¹ç†ç›¸å…³çš„ç‰¹å¾æ¨¡å¼ã€‚è¿™æ˜¯ç”±å­ç¨‹åºâ€œ res1.mâ€æŒ‰ç…§æŒ‡ä»¤å®Œæˆçš„:</p>
<h3 id="res1ç¨‹åº"><a href="#res1ç¨‹åº" class="headerlink" title="res1ç¨‹åº"></a>res1ç¨‹åº</h3><p><code>è®¡ç®—çº¹ç†</code></p>
<p> aa &#x3D; res1(wavelength,period,textures,nn,k_parallel,parm);  </p>
<p>This subroutine has 6 input arguments: the wavelength â€œ<strong>wavelength</strong>â€, the period of the grating â€œ<strong>period</strong>â€, the â€œ<strong>textures</strong>â€ variable, the number of Fourier harmonics â€œ<strong>nn</strong>â€, the normalized parallel incident wave vector â€œ<strong>k_parallel</strong>, and the â€œ<strong>parm</strong>â€ variable containing the values of all parameters used by the code and the selected the polarisation. If one has to study the diffraction by different gratings composed of the same textures, one needs to compute only once the eigenmodes. It is possible to save the â€œaaâ€ variable in a â€œ.matâ€ file and to reload it for the computation of the diffracted waves, see an example in Annex 10.3.</p>
<p>è¿™ä¸ªå­ç¨‹åºæœ‰6ä¸ªè¾“å…¥å‚æ•°ï¼š</p>
<ol>
<li>æ³¢é•¿â€œwavelengthâ€ï¼Œ</li>
<li>å…‰æ …å‘¨æœŸâ€œperiodâ€ï¼Œ</li>
<li>â€œtexturesâ€å˜é‡ï¼Œ</li>
<li>å‚…é‡Œå¶è°æ³¢çš„æ•°é‡â€œnnâ€ï¼Œ</li>
<li>å½’ä¸€åŒ–çš„å¹³è¡Œå…¥å°„æ³¢çŸ¢â€œk_parallelâ€ï¼Œ</li>
<li>ä»¥åŠåŒ…å«ä»£ç ä½¿ç”¨çš„æ‰€æœ‰å‚æ•°å€¼å’Œæ‰€é€‰åæŒ¯çš„â€œparmâ€å˜é‡ã€‚</li>
</ol>
<p>å¦‚æœéœ€è¦ç ”ç©¶ç”±åŒä¸€çº¹ç†ç»„æˆçš„ä¸åŒå…‰æ …çš„è¡å°„ï¼Œåˆ™åªéœ€è®¡ç®—ä¸€æ¬¡ç‰¹å¾æ¨¡å¼ã€‚å¯ä»¥å°†â€œaaâ€å˜é‡ä¿å­˜åœ¨ä¸€ä¸ªâ€œ.matâ€æ–‡ä»¶ä¸­ï¼Œå¹¶é‡æ–°åŠ è½½ä»¥è®¡ç®—è¡å°„æ³¢ï¼Œè§é™„å½•10.3ä¸­çš„ç¤ºä¾‹ã€‚</p>
<h2 id="Computing-the-diffracted-waves"><a href="#Computing-the-diffracted-waves" class="headerlink" title="Computing the diffracted waves"></a>Computing the diffracted waves</h2><h3 id="res2ç¨‹åº"><a href="#res2ç¨‹åº" class="headerlink" title="res2ç¨‹åº"></a>res2ç¨‹åº</h3><p><code>è®¡ç®—è¡å°„æ³¢</code> </p>
<p>This is the second step of the computation. This is done by the subroutine â€œres2.mâ€, following the instruction:</p>
<p>è¿™æ˜¯è®¡ç®—çš„ç¬¬äºŒæ­¥ã€‚è¿™æ˜¯é€šè¿‡å­ç¨‹åºâ€œres2.mâ€å®Œæˆçš„ï¼ŒæŒ‰ç…§ä»¥ä¸‹æŒ‡ç¤ºè¿›è¡Œï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = res2(aa, Profile);</span><br></pre></td></tr></table></figure>

<p>This subroutine has 2 input arguments: the output â€œ<strong>aa</strong>â€ of the subroutine â€œres1.mâ€ and the â€œ<strong>Profile</strong>â€ variable. The output argument â€œ<strong>result</strong>â€ contains all the information on the diffracted fields. â€œ<strong>result</strong>â€ is an object of class â€˜reticoloâ€™ that can be indexed as an usual structure with parentheses, or with the labels of the considered orders between curly braces. Examples will be given in the following.</p>
<p>è¿™ä¸ªå­ç¨‹åºæœ‰ä¸¤ä¸ª<code>è¾“å…¥</code>å‚æ•°ï¼š</p>
<ol>
<li>å­ç¨‹åºâ€œres1.mâ€çš„è¾“å‡ºâ€œaaâ€</li>
<li>â€œProfileâ€å˜é‡ã€‚</li>
</ol>
<p>è¾“å‡ºå‚æ•°â€œresultâ€åŒ…å«æ‰€æœ‰å…³äºè¡å°„åœºçš„ä¿¡æ¯ã€‚â€œresultâ€æ˜¯ä¸€ä¸ªâ€˜reticoloâ€™ç±»çš„å¯¹è±¡ï¼Œå¯ä»¥åƒæ™®é€šç»“æ„ä½“ä¸€æ ·ç”¨æ‹¬å·è¿›è¡Œç´¢å¼•ï¼Œæˆ–ä½¿ç”¨å¤§æ‹¬å·ä¸­çš„è€ƒè™‘é˜¶çº§åˆ«çš„æ ‡ç­¾è¿›è¡Œç´¢å¼•ã€‚ç¤ºä¾‹å°†åœ¨æ¥ä¸‹æ¥ç»™å‡ºã€‚</p>
<p>This information is divided into the following sub-structures fields :</p>
<p>è¿™äº›ä¿¡æ¯åˆ†ä¸ºä»¥ä¸‹å­ç¨‹åºç»“æ„<code>è¾“å‡º</code>6ä¸ªå­—æ®µ:</p>
<p>ä»<code>ä¸Šæ–¹</code>å…¥å°„</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- â€œresult. inc_topâ€</span><br><span class="line">- â€œresult. inc_top_reflectedâ€</span><br><span class="line">- â€œresult. inc_top_transmittedâ€</span><br></pre></td></tr></table></figure>

<p>ä»<code>ä¸‹æ–¹</code>å…¥å°„</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- â€œresult. inc_bottomâ€</span><br><span class="line">- â€œresult.inc_bottom_reflectedâ€</span><br><span class="line">- â€œresult. inc_bottom_transmittedâ€</span><br></pre></td></tr></table></figure>



<p>The sub-structure â€œ<strong>result.inc_top_reflected</strong>â€ contains all the information concerning the propagative <em>reflected</em> waves <em>for an incident wave from the top layer</em> of the grating. The incident wave is described in the sub-structure â€œ<strong>result.inc_topâ€</strong>.</p>
<p>å­ç»“æ„â€œresult.inc_top_reflectedâ€åŒ…å«æœ‰å…³æ¥è‡ªå…‰æ …é¡¶å±‚çš„å…¥å°„æ³¢çš„ä¼ æ’­åå°„æ³¢çš„æ‰€æœ‰ä¿¡æ¯ã€‚ å…¥å°„æ³¢åœ¨å­ç»“æ„â€œresult.inc_topâ€ä¸­æè¿°ã€‚</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403165245428.png" srcset="/img/loading.gif" lazyload alt="image-20230403165245428" style="zoom:50%;" />

<p>Fig. 4. The two obtained solutions.   å›¾4. è·å¾—çš„ä¸¤ä¸ªè§£å†³æ–¹æ¡ˆã€‚</p>
<p>Each sub-structure of result is composed of the several fields. Each field is a Matlab column vector or matrix having the same number N of lines. N is the number of propagative orders considered and can be 0.  </p>
<p>resultçš„æ¯ä¸ªå­ç»“æ„ç”±å¤šä¸ªå­—æ®µç»„æˆã€‚æ¯ä¸ªå­—æ®µéƒ½æ˜¯ä¸€ä¸ªMatlabåˆ—å‘é‡æˆ–çŸ©é˜µï¼Œå…·æœ‰ç›¸åŒçš„è¡Œæ•°Nã€‚ Næ˜¯è€ƒè™‘çš„ä¼ æ’­é˜¶æ•°ï¼Œå¯ä»¥ä¸º0ã€‚</p>
<table>
<thead>
<tr>
<th>Field name   å­—æ®µå</th>
<th>Signification   æ„ä¹‰</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>order  é˜¶æ•°</td>
<td>orders of the diffracted  propagative plane waves   è¡å°„ä¼ æ’­å¹³é¢æ³¢çš„é˜¶</td>
<td>N, 1</td>
</tr>
<tr>
<td>theta   Î˜</td>
<td>angle $\theta$m of each diffracted order   æ¯ä¸ªè¡å°„é˜¶æ•°çš„è§’ m</td>
<td>N, 1</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>normalised wave vector   å½’ä¸€åŒ–æ³¢çŸ¢</td>
<td>N, 3</td>
</tr>
<tr>
<td>efficiencyæ•ˆç‡</td>
<td>efficiency of each diffracted  order   æ¯ä¸ªè¡å°„çº§æ•°çš„æ•ˆç‡</td>
<td>N, 1</td>
</tr>
<tr>
<td>amplitude   æŒ¯å¹…</td>
<td>complexe amplitude in TE  polarization of every order   å„é˜¶ TE æåŒ–ä¸­çš„å¤æŒ¯å¹…</td>
<td>N, 1</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>electric field (Ex, Ey, Ez) of the diffracted orders  at O_top or O_bottom when the amplitude of the incident plane wave is one.   å½“å…¥å°„å¹³é¢æ³¢çš„æŒ¯å¹…ä¸º1æ—¶ï¼Œåœ¨ O _ é¡¶æˆ– O _ åº•çš„è¡å°„çº§æ•°çš„ç”µåœº(Exï¼ŒEyï¼ŒEz)</td>
<td>N, 3</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>magnetic field (Hx, Hy, Hz) of the diffracted orders  at O_top or O_bottom when the amplitude of the incident plane wave is one.   å½“å…¥å°„å¹³é¢æ³¢æŒ¯å¹…ä¸º1æ—¶ï¼Œåœ¨ o _ é¡¶æˆ– o _ åº•çš„è¡å°„çº§ç£åœº(Hxï¼ŒHyï¼ŒHz)ã€‚</td>
<td>N, 3</td>
</tr>
<tr>
<td>PlaneWave_E</td>
<td>E-vector  components of the $\overrightarrow{\text{PW}}$ â€™s (in the Oxyz basis) <br /> PW çš„ e å‘é‡åˆ†é‡(åœ¨ Oxyz åŸºç¡€ä¸Š)</td>
<td>N, 3</td>
</tr>
<tr>
<td>PlaneWave_H</td>
<td>H-vector  components of the $\overrightarrow{\text{PW}}$ â€™s (in the Oxyz basis)  <br />PW çš„ h å‘é‡åˆ†é‡(åœ¨ Oxyz åŸºç¡€ä¸Š)</td>
<td>N, 3</td>
</tr>
</tbody></table>
<p> (To use the same notations as in the conical code or in the crossed-grating code, set parm.res1.result&#x3D;-1 before calling res1.m).</p>
<p>(è¦ä½¿ç”¨ä¸é”¥å½¢ä»£ç æˆ–äº¤å‰å…‰æ …ä»£ç ç›¸åŒçš„ç¬¦å·ï¼Œåœ¨è°ƒç”¨ res1.m ä¹‹å‰è®¾ç½® parm.res1.result &#x3D;-1)ã€‚</p>
<h3 id="Efficiencies-æ•ˆç‡"><a href="#Efficiencies-æ•ˆç‡" class="headerlink" title="Efficiencies æ•ˆç‡"></a>Efficiencies æ•ˆç‡</h3><p>For a given diffraction order n, the diffraction efficiency is defined as the ratio between the flux of the diffracted Poynting vector and the flux of the incident Poynting vector (flux through a period of the grating).</p>
<p>å¯¹äºç»™å®šçš„è¡å°„é˜¶æ•°nï¼Œè¡å°„æ•ˆç‡å®šä¹‰ä¸ºè¡å°„PoyntingçŸ¢é‡é€šé‡å’Œå…¥å°„PoyntingçŸ¢é‡é€šé‡ï¼ˆé€šè¿‡å…‰æ …ä¸€ä¸ªå‘¨æœŸçš„é€šé‡ï¼‰ä¹‹æ¯”ã€‚</p>
<p> The efficiencies of all propagative reflected and transmitted waves for an incident wave from the top of the grating are given by the two vectors â€œ<strong>result.inc_top_reflected.efficiency</strong>â€ and â€œ<strong>result.inc_top_transmitted.efficiency</strong>â€. If all refractive indices are real, the sum of all elements of these two vectors is equal to one because of the energy conservation. The labels n of the corresponding orders are in â€œ<strong>result.inc_top_reflected.order</strong>â€ (see below for a description of the other fields of this sub_structure).</p>
<p>å¯¹äºæ¥è‡ªå…‰æ …é¡¶éƒ¨çš„å…¥å°„æ³¢çš„æ‰€æœ‰ä¼ æ’­åå°„å’Œé€å°„æ³¢çš„æ•ˆç‡åˆ†åˆ«ç”±ä¸¤ä¸ªå‘é‡â€œresult.inc_top_reflected.efficiencyâ€å’Œâ€œresult.inc_top_transmitted.efficiencyâ€ç»™å‡ºã€‚ å¦‚æœæ‰€æœ‰æŠ˜å°„ç‡éƒ½æ˜¯å®æ•°ï¼Œåˆ™è¿™ä¸¤ä¸ªå‘é‡çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œç­‰äº1ï¼Œå› ä¸ºèƒ½é‡å®ˆæ’ã€‚ ç›¸åº”é˜¶çº§åˆ«çš„æ ‡ç­¾nåœ¨â€œresult.inc_top_reflected.orderâ€ä¸­ï¼ˆæœ‰å…³æ­¤å­ç»“æ„çš„å…¶ä»–å­—æ®µçš„æè¿°ï¼Œè¯·å‚è§ä¸‹æ–‡ï¼‰</p>
<p> <code>Some examples</code> ä¸€äº›ä¾‹å­</p>
<ol>
<li>The efficiency of the reflected order -2 ($\quad\text{k}_{&#x2F;&#x2F;}\text{&#x3D;}\frac{\text{inc}}{\text{x}}-2\text{K}<em>X\quad$) when the grating is illuminated from the top is equal to result. inc_top_reflected.efficency{-2}. If this order is evanescent, the efficiency is 0.å½“å…‰æ …ä»é¡¶éƒ¨ç…§å°„æ—¶ï¼Œåå°„çº§$\quad\text{k}</em>{&#x2F;&#x2F;}\text{&#x3D;}\frac{\text{inc}}{\text{x}}-2\text{K}_X\quad$çš„æ•ˆç‡ç­‰äºç»“æœã€‚è¡¨é¢åå°„ã€‚æ•ˆç‡{-2}ã€‚å¦‚æœè¿™ä¸ªé¡ºåºæ˜¯æ¶ˆå¤±çš„ï¼Œé‚£ä¹ˆæ•ˆç‡æ˜¯0ã€‚</li>
</ol>
<p>It is important to have in mind the difference between : </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.inc_top_reflected.efficiency&#123;<span class="number">-2</span>&#125; : efficiency of order <span class="number">2</span></span><br><span class="line">result.inc_top_reflected.efficiency(<span class="number">-2</span>) : gives an error !</span><br><span class="line">result.inc_top_reflected.efficiency&#123;<span class="number">2</span>&#125; : efficiency of order <span class="number">2</span></span><br><span class="line">result.inc_top_reflected.efficiency(<span class="number">2</span>) : efficiency in order result. inc_top_reflected.order(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<ol>
<li>The orders of all the transmitted-propagative plane waves for an incident wave from the top of the grating are given by the vector â€œ<strong>result.inc_top_transmitted.order</strong>â€.</li>
</ol>
<p>æ¥è‡ªå…‰æ …é¡¶éƒ¨çš„å…¥å°„æ³¢çš„æ‰€æœ‰ä¼ æ’­é€å°„å¹³é¢æ³¢çš„çº§åˆ«å¯ä»¥åœ¨å‘é‡â€œresult.inc_top_transmitted.orderâ€ä¸­æ‰¾åˆ°ã€‚</p>
<ol>
<li>The efficiencies of all propagative reflected waves for an incident wave from the bottom in TM polarization are given by the vector â€œ<strong>result.inc_bottom_reflected.efficiency</strong>â€.</li>
</ol>
<p>å¯¹äºåœ¨TMåæŒ¯ä¸‹ä»åº•éƒ¨å…¥å°„çš„å…¥å°„æ³¢ï¼Œæ‰€æœ‰ä¼ æ’­åå°„æ³¢çš„æ•ˆç‡ç”±å‘é‡â€œresult.inc_bottom_ reflected.efficiencyâ€ç»™å‡ºã€‚</p>
<h3 id="Rayleigh-expansion-for-propagatives-modes"><a href="#Rayleigh-expansion-for-propagatives-modes" class="headerlink" title="Rayleigh expansion for propagatives modes"></a>Rayleigh expansion for propagatives modes</h3><p>ä¼ æ’­æ¨¡å¼çš„ç‘åˆ©å±•å¼€</p>
<p>The coefficients of the Rayleigh expansion of Fig. 1 can be obtained from the structure <strong>result</strong>. For instance, when the grating is illuminated from the bottom with a TE polarised mode, we have :</p>
<p>å›¾1çš„ç‘åˆ©å±•å¼€ç³»æ•°å¯ç”±ç»“æ„è®¡ç®—ç»“æœå¾—åˆ°ã€‚ä¾‹å¦‚ï¼Œå½“å…‰æ …ä»åº•éƒ¨ç”¨ TE åæŒ¯æ¨¡å¼ç…§æ˜æ—¶ï¼Œæˆ‘ä»¬æœ‰:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ebottom =result.inc_bottom_reflected.E&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Hbottom =result inc_bottom_reflected.H&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Etop =result.inc_bottom_transmitted.E&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Htop =result.inc_bottom_ transmitted.H&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br></pre></td></tr></table></figure>

<p>and the incident plane wave defined in page 4 is given by :</p>
<p>ç¬¬4é¡µä¸­å®šä¹‰çš„å…¥å°„å¹³é¢æ³¢ç”±ä»¥ä¸‹äººå‘˜ç»™å‡º:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ebottom =result inc_bottom.E (<span class="number">3</span> components in Oxyz)</span><br><span class="line">inc</span><br><span class="line">Hbottom =result.inc_bottom.H (<span class="number">3</span> components in Oxyz).</span><br></pre></td></tr></table></figure>

<h3 id="Amplitude-of-diffracted-propagative-waves"><a href="#Amplitude-of-diffracted-propagative-waves" class="headerlink" title="Amplitude of diffracted propagative waves"></a>Amplitude of diffracted propagative waves</h3><p>è¡å°„ä¼ æ’­æ³¢çš„æŒ¯å¹…</p>
<h4 id="å…¥å°„è§’åº¦-Angle-theta-m"><a href="#å…¥å°„è§’åº¦-Angle-theta-m" class="headerlink" title="å…¥å°„è§’åº¦ Angle $\theta_m$"></a>å…¥å°„è§’åº¦ Angle $\theta_m$</h4><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403170721968.png" srcset="/img/loading.gif" lazyload alt="image-20230403170721968" style="zoom:50%;" />



<p>Fig. 5 qm angles. å›¾5m è§’ã€‚</p>
<p>The angle qm related to order m is varying between â€“90 and 90. It is oriented in such a way that the k-parallel momentum of the corresponding wave vector (incident or diffracted) is</p>
<p>ä¸é˜¶æ•°mç›¸å…³çš„è§’åº¦Î¸måœ¨-90åº¦è‡³90åº¦ä¹‹é—´å˜åŒ–ã€‚å®ƒçš„æ–¹å‘å®‰æ’æ˜¯è¿™æ ·çš„ï¼Œä½¿å¾—ç›¸åº”æ³¢çŸ¢ï¼ˆå…¥å°„æˆ–è¡å°„ï¼‰çš„k-parallelåŠ¨é‡ä¸ºï¼š</p>
<p>$\text{k_x}^{\text{inc}}+\text{mk_x}&#x3D;(2\pi&#x2F;\lambda)\text{n_top}\sin(\Theta_\text{m})\text or (2\pi&#x2F;\lambda)\text{n_bottom_}\sin(\Theta_\text{m})$ æœ‰ç‚¹é”™è¯¯</p>
<p>$$</p>
<p>&#x3D; (2Ï€&#x2F;Î») n_top sin(qm) or (2Ï€&#x2F;Î») n_bottom_sin(qm).</p>
<h3 id="O-top-and-O-bottom-points-æœ€é«˜ç‚¹å’Œæœ€ä½ç‚¹"><a href="#O-top-and-O-bottom-points-æœ€é«˜ç‚¹å’Œæœ€ä½ç‚¹" class="headerlink" title="$O_{top}$ and $O_{bottom}$ points æœ€é«˜ç‚¹å’Œæœ€ä½ç‚¹"></a>$O_{top}$ and $O_{bottom}$ points æœ€é«˜ç‚¹å’Œæœ€ä½ç‚¹</h3><p>Otop and Obottom are 2 important points (see Fig. 1). In the Cartesian coordinates system Oxyz , they are defined by: Otop&#x3D;(0,0,h) at the top of the grating, and Obottom&#x3D;(0,0,0) at the bottom of the grating.</p>
<p>Otopå’ŒObottomæ˜¯ä¸¤ä¸ªé‡è¦ç‚¹ï¼ˆè§å›¾1ï¼‰ã€‚ åœ¨ç¬›å¡å°”åæ ‡ç³»Oxyzä¸­ï¼Œå®ƒä»¬åˆ†åˆ«å®šä¹‰ä¸ºï¼š</p>
<p>Otop &#x3D;ï¼ˆ0,0ï¼Œhï¼‰åœ¨å…‰æ …é¡¶éƒ¨ï¼Œ Obottom &#x3D;ï¼ˆ0,0,0ï¼‰åœ¨å…‰æ …åº•éƒ¨ã€‚</p>
<p>In addition, let us consider an arbitrary point M&#x3D;(x,y,z) in the 3D space in Oxyz. Associated to this point, we define the two vectors :</p>
<p>å¦å¤–ï¼Œè®©æˆ‘ä»¬è€ƒè™‘Oxyzä¸­ä¸‰ç»´ç©ºé—´ä¸­çš„ä»»æ„ç‚¹M &#x3D;ï¼ˆxï¼Œyï¼Œzï¼‰ã€‚ ä¸æ­¤ç‚¹ç›¸å…³è”ï¼Œæˆ‘ä»¬å®šä¹‰ä¸¤ä¸ªå‘é‡ï¼š</p>
<p>$\quad\mathbf{r}<em>{\text{top}&#x3D;}\overline{\mathrm{O}</em>{\text{top}}{\text{M}}}$, and</p>
<p>$\quad\mathbf{r}<em>{\text{bottom}&#x3D;}\overline{\mathrm{O}</em>{\text{bottom}}{\text{M}}}$.</p>
<h3 id="Jonesâ€™-coefficient-ç¼æ–¯ç³»æ•°"><a href="#Jonesâ€™-coefficient-ç¼æ–¯ç³»æ•°" class="headerlink" title="Jonesâ€™ coefficient ç¼æ–¯ç³»æ•°"></a>Jonesâ€™ coefficient ç¼æ–¯ç³»æ•°</h3><p>Let us assume that the grating is illuminated from the top layer and let us consider a diffracted order m in the bottom layer. Any other diffraction situation is straighforwardly deduced.</p>
<p>è®©æˆ‘ä»¬å‡è®¾å…‰æ …æ˜¯ä»é¡¶å±‚ç…§æ˜ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªè¡å°„é˜¶æ•° m åœ¨åº•å±‚ã€‚ä»»ä½•å…¶ä»–è¡å°„æƒ…å†µéƒ½æ˜¯ç›´æ¥æ¨å¯¼å‡ºæ¥çš„ã€‚</p>
<p>Let Î± be a given complex number. The incident electromagnetic field (6 components of <strong>E</strong> and <strong>H</strong> in every points of the 3D space) can be written :</p>
<p>è®¾ Î± æ˜¯ç»™å®šçš„å¤æ•°ã€‚å…¥å°„ç”µç£åœº(ä¸‰ç»´ç©ºé—´ä¸­æ¯ä¸ªç‚¹ä¸Šçš„ e å’Œ h çš„6ä¸ªåˆ†é‡)å¯ä»¥å†™æˆ:</p>
<p>$\mathbf{W}^{\text{inc}}&#x3D;\alpha\overrightarrow{\mathbf{PW}}$</p>
<p>where PW is a plane wave defined in every point by PW&#x3D;A exp(ikinc top rtop), A being the electromagnetic fields (6 components) of the plane wave at M&#x3D;Otop, and kinc top is the incident wave vector. A and K&#x3D;kinc top &#x2F; kinc top are given by the structure â€œresultâ€œ as will be defined later.</p>
<p>Similarly, the diffracted electromagnetic field in the m bottom order can be written :</p>
<p>å…¶ä¸­ï¼ŒPWæ˜¯ç”±PW &#x3D; A expï¼ˆikinc top rtopï¼‰åœ¨æ¯ä¸ªç‚¹å®šä¹‰çš„å¹³é¢æ³¢ï¼Œå…¶ä¸­Aæ˜¯å¹³é¢æ³¢åœ¨M &#x3D; Otopå¤„çš„ç”µç£åœºï¼ˆ6ä¸ªåˆ†é‡ï¼‰ï¼Œè€Œkinc topæ˜¯å…¥å°„æ³¢çŸ¢é‡ã€‚å‘é‡Aå’ŒK &#x3D; kinc top &#x2F; kinc topç”±ç»“æ„â€œresultâ€ç»™å‡ºï¼Œç¨åå°†è¿›è¡Œå®šä¹‰ã€‚</p>
<p>åŒæ ·åœ°ï¼Œmçº§åˆ«çš„è¡å°„ç”µç£åœºå¯ä»¥å†™æˆï¼š</p>
<p>$\mathbf{W}_\mathrm{m}^{\mathrm{dif}}&#x3D;\gamma\overline{\mathbf{PW^m}}$</p>
<p>where $\gamma$ is a complex number, PWm is a plane wave defined in every point by PWm&#x3D;Am exp (ikm bottom rbottom ), Am is the electromagnetic fields (6 components) of the plane wave at M&#x3D;Obottom, and km bottom is the wave vector of the mth transmitted order. Am and, Km&#x3D;kmbottom &#x2F; kmbottom are given by the structure â€œresultâ€œ as will be defined later.</p>
<p>We define the Jonesâ€™coefficient J, associated to the order m by</p>
<p>å…¶ä¸­ï¼ŒÎ³æ˜¯ä¸€ä¸ªå¤æ•°ï¼ŒPWmæ˜¯ç”±PWm &#x3D; Am expï¼ˆikm bottom rbottomï¼‰åœ¨æ¯ä¸ªç‚¹å®šä¹‰çš„å¹³é¢æ³¢ï¼Œå…¶ä¸­Amæ˜¯å¹³é¢æ³¢åœ¨M &#x3D; Obottomå¤„çš„ç”µç£åœºï¼ˆ6ä¸ªåˆ†é‡ï¼‰ï¼Œè€Œkm bottomæ˜¯ç¬¬mä¸ªé€å°„çº§åˆ«çš„æ³¢çŸ¢é‡ã€‚å‘é‡Amå’ŒKm &#x3D; kmbottom &#x2F; kmbottomç”±ç»“æ„â€œresultâ€ç»™å‡ºï¼Œç¨åå°†è¿›è¡Œå®šä¹‰ã€‚</p>
<p>æˆ‘ä»¬é€šè¿‡å®šä¹‰ä¸é˜¶æ•°mç›¸å…³è”çš„Jonesç³»æ•°Jæ¥å®Œæˆï¼š</p>
<p>å¾…æ·»åŠ </p>
<p>â€‹                 </p>
<h2 id="Using-symmetries-to-accelerate-the-computational-speed"><a href="#Using-symmetries-to-accelerate-the-computational-speed" class="headerlink" title="Using symmetries to accelerate the computational speed"></a>Using symmetries to accelerate the computational speed</h2><p><code>ä½¿ç”¨å¯¹ç§°æ€§æ¥åŠ å¿«è®¡ç®—é€Ÿåº¦</code></p>
<p>When the grating possesses some mirror symmetry for the plane x&#x3D;x0, one may define â€œparm.sym.x&#x3D; x0. Then</p>
<p>when k_parallel &#x3D;0, the code will use the symmetry property for speeding up the calculation.</p>
<p>å½“å…‰æ …åœ¨x &#x3D; x0å¹³é¢å¤„å…·æœ‰æŸäº›é•œåƒå¯¹ç§°æ€§æ—¶ï¼Œå¯ä»¥å®šä¹‰â€œparm.sym.x &#x3D; x0â€ã€‚ç„¶åï¼Œå½“k_parallel &#x3D; 0æ—¶ï¼Œä»£ç å°†ä½¿ç”¨å¯¹ç§°æ€§å±æ€§åŠ å¿«è®¡ç®—é€Ÿåº¦ã€‚</p>
<p>Note that the code does not verify if the symmetries of the grating defined by the user are in agreement with the â€œtexturesâ€ parameters. It is up to the user to define carefully the parameters parm.sym.x. All textures used in the calculation must possess the same symmetry.</p>
<p>è¯·æ³¨æ„ï¼Œä»£ç ä¸éªŒè¯ç”¨æˆ·å®šä¹‰çš„å…‰æ …çš„å¯¹ç§°æ€§æ˜¯å¦ä¸â€œtexturesâ€å‚æ•°ä¸€è‡´ã€‚ç”¨æˆ·å¿…é¡»ä»”ç»†å®šä¹‰å‚æ•°parm.sym.xã€‚è®¡ç®—ä¸­ä½¿ç”¨çš„æ‰€æœ‰çº¹ç†å¿…é¡»å…·æœ‰ç›¸åŒçš„å¯¹ç§°æ€§ã€‚</p>
<h2 id="Plotting-the-electromagnetic-field-and-calculating-the-absorption-loss"><a href="#Plotting-the-electromagnetic-field-and-calculating-the-absorption-loss" class="headerlink" title="Plotting the electromagnetic field and calculating the absorption loss"></a>Plotting the electromagnetic field and calculating the absorption loss</h2><h3 id="res3ç¨‹åº"><a href="#res3ç¨‹åº" class="headerlink" title="res3ç¨‹åº"></a>res3ç¨‹åº</h3><p><code>ç»˜åˆ¶ç”µç£åœºå¹¶è®¡ç®—å¸æ”¶æŸè€—</code></p>
<p>Computation of the electromagnetic fields è®¡ç®—ç”µç£åœº</p>
<p>Once the eigenmodes associated to all textures are known, the calculation of the electromagnetic fields everywhere in the grating can be performed. This calculation is done by the function â€œ<strong>res3.m</strong>â€, following the instruction:</p>
<p>ä¸€æ—¦çŸ¥é“äº†æ‰€æœ‰çº¹ç†çš„æœ¬å¾æ¨¡å¼ï¼Œå°±å¯ä»¥è®¡ç®—å…‰æ …ä¸­å„å¤„çš„ç”µç£åœºã€‚è¿™ä¸ªè®¡ç®—æ˜¯ç”±å‡½æ•°â€œ res3.mâ€æŒ‰ç…§æŒ‡ä»¤å®Œæˆçš„:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[e,z,index] = res3(x,aa,Profile, inc,parm);</span><br></pre></td></tr></table></figure>

<p>The functionâ€œres3.mâ€ can be called without calling â€œres2.mâ€. This subroutine has 5 input arguments:<br>-the â€œxâ€ variable is a vector containing the locations where the fields will be calculated in the x-direction [for<br>instance we may set x &#x3D; linspace(-period_x&#x2F;2, period_x&#x2F;2, 51); for allocating 51 sampling points in the xdirection],<br>the â€œaaâ€ variable contains all the information on the eigenmodes of all textures and is computed by the subroutine<br>res1.m,<br>-the variable â€œProfileâ€ is defined in Section 4.2; note that it can be redefined,<br>-the variable â€œincâ€ defines the y component of the complex amplitude of the incident electric (in TE polarisation)<br>or magnetic field (in TM polarisation) field at O_top or O_bottom .<br>For illuminating the grating exactly by the TE-polarized incident PW defined above, one should set:<br>einc&#x3D; result.inc_top PlaneWave_E(2) for TE polarisation; einc&#x3D; result.inc_top PlaneWave_H(2) for TM<br>polarisation.<br>-the â€œparmâ€ variable, already mentioned is discussed in the following.<br>There are three possible output arguments for the subroutine â€œres3.mâ€. The variable â€œeâ€ contains all the<br>electromagnetic field quantities:  </p>
<p>å‡½æ•°â€œres3.mâ€å¯ä»¥åœ¨ä¸è°ƒç”¨â€œres2.mâ€çš„æƒ…å†µä¸‹è°ƒç”¨ã€‚è¯¥å­ç¨‹åºå…·æœ‰<code>5ä¸ªè¾“å…¥</code>å‚æ•°ï¼š </p>
<ol>
<li><p>â€œxâ€å˜é‡æ˜¯ä¸€ä¸ªå‘é‡ï¼Œå…¶ä¸­åŒ…å«åœ¨xæ–¹å‘ä¸Šè®¡ç®—åœºçš„ä½ç½®[ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å°†x &#x3D; linspaceï¼ˆ- period_x &#x2F; 2ï¼Œperiod_x &#x2F; 2ï¼Œ51ï¼‰;åˆ†é…51ä¸ªé‡‡æ ·ç‚¹ä»¥åœ¨xæ–¹å‘è¿›è¡Œé‡‡æ ·]ï¼Œ</p>
</li>
<li><p>â€œaaâ€å˜é‡åŒ…å«æ‰€æœ‰çº¹ç†çš„ç‰¹å¾æ¨¡å¼ä¿¡æ¯ï¼Œå¹¶ç”±å­ç¨‹åºres1.mè®¡ç®—</p>
</li>
<li><p>å˜é‡â€œProfileâ€åœ¨ç¬¬4.2èŠ‚ä¸­å®šä¹‰ã€‚è¯·æ³¨æ„ï¼Œå®ƒå¯ä»¥é‡æ–°å®šä¹‰</p>
</li>
<li><p>å˜é‡â€œincâ€å®šä¹‰å…¥å°„ç”µåœºçš„å¤æŒ¯å¹…çš„yåˆ†é‡ï¼ˆåœ¨TEåæŒ¯ä¸­ï¼‰æˆ–ç£åœºï¼ˆåœ¨TMåæŒ¯ä¸­ï¼‰åœ¨O_topæˆ–O_bottomå¤„ã€‚ ä¸ºäº†ç²¾ç¡®åœ°ç”¨ä¸Šè¿°TEåæŒ¯å…¥å°„PWç…§æ˜å…‰æ …ï¼Œåº”è®¾ç½®ï¼š å¯¹äºTEåæŒ¯ï¼Œeinc &#x3D; result.inc_top PlaneWave_Eï¼ˆ2ï¼‰;å¯¹äºTMåæŒ¯ï¼Œeinc &#x3D; result.inc_top PlaneWave_Hï¼ˆ2ï¼‰ã€‚ </p>
</li>
<li><p>â€œparmâ€å˜é‡æ˜¯å·²ç»æåˆ°çš„ï¼Œåœ¨ä¸‹é¢è¿›è¡Œäº†è®¨è®ºã€‚</p>
</li>
</ol>
<p>å­ç¨‹åºâ€œres3.mâ€æœ‰<code>ä¸‰ä¸ª</code>è¾“å‡ºå˜é‡ã€‚</p>
<ul>
<li>â€œeâ€å˜é‡åŒ…å«æ‰€æœ‰ç”µç£åœºé‡ï¼š</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ey=e(:,:,<span class="number">1</span>); Hx=e(:,:,<span class="number">2</span>); Hz=e(:,:,<span class="number">3</span>); in TE polarization.</span><br><span class="line">Hy=e(:,:,<span class="number">1</span>); Ex=e(:,:,<span class="number">2</span>); Ez=e(:,:,<span class="number">3</span>); in TM polarization.</span><br></pre></td></tr></table></figure>

<p>The second variable â€œzâ€ is the vector containing the z-coordinate of the sampling points. Note that in the matrix Ex&#x3D;e(:,:,1), the first index refer to the z coordinate, and the second to the x-coordinate. Thus Ex(i,j) is the Ex field component at the location {z(i), x(j)}. The third variable â€œindexâ€ is the complex refractive index of the considered grating. index(i,j) is the refractive index at the location {z(i), x(j)}. It can be useful to test the profile of the grating.</p>
<ul>
<li>ç¬¬äºŒä¸ªå˜é‡â€œzâ€æ˜¯åŒ…å«é‡‡æ ·ç‚¹zåæ ‡çš„å‘é‡ã€‚è¯·æ³¨æ„ï¼Œåœ¨çŸ©é˜µEx &#x3D; eï¼ˆï¼šï¼Œï¼šï¼Œ1ï¼‰ä¸­ï¼Œç¬¬ä¸€ä¸ªç´¢å¼•æ˜¯zåæ ‡ï¼Œç¬¬äºŒä¸ªæ˜¯xåæ ‡ã€‚ å› æ­¤ï¼ŒExï¼ˆiï¼Œjï¼‰æ˜¯ä½äº{zï¼ˆiï¼‰ï¼Œxï¼ˆjï¼‰}ä½ç½®å¤„çš„Exåœºåˆ†é‡ã€‚ç¬¬ä¸‰ä¸ªå˜é‡â€œindexâ€æ˜¯æ‰€è€ƒè™‘å…‰æ …çš„å¤æŠ˜å°„ç‡ã€‚ indexï¼ˆiï¼Œjï¼‰æ˜¯åœ¨{zï¼ˆiï¼‰ï¼Œxï¼ˆjï¼‰}ä½ç½®å¤„çš„æŠ˜å°„ç‡ã€‚å®ƒå¯ä»¥ç”¨äºæµ‹è¯•å…‰æ …çš„è½®å»“ã€‚</li>
</ul>
<p>Some <strong>important</strong> comments on the <strong>parm</strong>â€ variable : å…³äºâ€œparmâ€å˜é‡çš„ä¸€äº›é‡è¦æ³¨é‡Šï¼š</p>
<ol>
<li>For calculating precisely the electromagnetics fields, one has to set : â€<strong>parm.res1.champ&#x3D;1â€</strong> before calling <strong>res1.m.</strong> This increases the calculation time and memory load, but it is highly recommended. If not, the computation of the field will be correct only in homogenous textures (for example in the top layer and in the bottom layer). 1.ä¸ºäº†ç²¾ç¡®è®¡ç®—ç”µç£åœºï¼Œå¿…é¡»åœ¨è°ƒç”¨res1.mä¹‹å‰è®¾ç½®ï¼šâ€œparm.res1.champ&#x3D;1â€ã€‚è¿™ä¼šå¢åŠ è®¡ç®—æ—¶é—´å’Œå†…å­˜è´Ÿè·ï¼Œä½†å¼ºçƒˆå»ºè®®è¿™æ ·åšã€‚å¦åˆ™ï¼Œåœ¨å‡åŒ€çº¹ç†ï¼ˆä¾‹å¦‚åœ¨é¡¶å±‚å’Œåº•å±‚ï¼‰ä¸­æ‰èƒ½æ­£ç¡®è®¡ç®—åœºã€‚</li>
<li>Illuminating the grating from the top or the bottom layer : As mentioned earlier, the code compute the diffraction efficiencies of the transmitted and reflected orders for an incident plane wave from the top and for an incident plane wave from the bottom at the same time. When plotting the field, the user must specify the direction of the incident plane wave. This is specified with variable <strong>parm.res3.sens</strong>. For <strong>parm.res3.sens&#x3D;1</strong>, the grating is illuminated from the top and for <strong>parm.res3.sens&#x3D;-1</strong>, the grating is illuminated from the bottom (default is <strong>parm.res3.sens&#x3D;1)</strong>. 2.ä»é¡¶å±‚æˆ–åº•å±‚ç…§å°„å…‰æ …ï¼šå¦‚å‰æ‰€è¿°ï¼Œè¯¥ä»£ç åŒæ—¶è®¡ç®—ä»é¡¶éƒ¨å’Œä»åº•éƒ¨å…¥å°„å¹³é¢æ³¢çš„é€å°„å’Œåå°„é˜¶æ•°çš„è¡å°„æ•ˆç‡ã€‚åœ¨ç»˜åˆ¶åœºæ—¶ï¼Œç”¨æˆ·å¿…é¡»æŒ‡å®šå…¥å°„å¹³é¢æ³¢çš„æ–¹å‘ã€‚è¿™æ˜¯ä½¿ç”¨å˜é‡parm.res3.sensæŒ‡å®šçš„ã€‚å¯¹äºparm.res3.sens &#x3D; 1ï¼Œä»é¡¶éƒ¨ç…§äº®å…‰æ …ï¼Œè€Œparm.res3.sens &#x3D; -1åˆ™ä»åº•éƒ¨ç…§äº®å…‰æ …ï¼ˆé»˜è®¤å€¼ä¸ºparm.res3.sens &#x3D; 1ï¼‰ã€‚</li>
<li>Specifying the z locations of the computed fields: This is provided by the variable <strong>parm.res3.npts</strong>. <strong>parm.res3.npts</strong> is a vector whose length is equal to the number of layers. For instance let us imagine, a grating defined by <strong>Profile</strong> &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}. Setting <strong>parm.res3.npts&#x3D;[2,3,4,5]</strong> implies that the field will be computed in two z&#x3D;constant plans in the top layer, in three z&#x3D;constant plans in the first layer (texture 2), in four z&#x3D;constant plans in the second layer (texture 3), and in five z&#x3D;constant plans in the bottom layer. Default for <strong>parm.res3.npts</strong> is 10 z&#x3D;constant plans per layer. æŒ‡å®šè®¡ç®—åœºçš„zä½ç½®ï¼šè¿™ç”±å˜é‡parm.res3.nptsæä¾›ã€‚parm.res3.nptsæ˜¯ä¸€ä¸ªå‘é‡ï¼Œå…¶é•¿åº¦ç­‰äºå±‚æ•°ã€‚ä¾‹å¦‚ï¼Œå‡è®¾å­˜åœ¨ä¸€ä¸ªç”±Profile &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}å®šä¹‰çš„å…‰æ …ã€‚è®¾ç½®parm.res3.npts&#x3D;[2,3,4,5]æ„å‘³ç€å°†åœ¨é¡¶å±‚çš„ä¸¤ä¸ªz &#x3D; constantå¹³é¢ä¸­è®¡ç®—åœºï¼Œåœ¨ç¬¬ä¸€å±‚ï¼ˆçº¹ç†2ï¼‰ä¸­çš„ä¸‰ä¸ªz &#x3D; constantå¹³é¢ä¸­è®¡ç®—åœºï¼Œåœ¨ç¬¬äºŒå±‚ï¼ˆçº¹ç†3ï¼‰ä¸­çš„å››ä¸ªz &#x3D; constantå¹³é¢ä¸­è®¡ç®—åœºï¼Œå¹¶åœ¨åº•å±‚çš„äº”ä¸ªz &#x3D; constantå¹³é¢ä¸­è®¡ç®—åœºã€‚parm.res3.nptsçš„é»˜è®¤å€¼æ˜¯æ¯å±‚10ä¸ªz &#x3D; constantå¹³é¢ã€‚</li>
</ol>
<p><code>VERY IMPORTANT</code> éå¸¸é‡è¦</p>
<p>where is the z&#x3D;0 plan and what are the z-coordinates of the z&#x3D;constant plan? The z&#x3D;0 plan is defined at the bottom of the bottom layer. Thus, the field calculation is performed only for z&gt;0 values. For the example <strong>Profile</strong> &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}, and if we refer to texture 4 as the substrate, the z&#x3D;0 plan is located in the substrate at a distance 0.6 under the grating. The z&#x3D;constant plans are located by an equidistant sampling in every layer. Always referring to the previous example, it implies that the five z&#x3D;constant plans in the substrate are located at coordinate z&#x3D;(p-0.5) 0.6&#x2F;5, where p&#x3D;1,2,â€¦5. Note that the z coordinates for the z&#x3D;constant plans are always given by the second output variable of res3.m.</p>
<p>z&#x3D;0å¹³é¢åœ¨åº•å±‚åº•éƒ¨å®šä¹‰ã€‚å› æ­¤ï¼Œåœºè®¡ç®—ä»…åœ¨z&gt; 0å€¼æ—¶æ‰§è¡Œã€‚å¯¹äºç¤ºä¾‹Profile &#x3D; {[0.5,1,2,0.6]ï¼Œ[1,2,3,4]}ï¼Œå¦‚æœå°†çº¹ç†4ç§°ä¸ºåŸºæ¿ï¼Œåˆ™z &#x3D; 0å¹³é¢ä½äºå…‰æ …ä¸‹0.6çš„è·ç¦»å¤„çš„åŸºæ¿ä¸Šã€‚ z &#x3D; constantå¹³é¢æ˜¯åœ¨æ¯ä¸ªå±‚ä¸­é€šè¿‡ç­‰è·é‡‡æ ·æ¥å®šä½çš„ã€‚å§‹ç»ˆå‚è€ƒä¹‹å‰çš„ä¾‹å­ï¼Œæ„å‘³ç€åº•å±‚ä¸­çš„äº”ä¸ªz &#x3D; constantå¹³é¢ä½äºz &#x3D;ï¼ˆp-0.5ï¼‰0.6&#x2F;5çš„åæ ‡å¤„ï¼Œå…¶ä¸­p &#x3D; 1,2ï¼Œâ€¦ 5ã€‚è¯·æ³¨æ„ï¼Œz &#x3D; constantå¹³é¢çš„zåæ ‡å§‹ç»ˆç”±res3.mçš„ç¬¬äºŒä¸ªè¾“å‡ºå˜é‡ç»™å‡ºã€‚</p>
<ol start="4">
<li><p>How can one specify a given z&#x3D;constant plan? First, one has to redefine the variable <strong>Profile</strong>. For the grating example with the two layers discussed above, let us imagine that one wants to plot the field at z&#x3D;z0+0.6+0.2 in layer 2. Then one has to set: <strong>Profile</strong> &#x3D; {[0.5,1-z0,0,z0,0.2,0.6],[1,2,2,2,3,4]} and set <strong>parm.res3.npts&#x3D;[0,0,1,0,0,0]</strong>. Note that it is not necessary to redefine the variable <strong>Profile</strong> at the beginning of the program. One just needs to redefine this variable before calling subroutine res3.m. å¦‚ä½•æŒ‡å®šç»™å®šçš„z &#x3D; constantå¹³é¢ï¼Ÿé¦–å…ˆï¼Œå¿…é¡»é‡æ–°å®šä¹‰å˜é‡Profileã€‚å¯¹äºä¸Šé¢è®¨è®ºçš„ä¸¤ä¸ªå±‚çš„å…‰æ …ç¤ºä¾‹ï¼Œå‡è®¾æƒ³è¦åœ¨ç¬¬2å±‚çš„z &#x3D; z0 + 0.6 + 0.2å¤„ç»˜åˆ¶åœºã€‚ç„¶åï¼Œå¿…é¡»è®¾ç½®ï¼šProfile &#x3D; {[0.5,1-z0,0,z0,0.2,0.6]ï¼Œ[1,2,2,2,3,4]}ï¼Œå¹¶è®¾ç½®parm.res3.npts &#x3D; [0,0,1,0,0,0]ã€‚è¯·æ³¨æ„ï¼Œåœ¨ç¨‹åºå¼€å¤´é‡æ–°å®šä¹‰å˜é‡Profileæ˜¯ä¸å¿…è¦çš„ã€‚åªéœ€è¦åœ¨è°ƒç”¨å­ç¨‹åºres3.mä¹‹å‰é‡æ–°å®šä¹‰æ­¤å˜é‡å³å¯ã€‚</p>
</li>
<li><p>Automatic plots: an automatic plot (showing all the components of the electromagnetic fields and the grating refractive index distribution) is provided by setting <strong>parm.res3.trace</strong>&#x3D;1. If one wants to plot only some components of the fields, one can set for instance in TE polarization: <strong>parm.res3.champs</strong>&#x3D;[1,0] to plot Ey and the objet, <strong>parm.res3.champs</strong>&#x3D;[2] to plot only Hx. è‡ªåŠ¨ç»˜å›¾ï¼šé€šè¿‡è®¾ç½®parm.res3.trace &#x3D; 1ï¼Œå¯ä»¥æä¾›è‡ªåŠ¨ç»˜å›¾ï¼ˆæ˜¾ç¤ºç”µç£åœºå’Œå…‰æ …æŠ˜å°„ç‡åˆ†å¸ƒçš„æ‰€æœ‰ç»„ä»¶ï¼‰ã€‚å¦‚æœåªæƒ³ç»˜åˆ¶åœºçš„æŸäº›ç»„ä»¶ï¼Œåˆ™å¯ä»¥åœ¨TEåæŒ¯ä¸­è®¾ç½®ä¾‹å¦‚parm.res3.champs &#x3D; [1,0]ç»˜åˆ¶Eyå’Œç‰©ä½“ï¼Œparm.res3.champs &#x3D; [2]åªç»˜åˆ¶Hxã€‚</p>
</li>
</ol>
<h3 id="Computation-of-the-absorption-loss"><a href="#Computation-of-the-absorption-loss" class="headerlink" title="Computation of the absorption loss"></a>Computation of the absorption loss</h3><p>å¸æ”¶æŸå¤±çš„è®¡ç®—</p>
<p>Loss computation is performed with the subroutine â€œ<strong>res3.m</strong>â€.</p>
<p>æŸè€—è®¡ç®—ä½¿ç”¨å­ç¨‹åºâ€œ res3.mâ€æ‰§è¡Œã€‚</p>
<p>First approach based on integrals (not valid for homogeneous layers with non-diagonal anisotropy): The absorption loss in a surface ğ‘† is given by:</p>
<p>ç¬¬ä¸€ç§åŸºäºç§¯åˆ†çš„æ–¹æ³•ï¼ˆä¸é€‚ç”¨äºå…·æœ‰éå¯¹è§’å„å‘åŒæ€§çš„å‡åŒ€å±‚ï¼‰ï¼š</p>
<p>è¡¨é¢ğ‘†çš„å¸æ”¶æŸè€—ç”±ä»¥ä¸‹å…¬å¼ç»™å‡ºï¼š</p>
<p> ğ¿ &#x3D; ğœ‹ âˆ« ğ¼ğ‘š ğœ€(ğ‘€) |ğ¸ (ğ‘€)|2 ğ‘‘ğ‘† for TE polarization.</p>
<p>ğ¿ &#x3D; ğœ‹ âˆ« ğ¼ğ‘š (ğœ€ğ‘‹ğ‘‹(ğ‘€)|ğ¸ğ‘‹(ğ‘€)|2 + ğœ€ğ‘ğ‘(ğ‘€)|ğ¸ğ‘§(ğ‘€)|2) ğ‘‘ğ‘† for TM polarization.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[e, Z, index, wZ, loss_per_layer, loss_of_Z, loss_of_Z_X, X, wX] = res3(x,aa,Profile,einc,parm);</span><br></pre></td></tr></table></figure>

<p>The important ouput arguments are: é‡è¦çš„è¾“å‡ºå‚æ•°æ˜¯:</p>
<p><strong>loss_per_layer</strong>: the loss in every layer defined by <strong>Profile</strong>, <strong>loss_per_layer</strong>(1) is the loss in the top layer, loss_per_layer(2) is the loss in layer 2, â€¦ and loss_per_layer(end) is the loss in the bottom layer </p>
<p>loss_of_Z: the absorption loss density (integrated over X) as a function of Z (like for X, the sampling points Z are not equidistant. You may plot this loss density as follows: plot(Z, loss_of_Z), xlabel(â€˜Zâ€™), ylabel(â€˜absorptionâ€™) </p>
<p>loss_of_Z_X(Z,X) &#x3D; Ï€&#x2F;Î» Im(index(Z,X).^2) |e(Z,X,1)|2 in TE polarization </p>
<p>loss_of_Z_X(Z,X) &#x3D; Ï€&#x2F;Î» Im(index(Z,X).^2) ( e(Z,X,2)|2+|e(Z,X,3)|2) in TM polarization </p>
<p>index: index(i,j) is the complex refractive index at the location {z(i), x(j)}.</p>
<p>æ¯å±‚æŸè€—: ç”± Profile å®šä¹‰çš„æ¯å±‚æŸè€—ï¼Œæ¯å±‚æŸè€—(1)æ˜¯é¡¶å±‚æŸè€—ï¼Œæ¯å±‚æŸè€—(2)æ˜¯ç¬¬2å±‚æŸè€—ï¼Œâ€¦ æ¯å±‚æŸè€—(æœ«ç«¯)æ˜¯åº•å±‚æŸè€—(z) : å¸æ”¶æŸè€—å¯†åº¦(åœ¨ x ä¸Šç§¯åˆ†)ä¸ z çš„å‡½æ•°å…³ç³»(å¦‚ xï¼Œå–æ ·ç‚¹ z ä¸ç­‰è·)ã€‚æ‚¨å¯ä»¥å°†è¿™ä¸ªæŸå¤±å¯†åº¦ç»˜åˆ¶å¦‚ä¸‹: ç»˜å›¾(zï¼Œ_ z çš„æŸå¤±) ï¼Œxlabel (â€˜ zâ€™) ï¼Œylabel (â€˜å¸æ”¶â€™) _ z _ x (zï¼Œx)çš„æŸå¤± _ &#x3D; Ï€&#x2F;Î»im (æŒ‡æ•°(zï¼Œx)ã€‚_ z _ x (zï¼Œx) &#x3D; Ï€&#x2F;Î»im (index (zï¼Œx)çš„ TE åæŒ¯æŸè€— _ ä¸­çš„ ^ 2) | e (zï¼Œxï¼Œ1) | 2ã€‚TM åæŒ¯æŒ‡æ•°ä¸­çš„ ^ 2)(e (zï¼Œxï¼Œ2) | 2 + | e (zï¼Œxï¼Œ3) | 2) : æŒ‡æ•°(iï¼Œj)æ˜¯{ z (i) ï¼Œx (j)}å¤„çš„å¤æŠ˜å°„ç‡ã€‚</p>
<p>Second approach based on Poynting theorem (always valid, even for homogeneous layers with non-diagonal anisotropy):</p>
<p>åŸºäº Poynting å®šç†çš„ç¬¬äºŒç§æ–¹æ³•(æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œå³ä½¿å¯¹äºéå¯¹è§’å„å‘å¼‚æ€§çš„å‡åŒ€å±‚) :</p>
<p>An alternative approach to compute the losses in the layers consists in calculating the difference in the flux of the incoming and outgoing Poynting vectors. This approach is faster, but in some cases, the computation of the integral can be more accurate. In homogeneous layers with non-diagonal anisotropy, only this approach is possible.</p>
<p>å¦ä¸€ç§è®¡ç®—å„å±‚æŸè€—çš„æ–¹æ³•æ˜¯è®¡ç®—è¾“å…¥å’Œè¾“å‡º Poynting å‘é‡çš„é€šé‡å·®ã€‚è¿™ç§æ–¹æ³•æ›´å¿«ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç§¯åˆ†çš„è®¡ç®—å¯ä»¥æ›´ç²¾ç¡®ã€‚åœ¨éå¯¹è§’å„å‘å¼‚æ€§çš„å‡åŒ€å±‚ä¸­ï¼Œåªæœ‰è¿™ç§æ–¹æ³•æ˜¯å¯è¡Œçš„ã€‚</p>
<p>To specify which approach used per layer, we define a vector parm.res3.pertes_poynting &#x3D; [0,0,0,1,0]; % for instance for a 5-layer grating with â€œ0â€, the integral approach is used (default option) and with â€œ1â€, the Poynting approach is used. The length of parm.res3.pertes_poynting is equal to the number of layers. We may set parm.res3.pertes_poynting &#x3D; 0 or 1; the scalar is then repeated for all layers.</p>
<p>ä¸ºäº†æŒ‡å®šæ¯å±‚ä½¿ç”¨çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‘é‡ parm.res3.pertes _ Poynting &#x3D; [0,0,0,1,0] ; ä¾‹å¦‚ï¼Œå¯¹äº5å±‚å…‰æ …ï¼Œä½¿ç”¨â€œ0â€ï¼Œä½¿ç”¨ç§¯åˆ†æ–¹æ³•(é»˜è®¤é€‰é¡¹) ï¼Œå¯¹äºâ€œ1â€ï¼Œä½¿ç”¨ Poynting æ–¹æ³•ã€‚Parm.res3.pertes _ poynting çš„é•¿åº¦ç­‰äºå±‚æ•°ã€‚æˆ‘ä»¬å¯ä»¥è®¾ç½® parm.res3.pertes _ poynting &#x3D; 0æˆ–1; ç„¶åå¯¹æ‰€æœ‰å±‚é‡å¤æ ‡é‡ã€‚</p>
<p>We may then compute the flux of the Poynting vector in the layer-boundary planes [e, Z, index, wZ,loss_per_layer,loss_of_Z,loss_of_Z_X,X,wX,Flux_Poynting] &#x3D; res3(x,aa,Profile,einc,parm);</p>
<p>ç„¶åæˆ‘ä»¬å¯ä»¥è®¡ç®— Poynting å‘é‡åœ¨å±‚è¾¹ç•Œé¢[ eï¼Œzï¼Œindexï¼Œwzï¼Œloss _ per _ layerï¼Œloss _ zï¼Œloss _ of _ zxï¼Œxï¼Œwxï¼Œflux _ Poynting ] &#x3D; res3(xï¼Œaaï¼ŒProfileï¼Œeincï¼Œparm)ä¸­çš„é€šé‡;</p>
<p><strong>Flux_Poynting</strong> is a vector. <strong>Flux_Poynting(1)</strong> corresponds to the upper interface of the top layer. The flux is computed for a normal vector equal to the ğ³Ì‚vector. If <strong>Flux_Poynting(p)</strong> &gt; 0, the energy flows toward the top and if it is negative, the energy flows toward the bottom.</p>
<p><strong>Flux _ poynting æ˜¯ä¸€ä¸ªçŸ¢é‡ã€‚Flux _ poynting (1)å¯¹åº”äºé¡¶å±‚çš„ä¸Šå±‚ç•Œé¢ã€‚é€šé‡æ˜¯é’ˆå¯¹ä¸€ä¸ªç­‰äº something çŸ¢é‡çš„æ³•å‘é‡è®¡ç®—çš„ã€‚å¦‚æœ Flux _ poynting (p) &gt; 0ï¼Œèƒ½é‡æµå‘é¡¶éƒ¨ï¼Œå¦‚æœå®ƒæ˜¯è´Ÿçš„ï¼Œèƒ½é‡æµå‘åº•éƒ¨ã€‚</strong></p>
<p>For an illumination from the top and a lossy substrate, the substrate absorption is **-**<strong>Flux_Poynting (end)&#x2F;(0.5*period)</strong>. For an illumination from the bottom and a lossy superstrate, the superstrate absorption is <strong>Flux_Poynting (1)&#x2F;(0.5*period)</strong>.</p>
<p>å¯¹äºæ¥è‡ªé¡¶éƒ¨å’Œæœ‰è€—åŸºæ¿çš„ç…§æ˜ï¼ŒåŸºæ¿çš„å¸æ”¶æ˜¯ Flux _ poynting (end)&#x2F;(0.5 * period)ã€‚å¯¹äºæ¥è‡ªåº•éƒ¨å’Œæœ‰è€—ä¸Šå±‚çš„ç…§æ˜ï¼Œä¸Šå±‚å¸æ”¶æ˜¯ Flux _ poynting (1)&#x2F;(0.5 * period)ã€‚</p>
<p><code>Note on the computation accuracy of the integral approach</code> å…³äºç§¯åˆ†æ³•è®¡ç®—ç²¾åº¦çš„æ³¨æ„äº‹é¡¹</p>
<p>To compute integrals like the loss or the electromagnetic energy, RETICOLO uses a Gauss-Legendre integration method. This method, which is very powerful for â€˜regularâ€™ functions, becomes inaccurate for discontinuous functions. Thus, the integration domain should be divided into subdomains where the electric field <strong>E</strong> is continuous. For the integration in <strong>X</strong>, this difficult task is performed by the program, so that the user should only define the limits of integration: the input â€œ<strong>x</strong>â€ argument is now a vector of length 2, which represent the limits of the x interval (to compute the loss over the entire period, we may take <strong>x</strong>(2)&#x3D;<strong>x</strong>(1)+<strong>period</strong>. The integration domain is then divided into subintervals where the permittivity is continuous, each subinterval having a length less than l&#x2F;(2p). For every subinterval, a Gauss-Legendre integration method of degree 10 is used. This default value can be changed by setting <strong>parm.res3.gauss_x</strong>&#x3D;. The actual points of computation of the field are returned in the output argument</p>
<p>ä¸ºäº†è®¡ç®—åƒæŸè€—æˆ–ç”µç£èƒ½è¿™æ ·çš„ç§¯åˆ†ï¼ŒRETICOLO ä½¿ç”¨äº† Gauss-Legendre ç§¯åˆ†æ³•ã€‚è¿™ç§æ–¹æ³•å¯¹äºâ€œæ­£åˆ™â€å‡½æ•°éå¸¸æœ‰æ•ˆï¼Œä½†æ˜¯å¯¹äºä¸è¿ç»­çš„å‡½æ•°å°±ä¸å‡†ç¡®äº†ã€‚å› æ­¤ï¼Œç§¯åˆ†åŸŸåº”è¯¥è¢«åˆ’åˆ†ä¸ºç”µåœº e æ˜¯è¿ç»­çš„å­åŸŸã€‚å¯¹äº x ä¸­çš„ç§¯åˆ†ï¼Œè¿™ä¸ªå›°éš¾çš„ä»»åŠ¡æ˜¯ç”±ç¨‹åºæ‰§è¡Œçš„ï¼Œå› æ­¤ç”¨æˆ·åªéœ€è¦å®šä¹‰ç§¯åˆ†çš„æé™: è¾“å…¥â€œ xâ€å‚æ•°ç°åœ¨æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º2çš„å‘é‡ï¼Œå®ƒè¡¨ç¤º x åŒºé—´çš„æé™(ä¸ºäº†è®¡ç®—æ•´ä¸ªå‘¨æœŸçš„æŸå¤±ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨ x (2) &#x3D; x (1) + å‘¨æœŸ)ã€‚ç„¶åå°†ç§¯åˆ†åŸŸåˆ’åˆ†ä¸ºä»‹ç”µå¸¸æ•°è¿ç»­çš„å­åŒºé—´ï¼Œæ¯ä¸ªå­åŒºé—´çš„é•¿åº¦å°äº&#x2F;(2)ã€‚å¯¹äºæ¯ä¸ªå­åŒºé—´ï¼Œä½¿ç”¨10åº¦çš„ Gauss-Legendre ç§¯åˆ†æ–¹æ³•ã€‚è¿™ä¸ªé»˜è®¤å€¼å¯ä»¥é€šè¿‡è®¾ç½® parm.res3.gauss _ x &#x3D; æ¥æ”¹å˜ã€‚å­—æ®µçš„å®é™…è®¡ç®—ç‚¹åœ¨è¾“å‡ºå‚æ•°ä¸­è¿”å›X.</p>
<p>For the z integration, the discontinuity points are more easily determined by the variable â€˜Profileâ€™. The user</p>
<p>may choose the number of subintervals and the degree in every layer using the parameter parm.res3.npts, which is now an array with two lines (in subsection 8.1 this variable is a line vector): the first line defines the degree and the second line the numbers of subintervals of every layer. For example: parm.res3.npts &#x3D; [ [10,0,12] ; [3,1,5] ]; means that 3 subintervals with 10-degree points are used in the first layer, 1 subintervals with 0 point in the second layer, 5 subintervals with 12degree points in the third layer.</p>
<p>å¯¹äºzç§¯åˆ†ï¼Œä¸è¿ç»­ç‚¹å¯ä»¥æ›´è½»æ¾åœ°é€šè¿‡å˜é‡â€œProfileâ€ç¡®å®šã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨å‚æ•°parm.res3.nptsé€‰æ‹©æ¯ä¸ªå±‚ä¸­çš„å­åŒºé—´æ•°å’Œåº¦æ•°ï¼Œè¯¥å‚æ•°ç°åœ¨æ˜¯ä¸€ä¸ªå¸¦æœ‰ä¸¤è¡Œçš„æ•°ç»„ï¼ˆåœ¨ç¬¬8.1å°èŠ‚ä¸­ï¼Œæ­¤å˜é‡æ˜¯çº¿å‘é‡ï¼‰ï¼šç¬¬ä¸€è¡Œå®šä¹‰åº¦æ•°ï¼Œç¬¬äºŒè¡Œå®šä¹‰æ¯ä¸ªå±‚çš„å­åŒºé—´æ•°ã€‚ä¾‹å¦‚ï¼šparm.res3.npts &#x3D;[ [10,0,12];[3,1,5]]; è¡¨ç¤ºåœ¨ç¬¬ä¸€å±‚ä¸­ä½¿ç”¨3ä¸ªå­åŒºé—´å’Œ10åº¦ç‚¹ï¼Œç¬¬äºŒå±‚ä¸­ä½¿ç”¨1ä¸ªå­åŒºé—´å’Œ0ç‚¹ï¼Œç¬¬ä¸‰å±‚ä¸­ä½¿ç”¨5ä¸ªå­åŒºé—´å’Œ12åº¦ç‚¹ã€‚</p>
<p>The actual z-points of computation of the field are returned in the output variable <strong>Z</strong>, and the vector <strong>wZ</strong> represents the weights and we have sum(<strong>loss_of_Z</strong>.*<strong>wZ</strong>)&#x3D;sum(<strong>loss_per_layer</strong>). Although the maximum degree that can be handled by reticolo is 1000, it is recommended to limit the degree values to modest numbers (10-30 maximum) and to increase the number of subintervals (the larger the degree, the denser the sampling points in the vicinity of the subinterval boundaries).</p>
<p>å­—æ®µè®¡ç®—çš„å®é™… z ç‚¹åœ¨è¾“å‡ºå˜é‡ z ä¸­è¿”å›ï¼Œå‘é‡ wZ è¡¨ç¤ºæƒé‡ï¼Œæˆ‘ä»¬æœ‰ _ z çš„æ€»å’Œ(æŸå¤± _)ã€‚wZ) &#x3D; æ€»å’Œ(æ¯å±‚æŸå¤±)ã€‚å°½ç®¡ reticolo å¯ä»¥å¤„ç†çš„æœ€å¤§ç¨‹åº¦æ˜¯1000ï¼Œä½†å»ºè®®å°†ç¨‹åº¦å€¼é™åˆ¶ä¸ºé€‚åº¦æ•°(æœ€å¤§10-30) ï¼Œå¹¶å¢åŠ å­åŒºé—´çš„æ•°ç›®(ç¨‹åº¦è¶Šå¤§ï¼Œå­åŒºé—´è¾¹ç•Œé™„è¿‘çš„é‡‡æ ·ç‚¹è¶Šå¯†é›†)ã€‚</p>
<p>Note that if <strong>einc</strong>&#x3D; <strong>result. inc_top PlaneWave_E(2)</strong>, in TE ploarization, or <strong>einc</strong>&#x3D; <strong>result. inc_top PlaneWave_H(2)</strong>, in TE ploarization <strong>,</strong> the energie conservation test for an incident plane wave from the top is sum(result. inc_top_reflected.efficiency)+ sum(result. inc_top_transmitted.efficiency)+ sum(loss_per_layer) &#x2F; (.5*period) &#x3D; 1.</p>
<p>æ³¨æ„ï¼Œå¦‚æœ einc &#x3D; resultã€‚Inc _ top PlaneWave _ e (2) ï¼ŒTE æåŒ–ï¼Œæˆ– einc &#x3D; resultã€‚åœ¨ TE æåŒ–æ¡ä»¶ä¸‹ï¼Œä»é¡¶éƒ¨å…¥å°„çš„å¹³é¢æ³¢çš„èƒ½é‡å®ˆæ’å®éªŒæ˜¯æ±‚å’Œ(ç»“æœ)ã€‚åå°„ã€‚æ•ˆç‡) + æ€»å’Œ(ç»“æœ)ã€‚ä¼ è¾“ã€‚æ•ˆç‡) + æ€»å’Œ(æ¯å±‚æŸå¤±)&#x2F;(. 5å‘¨æœŸ) &#x3D; 1ã€‚</p>
<p>Usually, this equality is achieved with an absolute error of &lt;10-5.</p>
<p>é€šå¸¸ï¼Œè¿™ç§ç­‰å¼æ˜¯åœ¨ç»å¯¹è¯¯å·® &lt; 105æ—¶å®ç°çš„ã€‚</p>
<p><code> For specialists: å¯¹äºä¸“å®¶</code>:</p>
<ol>
<li>-loss_of_Z_X &#x3D;pi&#x2F; wavelength<em>imag(index.^2).</em> abs(e(:,:,1)).^2; in TE polarization</li>
<li>-loss_of_Z_X &#x3D;pi&#x2F; wavelength*imag(index.^2).*sum(abs(e(:,:,2:3)).^2,3); in TM polarization</li>
<li>-loss_of_Z &#x3D;(loss_of_Z_X*wX(:)).â€™;</li>
<li>-by setting index(index ~&#x3D; index_chosen)&#x3D;0 in the previous formulas, one may calculate the absorption loss in the medium of refractive index index_chosen.</li>
</ol>
<p>é€šè¿‡åœ¨å…ˆå‰çš„å…¬å¼ä¸­è®¾ç½®indexï¼ˆindexã€œ&#x3D;index_chosenï¼‰&#x3D; 0ï¼Œå¯ä»¥è®¡ç®—æŠ˜å°„ç‡ä¸ºindex_chosençš„ä»‹è´¨ä¸­çš„å¸æ”¶æŸè€—ã€‚</p>
<h2 id="Bloch-mode-effective-indices"><a href="#Bloch-mode-effective-indices" class="headerlink" title="Bloch-mode effective indices"></a>Bloch-mode effective indices</h2><p><code>Blochæ¨¡å¼æœ‰æ•ˆæŒ‡æ•°</code></p>
<p>RETICOLO gives access to another output: the Bloch mode associated to all textures. The Bloch mode k of the</p>
<p>texture l can be written</p>
<p>RETICOLOæä¾›äº†å¦ä¸€ç§è¾“å‡ºï¼šä¸æ‰€æœ‰çº¹ç†ç›¸å…³è”çš„å¸ƒæ´›èµ«æ¨¡ã€‚çº¹ç†lçš„å¸ƒæ´›èµ«æ¨¡kå¯ä»¥å†™æˆï¼š</p>
<p>$\left|\Phi_k{}^l\right\rangle&#x3D;\sum_m a_m^{k,l}exp\left[i(k_x^{inc}+mK_x)x\right]exp\left(i\frac{2\pi}{\lambda}n_{eff}^{k,l}z\right)$,</p>
<p>where $n_{\textit{eff}}^{k,l}$ is the effective index of the Bloch mode <em>k</em> of the texture <em>l</em>.</p>
<p>å…¶ä¸­ï¼Œ$n_{\textit{eff}}^{k,l}$æ˜¯çº¹ç†lçš„å¸ƒæ´›èµ«æ¨¡kçš„æœ‰æ•ˆæŒ‡æ•°ã€‚</p>
<p><code>Instruction:</code>è¯´æ˜:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aa, n_eff] = res1(wavelength,period,textures,nn,kparallel, parm);</span><br></pre></td></tr></table></figure>

<p>Note that the â€œn_effâ€ variable is a Matlab cell array: â€œn_eff{ii}â€ is a column vector containing all the Bloch-mode effective indices associated to the texture â€œtextures{ii}â€. The element number 5 of this vector, for example, is called by the instruction â€œn_eff{ii}(5);â€. An attenuated Bloch-mode has a complex effective index.</p>
<p>è¯·æ³¨æ„ï¼Œâ€œn_effâ€å˜é‡æ˜¯Matlabå•å…ƒæ•°ç»„ï¼šâ€œn_eff {ii}â€æ˜¯åŒ…å«æ‰€æœ‰ä¸çº¹ç†â€œtextures {ii}â€ç›¸å…³è”çš„å¸ƒæ´›èµ«æ¨¡æœ‰æ•ˆæŒ‡æ•°çš„åˆ—å‘é‡ã€‚ä¾‹å¦‚ï¼Œæ­¤å‘é‡çš„ç¬¬5ä¸ªå…ƒç´ ç”±æŒ‡ä»¤â€œn_eff {ii}ï¼ˆ5ï¼‰;â€è°ƒç”¨ã€‚è¡°å‡çš„å¸ƒæ´›èµ«æ¨¡å…·æœ‰å¤æœ‰æ•ˆæŒ‡æ•°ã€‚</p>
<p><code>Bloch mode profile visualization</code> Bloch æ¨¡å¼å‰–é¢å¯è§†åŒ–:</p>
<p>To plot the profile of Bloch mode Num_mode of the texture Num_texture:</p>
<p>è¦ç»˜åˆ¶çº¹ç†Num_textureçš„Blochæ¨¡Num_modeçš„è½®å»“ï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1(aa, neff, Num_texture, Num_mode);</span><br></pre></td></tr></table></figure>

<p>To obtain the profile datas in the format given by res3:</p>
<p>è¦ä»¥res3ç»™å‡ºçš„æ ¼å¼è·å–è½®å»“æ•°æ®ï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[e,o,x] = res1(aa, neff, Num_texture, Num_mode); <span class="comment">% by default, |x| &lt; period/2</span></span><br><span class="line">[e,o] = res1(aa, neff, Num_texture, Num_mode, x); <span class="comment">% by specifying the x vector, x=linspace(0, 3*period(1),100)</span></span><br><span class="line"><span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure>

<h2 id="10-Annex-é™„ä»¶"><a href="#10-Annex-é™„ä»¶" class="headerlink" title="10 Annex é™„ä»¶"></a>10 Annex é™„ä»¶</h2><h3 id="10-1-Checking-that-the-textures-are-correctly-set-up"><a href="#10-1-Checking-that-the-textures-are-correctly-set-up" class="headerlink" title="10.1 Checking that the textures are correctly set up"></a>10.1 Checking that the textures are correctly set up</h3><p>æ£€æŸ¥çº¹ç†è®¾ç½®æ˜¯å¦æ­£ç¡®</p>
<p>Setting â€œ<strong>parm.res1.trace &#x3D; 1</strong>;â€ generates a Matlab figure which represents the refractive-index distribution of all the textures.</p>
<p>è®¾ç½®â€œ parm.res1.trace &#x3D; 1;â€ç”Ÿæˆä¸€ä¸ªä»£è¡¨æ‰€æœ‰çº¹ç†æŠ˜å°„ç‡åˆ†å¸ƒçš„ Matlab å›¾å½¢ã€‚</p>
<h3 id="10-2-The-â€œretioâ€-â€œreteffaceâ€-instructions"><a href="#10-2-The-â€œretioâ€-â€œreteffaceâ€-instructions" class="headerlink" title="10.2 The â€œretioâ€ &amp; â€œreteffaceâ€ instructions"></a>10.2 The â€œretioâ€ &amp; â€œreteffaceâ€ instructions</h3><p>RETICOLO automatically creates temporary files in order to save memory. These temporary files are of the form â€œabcd0.matâ€, â€œabcd1.matâ€ â€¦ with abcd are randomly chosen) .They are created in the current directory. In general RETICOLO automatically erases these files when they are no longer needed, but it is recommended to finish all programs by the instruction â€œretio;â€, which erases all temporary files. Also, if a program anormally stopsone may execute the instruction â€œretioâ€ before restarting the program.</p>
<p>RETICOLOä¼šè‡ªåŠ¨åˆ›å»ºä¸´æ—¶æ–‡ä»¶ä»¥èŠ‚çœå†…å­˜ã€‚è¿™äº›ä¸´æ—¶æ–‡ä»¶çš„æ ¼å¼ä¸ºâ€œabcd0.matâ€ï¼Œâ€œabcd1.matâ€â€¦â€¦å…¶ä¸­abcdæ˜¯éšæœºé€‰æ‹©çš„ï¼‰ã€‚å®ƒä»¬åœ¨å½“å‰ç›®å½•ä¸­åˆ›å»ºã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒRETICOLOåœ¨ä¸å†éœ€è¦è¿™äº›æ–‡ä»¶æ—¶ä¼šè‡ªåŠ¨åˆ é™¤å®ƒä»¬ï¼Œä½†å»ºè®®é€šè¿‡æŒ‡ä»¤â€œretio;â€ç»“æŸæ‰€æœ‰ç¨‹åºï¼Œè¯¥æŒ‡ä»¤å°†åˆ é™¤æ‰€æœ‰ä¸´æ—¶æ–‡ä»¶ã€‚æ­¤å¤–ï¼Œå¦‚æœç¨‹åºå¼‚å¸¸åœæ­¢ï¼Œå¯ä»¥åœ¨é‡æ–°å¯åŠ¨ç¨‹åºä¹‹å‰æ‰§è¡ŒæŒ‡ä»¤â€œretioâ€ã€‚</p>
<p>The â€œreteffaceâ€ instruction allows to know all the â€œabcd0.matâ€ files and to erase them if wanted.</p>
<p>â€œ retefaceâ€æŒ‡ä»¤å…è®¸çŸ¥é“æ‰€æœ‰â€œ abcd0.matâ€æ–‡ä»¶ï¼Œå¹¶åœ¨éœ€è¦æ—¶åˆ é™¤å®ƒä»¬ã€‚</p>
<p>If we are not limited by memory (this is often the case with modern computers), we can prevent the writing of intermediate files on the hard disk by the setting</p>
<p>å¦‚æœæˆ‘ä»¬ä¸å—å†…å­˜çš„é™åˆ¶(ç°ä»£è®¡ç®—æœºé€šå¸¸å°±æ˜¯è¿™ç§æƒ…å†µ) ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®æ¥é˜²æ­¢åœ¨ç¡¬ç›˜ä¸Šå†™å…¥ä¸­é—´æ–‡ä»¶</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parm.not_io = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>before the call to res1. Then it is no longer necessary to use the retio instruction at the end of the programs to erase the files.</p>
<p>åœ¨è°ƒç”¨ res1ä¹‹å‰ã€‚ç„¶åå°±ä¸å†éœ€è¦åœ¨ç¨‹åºç»“æŸæ—¶ä½¿ç”¨ retio æŒ‡ä»¤æ¥åˆ é™¤æ–‡ä»¶äº†ã€‚</p>
<p><code>Important</code>: to use parfor loops, it is imperative to take the option parm.not_io &#x3D; 1.</p>
<p>é‡è¦æç¤º: è¦ä½¿ç”¨ parfor å¾ªç¯ï¼Œå¿…é¡»ä½¿ç”¨é€‰é¡¹ parm.not _ io &#x3D; 1ã€‚</p>
<h3 id="10-3-How-to-save-and-to-reload-the-â€œaaâ€-variable"><a href="#10-3-How-to-save-and-to-reload-the-â€œaaâ€-variable" class="headerlink" title="10.3.   How to save and to reload the â€œaaâ€ variable"></a><strong>10.3.</strong>   How to save and to reload the â€œaaâ€ variable</h3><p>å¦‚ä½•ä¿å­˜å’Œé‡æ–°åŠ è½½â€œ aaâ€å˜é‡</p>
<p>To save the â€œ<strong>aa</strong>â€ variable in a â€œ.matâ€ file, the user has to define a new parameter containing the name of the file he or she wants to create : â€œ<strong>parm.res1.fperm &#x3D; â€˜file_nameâ€™</strong>;â€. field_name is a char string with at least one letter. The program will automatically save â€œ<strong>aa</strong>â€ in the file â€œ<strong>file_name.mat</strong>â€. In a new utilisation it is sufficient to write aa&#x3D;<strong>&#x3D; â€˜file_nameâ€™</strong>;.</p>
<p>å°†â€œ aaâ€å˜é‡ä¿å­˜åˆ°â€œã€‚åœ¨ matâ€æ–‡ä»¶ä¸­ï¼Œç”¨æˆ·å¿…é¡»å®šä¹‰ä¸€ä¸ªæ–°å‚æ•°ï¼Œå…¶ä¸­åŒ…å«ä»–æˆ–å¥¹æƒ³è¦åˆ›å»ºçš„æ–‡ä»¶çš„åç§°: â€œ parm.res1.fperm &#x3D; â€˜ file _ nameâ€™;â€ã€‚Field _ name æ˜¯ä¸€ä¸ªè‡³å°‘æœ‰ä¸€ä¸ªå­—æ¯çš„å­—ç¬¦ä¸²ã€‚ç¨‹åºä¼šè‡ªåŠ¨å°†â€œ aaâ€ä¿å­˜åˆ°æ–‡ä»¶â€œ file _ nameâ€ä¸­ã€‚é©¬ç‰¹ã€‚åœ¨ä¸€ä¸ªæ–°çš„åº”ç”¨ç¨‹åºä¸­ï¼Œå†™ aa &#x3D; &#x3D; â€˜ file _ nameâ€™å°±è¶³å¤Ÿäº†;ã€‚</p>
<p>Example of a program which calculates and saves the â€œaaâ€ variable [â€¦] % Definition of the input parameters, see Section 3 <strong>parm.res1.fperm &#x3D; â€˜totoâ€™</strong>;</p>
<p>è®¡ç®—å¹¶ä¿å­˜è¾“å…¥å‚æ•°çš„â€œ aaâ€å˜é‡[ â€¦ ]% å®šä¹‰çš„ç¨‹åºç¤ºä¾‹ï¼Œå‚è§ç¬¬3èŠ‚ parm.res1.fperm &#x3D; â€˜ totoâ€™;</p>
<p>[â€¦] % Definition of the textures, see Section 4.1</p>
<p>[ â€¦ ]% çº¹ç†çš„å®šä¹‰ï¼Œå‚è§ç¬¬4.1èŠ‚</p>
<p><strong>aa &#x3D; res1(wavelength,period,textures,nn,k_parallel,parm)</strong>;</p>
<p><strong>Aa &#x3D; res1(æ³¢é•¿ï¼Œå‘¨æœŸï¼Œçº¹ç†ï¼Œnnï¼Œk å¹³è¡Œï¼Œparm) ;</strong></p>
<p>Example of a program which uses the â€œaaâ€ variable and then calculates the diffracted waves [â€¦]  % Definition of the profile, see Section 4.2. Note that the textures used to define the profile argument have to correspond to the textures defined in the program which has previously calculated the â€œaaâ€ variable. aa&#x3D;â€™totoâ€™;</p>
<p>ç¨‹åºä½¿ç”¨â€œ aaâ€å˜é‡ï¼Œç„¶åè®¡ç®—è¡å°„æ³¢[ â€¦ ]% è½®å»“çš„å®šä¹‰ï¼Œå‚è§ç¬¬4.2èŠ‚ã€‚æ³¨æ„ï¼Œç”¨äºå®šä¹‰é…ç½®æ–‡ä»¶å‚æ•°çš„çº¹ç†å¿…é¡»ä¸ä¹‹å‰è®¡ç®—â€œ aaâ€å˜é‡çš„ç¨‹åºä¸­å®šä¹‰çš„çº¹ç†ç›¸å¯¹åº”ã€‚Aa &#x3D;â€™totoâ€™;</p>
<h3 id="10-4-Asymmetry-of-the-Fourier-harmonics-retained-in-the-computation"><a href="#10-4-Asymmetry-of-the-Fourier-harmonics-retained-in-the-computation" class="headerlink" title="10.4.   Asymmetry of the Fourier harmonics retained in the computation"></a><strong>10.4.</strong>   Asymmetry of the Fourier harmonics retained in the computation</h3><p> nn &#x3D; [-15;20]; % this defines the set of non-symmetric Fourier harmonics retained for the computation. In this</p>
<p>case, the Fourier harmonics from â€“15 to +20 are retained.</p>
<p>The instructions â€œnn &#x3D; 10;â€ and â€œnn &#x3D; [-10;10];â€ are equivalent.</p>
<p>Take care that the use of symmetry imposes symmetric Fourier harmonics if not the computation will be done</p>
<p>without any symmetry consideration.</p>
<p>nn &#x3D; [-15; 20];% è¿™å®šä¹‰äº†è®¡ç®—ä¸­ä¿ç•™çš„éå¯¹ç§°å‚…é‡Œå¶è°æ³¢é›†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¿ç•™ä»-15åˆ°+20çš„å‚…é‡Œå¶è°æ³¢ã€‚ â€œnn &#x3D; 10;â€å’Œâ€œnn &#x3D; [-10; 10];â€æŒ‡ä»¤æ˜¯ç­‰ä»·çš„ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœä¸ä½¿ç”¨å¯¹ç§°æ€§ï¼Œåˆ™ä½¿ç”¨å¯¹ç§°å‚…é‡Œå¶è°æ³¢è¿›è¡Œè®¡ç®—ï¼Œå¦åˆ™å°†å®Œå…¨æ²¡æœ‰è€ƒè™‘å¯¹ç§°æ€§ã€‚</p>
<h2 id="11-Summary"><a href="#11-Summary" class="headerlink" title="11  Summary"></a>11  Summary</h2><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403230539759.png" srcset="/img/loading.gif" lazyload alt="image-20230403230539759" style="zoom:50%;" />

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parm = res0( <span class="number">1</span>) <span class="keyword">for</span> TE polarisation;</span><br><span class="line">parm = res0(<span class="number">-1</span>) <span class="keyword">for</span> TM polarisation;</span><br><span class="line">aa = res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">result = res2(aa,Profile);</span><br><span class="line">J = result.Jones.inc_top_transmitted &#123;m&#125;</span><br><span class="line">[e,z,o] = res3(x,aa,Profile, inc,parm);</span><br></pre></td></tr></table></figure>

<h2 id="12-Examples-ä¾‹å­"><a href="#12-Examples-ä¾‹å­" class="headerlink" title="12 Examples  ä¾‹å­"></a>12 Examples  ä¾‹å­</h2><p> The following example can be copied and executed in Matlab ï¼š</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% EXAMPLE 1D (TE or TM) %</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">wavelength=<span class="number">8</span>;</span><br><span class="line">period=<span class="number">10</span>;<span class="comment">% same unit as wavelength</span></span><br><span class="line">n_incident_medium=<span class="number">1</span>;<span class="comment">% refractive index of the top layer</span></span><br><span class="line">n_transmitted_medium=<span class="number">1.5</span>;<span class="comment">% refractive index of the bottom layer</span></span><br><span class="line">angle_theta0=<span class="number">-10</span>;k_parallel=n_incident_medium*<span class="built_in">sin</span>(angle_theta0*<span class="built_in">pi</span>/<span class="number">180</span>);</span><br><span class="line">parm=res0(<span class="number">1</span>);<span class="comment">% TE polarization. For TM : parm=res0(-1)</span></span><br><span class="line">parm.res1.champ=<span class="number">1</span>;<span class="comment">% the electromagnetic field is calculated accurately</span></span><br><span class="line">nn=<span class="number">40</span>;<span class="comment">% Fourier harmonics run from [-40,40]</span></span><br><span class="line"><span class="comment">% textures for all layers including the top and bottom layers</span></span><br><span class="line">texture=cell(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">textures&#123;<span class="number">1</span>&#125;= n_incident_medium; <span class="comment">% uniform texture</span></span><br><span class="line">textures&#123;<span class="number">2</span>&#125;= n_transmitted_medium; <span class="comment">% uniform texture</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;=&#123;[<span class="number">-2.5</span>,<span class="number">2.5</span>],[n_incident_medium,n_transmitted_medium] &#125;;</span><br><span class="line"></span><br><span class="line">aa=res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">Profile=&#123;[<span class="number">4.1</span>,<span class="number">5.2</span>,<span class="number">4.1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]&#125;;</span><br><span class="line">one_D_TE=res2(aa,Profile)</span><br><span class="line">eff=one_D_TE.inc_top_reflected.efficiency&#123;<span class="number">-1</span>&#125;</span><br><span class="line">J=one_D_TE.Jones.inc_top_reflected&#123;<span class="number">-1</span>&#125;;<span class="comment">% Jonesâ€™coefficients</span></span><br><span class="line"><span class="built_in">abs</span>(J)^<span class="number">2</span> <span class="comment">% first order efficiency for an illumination from the top layer</span></span><br><span class="line"><span class="comment">% field calculation</span></span><br><span class="line">x=<span class="built_in">linspace</span>(-period/<span class="number">2</span>,period/<span class="number">2</span>,<span class="number">51</span>);<span class="comment">% x coordinates(z-coordinates are determined by</span></span><br><span class="line">res3.m)</span><br><span class="line">einc=<span class="number">1</span>;</span><br><span class="line">parm.res3.trace=<span class="number">1</span>; <span class="comment">% plotting automatically</span></span><br><span class="line">parm.res3.npts=[<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>];</span><br><span class="line">[e,z,index]=res3(x,aa,Profile,einc,parm);</span><br><span class="line"><span class="built_in">figure</span>;pcolor(x,z,<span class="built_in">real</span>(<span class="built_in">squeeze</span>(e(:,:,<span class="number">1</span>)))); <span class="comment">% user plotting</span></span><br><span class="line">shading flat;xlabel(<span class="string">&#x27;x&#x27;</span>);ylabel(<span class="string">&#x27;y&#x27;</span>);axis equal;title(<span class="string">&#x27;Real(Ey)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loss calculation</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;=&#123;[<span class="number">-2.5</span>,<span class="number">2.5</span>],[n_incident_medium,<span class="number">.1</span>+<span class="number">5</span><span class="built_in">i</span>] &#125;;</span><br><span class="line">aa_loss=res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">one_D_loss=res2(aa_loss,Profile)</span><br><span class="line">parm.res3.npts=[[<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>];[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>]];</span><br><span class="line">einc=one_D_loss.inc_top.PlaneWave_E(<span class="number">2</span>);</span><br><span class="line">[e,z,index,wZ,loss_per_layer,loss_of_Z,loss_of_Z_X,X,wX]=res3([-</span><br><span class="line">period/<span class="number">2</span>,period/<span class="number">2</span>],aa_loss,Profile,einc,parm);</span><br><span class="line">Energie_conservation=sum(one_D_loss.inc_top_reflected.efficiency)+sum(one_D_loss.in</span><br><span class="line">c_top_transmitted.efficiency)+sum(loss_per_layer)/(<span class="number">.5</span>* period)<span class="number">-1</span></span><br><span class="line">retio <span class="comment">% erase temporary files</span></span><br></pre></td></tr></table></figure>












<h1 id="for-the-analysis-of-the-diffraction-by-stacks-of-lamellar-1D-gratings-conical-diffraction"><a href="#for-the-analysis-of-the-diffraction-by-stacks-of-lamellar-1D-gratings-conical-diffraction" class="headerlink" title="for the analysis of the diffraction by stacks of lamellar 1D gratings (conical diffraction)"></a>for the analysis of the diffraction by stacks of lamellar 1D gratings (conical diffraction)</h1><p><code>ç”¨äºåˆ†æå±‚çŠ¶ä¸€ç»´å…‰æ …çš„è¡å°„(é”¥å½¢è¡å°„)</code></p>
<p>Reticolo code 1D-conical is a free software for analyzing 1D gratings in classical and conical mountings. It operates under Matlab. To install it, copy the companion folder â€œreticolo_allegeâ€ and add the folder in the Matlab path. The code may also be used to analyze thin-film stacks with homogeneous and anisotropic materials, see the end of Section 3.1.</p>
<p>Reticolo ä»£ç 1d-é”¥æ˜¯ä¸€ä¸ªå…è´¹çš„è½¯ä»¶ï¼Œç”¨äºåˆ†æä¸€ç»´å…‰æ …åœ¨ç»å…¸å’Œé”¥å½¢å®‰è£…ã€‚å®ƒåœ¨ Matlab ä¸‹è¿è¡Œã€‚è¦å®‰è£…å®ƒï¼Œå¤åˆ¶ä¼´éšæ–‡ä»¶å¤¹â€œ reticolo _ allegeâ€ï¼Œå¹¶å°†è¯¥æ–‡ä»¶å¤¹æ·»åŠ åˆ° Matlab è·¯å¾„ä¸­ã€‚è¯¥ä»£ç ä¹Ÿå¯ç”¨äºåˆ†æå‡è´¨å’Œå„å‘å¼‚æ€§ææ–™çš„è–„è†œå †æ ˆï¼Œå‚è§ç¬¬3.1èŠ‚çš„ç»“å°¾ã€‚</p>
<h2 id="Outline-å¤§çº²"><a href="#Outline-å¤§çº²" class="headerlink" title="Outline å¤§çº²"></a>Outline å¤§çº²</h2><h2 id="Generality-æ¦‚æ‹¬"><a href="#Generality-æ¦‚æ‹¬" class="headerlink" title="Generality æ¦‚æ‹¬"></a>Generality æ¦‚æ‹¬</h2><p>RETICOLO is a code written in the language MATLAB 9.0. It computes the diffraction efficiencies and the diffracted amplitudes of gratings composed of stacks of lamellar structures. It incorporates routines for the calculation and visualisation of the electromagnetic fields inside and outside the grating. With this version, 2D periodic (crossed) gratings cannot be analysed.</p>
<p>RETICOLO æ˜¯ç”¨ MATLAB 9.0è¯­è¨€ç¼–å†™çš„ä»£ç ã€‚å®ƒè®¡ç®—ç”±å±‚çŠ¶ç»“æ„å †å ç»„æˆçš„å…‰æ …çš„è¡å°„æ•ˆç‡å’Œè¡å°„æŒ¯å¹…ã€‚å®ƒåŒ…å«äº†ç”¨äºè®¡ç®—å’Œå¯è§†åŒ–å…‰æ …å†…å¤–ç”µç£åœºçš„ä¾‹ç¨‹ã€‚æœ‰äº†è¿™ä¸ªç‰ˆæœ¬ï¼ŒäºŒç»´å‘¨æœŸ(äº¤å‰)å…‰æ …ä¸èƒ½è¢«åˆ†æã€‚</p>
<p>As free alternative to MATLAB, RETICOLO can also be run in GNU Octave with minimal code changes. For further information, please contact <a href="mailto:&#x74;&#x69;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#x74;&#116;&#x65;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#x72;&#x40;&#112;&#114;&#x6f;&#x66;&#97;&#99;&#116;&#111;&#114;&#46;&#97;&#x74;">&#x74;&#x69;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#x74;&#116;&#x65;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#x72;&#x40;&#112;&#114;&#x6f;&#x66;&#97;&#99;&#116;&#111;&#114;&#46;&#97;&#x74;</a>.</p>
<p>ä½œä¸º MATLAB çš„å…è´¹æ›¿ä»£å“ï¼ŒRETICOLO ä¹Ÿå¯ä»¥åœ¨ GNU Octave ä¸­è¿è¡Œï¼Œä»£ç å˜åŒ–å¾ˆå°ã€‚æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è”ç³» <a href="mailto:&#116;&#105;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#116;&#x74;&#101;&#114;&#x61;&#109;&#x73;&#107;&#111;&#103;&#108;&#x65;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#99;&#x74;&#x6f;&#114;&#x2e;&#97;&#x74;">&#116;&#105;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#116;&#x74;&#101;&#114;&#x61;&#109;&#x73;&#107;&#111;&#103;&#108;&#x65;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#99;&#x74;&#x6f;&#114;&#x2e;&#97;&#x74;</a>ã€‚</p>
<p>In brief, RETICOLO implements a frequency-domain modal method (known as the Rigorous Coupled wave Analysis&#x2F;RCWA). To get an overview of the RCWA, the interested readers may refer to the following articles:</p>
<p>ç®€è€Œè¨€ä¹‹ï¼ŒRETICOLO å®ç°äº†ä¸€ç§é¢‘åŸŸæ¨¡æ€æ–¹æ³•(ç§°ä¸ºä¸¥æ ¼è€¦åˆæ³¢åˆ†æ&#x2F;RCWA)ã€‚ä¸ºäº†å¾—åˆ° RCWA çš„æ¦‚è¿°ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥å‚è€ƒä»¥ä¸‹æ–‡ç« :</p>
<p>1D-classical and conical diffraction</p>
<p>1d-ç»å…¸å’Œåœ†é”¥è¡å°„</p>
<p><strong>Scattering matrix approach:</strong> The code incorporates many refinements that we have not published and that we do not plan to publish. For instance, although it is generally admitted that the S-matrix is inconditionnally stable, it is not always the case. We have developed an in-house transfer matrix method which is more stable and accurate. The new transfer matrix approach is also more general and can handle perfect metals. The essence of the method has been rapidly published in â€œJ.-P. Hugonin, M. Besbes and P. Lalanne, Op. Lett. <strong>33</strong>, 1590 (2008)â€.</p>
<p><strong>æ•£å°„çŸ©é˜µæ–¹æ³•: è¯¥ä»£ç åŒ…å«äº†è®¸å¤šæˆ‘ä»¬æ²¡æœ‰å‘è¡¨è¿‡ä¹Ÿä¸æ‰“ç®—å‘è¡¨çš„æ”¹è¿›ã€‚ä¾‹å¦‚ï¼Œå°½ç®¡äººä»¬æ™®éæ‰¿è®¤ s çŸ©é˜µæ˜¯æ— æ¡ä»¶ç¨³å®šçš„ï¼Œä½†äº‹å®å¹¶éæ€»æ˜¯å¦‚æ­¤ã€‚æˆ‘ä»¬å¼€å‘äº†ä¸€ç§æ›´ç¨³å®šå’Œå‡†ç¡®çš„å†…éƒ¨è½¬ç§»çŸ©é˜µæ–¹æ³•ã€‚æ–°çš„è½¬ç§»çŸ©é˜µæ–¹æ³•ä¹Ÿæ›´åŠ é€šç”¨ï¼Œå¯ä»¥å¤„ç†å®Œç¾çš„é‡‘å±ã€‚è¿™ç§æ–¹æ³•çš„ç²¾é«“å·²ç»åœ¨ã€Šæ—¥æŠ¥ã€‹ä¸Šè¿…é€Ÿå‘è¡¨ã€‚ä½œè€…: Hugoninï¼Œm. Besbes and pã€‚è±ç‰¹ã€‚33,1590(2008)â€ã€‚</strong></p>
<p><strong>Field calculation:</strong> The calculation of the near-field electromagnetic fields everywhere in the grating is performed according to the method described in â€œP. Lalanne, M.P. Jurek, JMO <strong>45</strong>, 1357 (1998)â€ and to its generalization to crossed gratings (unpublished). Basically, no Gibbs phenomenon will be visible in the plots of the discontinuous electromagnetic quantities, but field singularities at corners will be correctly handled.</p>
<p><strong>åœºè®¡ç®—: æ ¹æ®â€œ P.Lalanneï¼Œm.p. Jurekï¼ŒJMO 45,1357(1998)â€ä¸­æè¿°çš„æ–¹æ³•åŠå…¶å¯¹äº¤å‰å…‰æ …çš„æ¨å¹¿(æœªå‘è¡¨) ï¼Œè®¡ç®—äº†å…‰æ …å†…å„å¤„çš„è¿‘åœºç”µç£åœºã€‚åŸºæœ¬ä¸Šï¼Œåœ¨ä¸è¿ç»­ç”µç£é‡çš„å›¾ä¸­ä¸ä¼šçœ‹åˆ°å‰å¸ƒæ–¯ç°è±¡ï¼Œä½†æ˜¯åœ¨è§’è½å¤„çš„åœºå¥‡å¼‚æ€§å°†è¢«æ­£ç¡®å¤„ç†ã€‚</strong></p>
<p><strong>Acknowledging the use of RETICOLO</strong>: In publications and reports, acknowledgments have to be provided by referencing to J.P. Hugonin and P. Lalanne, RETICOLO software for grating analysis, Institut dâ€™Optique, Orsay, France (2005), arXiv:2101:00901.</p>
<p><strong>æ‰¿è®¤ RETICOLO çš„ä½¿ç”¨: åœ¨å‡ºç‰ˆç‰©å’ŒæŠ¥å‘Šä¸­ï¼Œæ‰¿è®¤å¿…é¡»å‚è€ƒ j.p. Hugonin å’Œ p. Lalanneï¼ŒRETICOLO å…‰æ …åˆ†æè½¯ä»¶ï¼Œæ³•å›½ Orsay å…‰å­¦ç ”ç©¶æ‰€ï¼ŒarXiv: 2101:00901ã€‚</strong></p>
<p>In journal publications and in addition, one may fairly quote the following references:</p>
<p>åœ¨æœŸåˆŠå‡ºç‰ˆç‰©å’Œå¦å¤–ï¼Œäººä»¬å¯ä»¥å…¬æ­£åœ°å¼•ç”¨ä¸‹åˆ—å‚è€ƒæ–‡çŒ®:</p>
<p>-P. Lalanne and G.M. Morris, â€œHighly improved convergence of the coupled-wave method for TM polarizationâ€, J. Opt. Soc. Am. A <strong>13</strong>, 779-789 (1996).</p>
<p>æ‹‰å…°å†…å’Œè«é‡Œæ–¯ï¼Œâ€œ TM æåŒ–çš„è€¦åˆæ³¢æ–¹æ³•çš„é«˜åº¦æ”¹è¿›çš„æ”¶æ•›æ€§â€ï¼ŒJ.Optã€‚Soc.è¯‘æ³¨:ã€‚13,779-789(1996).</p>
<p>-P. Lalanne and M.P. Jurek, â€œComputation of the near-field pattern with the coupled-wave method for TM polarizationâ€, J. Mod. Opt.<strong>45</strong>, 1357-1374 (1998), if near-field electromagnetic-field distributions are shown.</p>
<p>- P.Lalanne å’Œ m.p. Jurekï¼Œâ€œç”¨ TM æåŒ–çš„è€¦åˆæ³¢æ–¹æ³•è®¡ç®—è¿‘åœºæ¨¡å¼â€ï¼ŒJ.Modã€‚å¦‚æœæ˜¾ç¤ºè¿‘åœºç”µç£åœºåˆ†å¸ƒï¼Œåˆ™ä¸º Opt. 45,1357-1374(1998)ã€‚</p>
<h2 id="The-diffraction-problem-considered"><a href="#The-diffraction-problem-considered" class="headerlink" title="The diffraction problem considered"></a>The diffraction problem considered</h2><p>è€ƒè™‘äº†è¡å°„é—®é¢˜</p>
<p>In general terms, the code solves the diffraction problem by a grating defined by a stack of layers which have all identical periods in the x- directions and are invariant in the y direction see the following figure. In the following, the (x,y) plane and the z-direction will be referred to as the transverse plane and the longitudinal direction, respectively. To define the grating structure, first we have to define a top and a bottom. This is rather arbitrary since the top or the bottom can be the substrate or the cover of a real structure. It is up to the user. Once the top</p>
<p>ä¸€èˆ¬æ¥è¯´ï¼Œè¯¥ä»£ç é€šè¿‡ä¸€ä¸ªå…‰æ …æ¥è§£å†³è¡å°„é—®é¢˜ï¼Œè¿™ä¸ªå…‰æ …ç”±ä¸€å †åœ¨ x æ–¹å‘ä¸Šå…·æœ‰ç›¸åŒå‘¨æœŸä¸”åœ¨ y æ–¹å‘ä¸Šä¸å˜çš„å±‚æ‰€å®šä¹‰ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚æ¥ä¸‹æ¥ï¼Œ(xï¼Œy)å¹³é¢å’Œ z æ–¹å‘åˆ†åˆ«ç§°ä¸ºæ¨ªå‘å¹³é¢å’Œçºµå‘å¹³é¢ã€‚ä¸ºäº†å®šä¹‰å…‰æ …ç»“æ„ï¼Œé¦–å…ˆæˆ‘ä»¬å¿…é¡»å®šä¹‰ä¸€ä¸ªé¡¶éƒ¨å’Œä¸€ä¸ªåº•éƒ¨ã€‚è¿™æ˜¯ç›¸å½“æ­¦æ–­çš„ï¼Œå› ä¸ºé¡¶éƒ¨æˆ–åº•éƒ¨å¯ä»¥æ˜¯ä¸€ä¸ªçœŸå®ç»“æ„çš„è¡¬åº•æˆ–è¦†ç›–ç‰©ã€‚è¿™å–å†³äºç”¨æˆ·ã€‚ä¸€æ—¦ç™»é¡¶</p>
<p> and the bottom of the grating have been defined, the user can choose to illuminate the structure from the top or from the bottom. The z-axis is oriented from bottom to top.</p>
<p>å…‰æ …çš„åº•éƒ¨å·²ç»ç¡®å®šï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©ä»é¡¶éƒ¨æˆ–ä»åº•éƒ¨ç…§æ˜ç»“æ„ã€‚Z è½´æ˜¯ä»ä¸‹åˆ°ä¸Šå®šå‘çš„ã€‚</p>
<p>RETICOLO is written with the ğ‘’ğ‘¥ğ‘(âˆ’ğ‘–ğœ”ğ‘¡) convention for the complex notation of the fields. So, if the materials are absorbant, one expects that all indices have a positive imaginary part. The Maxwellâ€™s equations are of the form</p>
<p>RETICOLO æ˜¯ç”¨ exp (- iÏ‰t)çº¦å®šä¹¦å†™çš„ï¼Œç”¨äºå­—æ®µçš„å¤æ‚ç¬¦å·ã€‚å› æ­¤ï¼Œå¦‚æœææ–™æ˜¯å¸æ”¶æ€§çš„ï¼Œäººä»¬æœŸæœ›æ‰€æœ‰çš„æŒ‡æ•°éƒ½æœ‰ä¸€ä¸ªæ­£è™šéƒ¨åˆ†ã€‚éº¦å…‹æ–¯éŸ¦æ–¹ç¨‹ç»„æ˜¯è¿™ç§å½¢å¼</p>
<p>where ğœ€ &#x3D; ğ‘›2 is the relative permittivity, a complex number, and ğœ† is the wavelength in a vacuum.</p>
<p>å…¶ä¸­ Îµ &#x3D; n2æ˜¯ç›¸å¯¹ç”µå®¹ç‡ï¼Œä¸€ä¸ªå¤æ•° Î» æ˜¯çœŸç©ºä¸­çš„æ³¢é•¿ã€‚</p>
<p>RETICOLO-1D returns the diffraction efficiencies of the transmitted and reflected orders for an incident plane wave from the top and for an incident plane wave from the bottom, both for TM and TE polarizations. The four results are obtained by the same calculation (incident TE wave from the top, incident TM wave from the top, incident TE wave from the bottom and incident TM wave from the bottom). Of course, the two incident plane waves must have identical parallel wave vector in the transverse plane [ kinc , kinc ]. This possibility which is not</p>
<p>RETICOLO-1D è¿”å›äº† TM å’Œ TE åæŒ¯æƒ…å†µä¸‹ä»é¡¶éƒ¨å…¥å°„çš„å¹³é¢æ³¢å’Œä»åº•éƒ¨å…¥å°„çš„å¹³é¢æ³¢çš„é€å°„å’Œåå°„é˜¶çš„è¡å°„æ•ˆç‡ã€‚å››ä¸ªç»“æœæ˜¯é€šè¿‡ç›¸åŒçš„è®¡ç®—(ä»é¡¶éƒ¨å…¥å°„çš„ TE æ³¢ï¼Œä»é¡¶éƒ¨å…¥å°„çš„ TM æ³¢ï¼Œä»åº•éƒ¨å…¥å°„çš„ TE æ³¢å’Œä»åº•éƒ¨å…¥å°„çš„ TM æ³¢)å¾—åˆ°çš„ã€‚å½“ç„¶ï¼Œä¸¤ä¸ªå…¥å°„å¹³é¢æ³¢åœ¨æ¨ªå‘å¹³é¢ä¸Šå¿…é¡»æœ‰ç›¸åŒçš„å¹³è¡Œæ³¢å‘é‡[ kincï¼Œkinc ]ã€‚è¿™ç§å¯èƒ½æ€§ä¸æ˜¯</p>
<h2 id="è·‘çš„é€š"><a href="#è·‘çš„é€š" class="headerlink" title="è·‘çš„é€š"></a>è·‘çš„é€š</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%   1  D    exemple10_1D</span></span><br><span class="line"><span class="comment">% ä¸åŒåšåº¦ä»¿çœŸ exemple2_1D</span></span><br><span class="line"><span class="comment">% ä¸åŒæ³¢é•¿ä»¿çœŸ exemple5_1D</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">addpath(<span class="string">&#x27;reticolo_allege_v9&#x27;</span>);</span><br><span class="line">t1 = clock;</span><br><span class="line">incident_angle = <span class="number">0</span>;</span><br><span class="line">wavelength_range(:,<span class="number">1</span>) = <span class="number">0.4</span>:<span class="number">0.010</span>:<span class="number">2</span>; <span class="comment">% æ³¢é•¿èŒƒå›´</span></span><br><span class="line">grating_period = <span class="number">1</span>; <span class="comment">% å…‰æ …å‘¨æœŸ</span></span><br><span class="line">grating_height = <span class="number">1</span>;</span><br><span class="line">incident_refractive_index = <span class="number">1</span>; <span class="comment">% å…¥å°„ä»‹è´¨çš„æŠ˜å°„ç‡</span></span><br><span class="line">beta0 = incident_refractive_index * <span class="built_in">sin</span>(incident_angle * <span class="built_in">pi</span> / <span class="number">180</span>); <span class="comment">% å…¥å°„è§’çš„ç›¸ä½è§’</span></span><br><span class="line">polarization = <span class="number">-1</span>; <span class="comment">% -1:TM   1:TE   </span></span><br><span class="line">parm = res0(polarization); parm.not_io = <span class="number">1</span>; <span class="comment">% åˆå§‹åŒ–å‚æ•°</span></span><br><span class="line">parm.sym.x = <span class="number">0</span>; <span class="comment">% åˆ©ç”¨å¯¹ç§°æ€§</span></span><br><span class="line">fourier_series = <span class="number">20</span>; <span class="comment">% Fourier series</span></span><br><span class="line"><span class="comment">%% ç»“æ„å°ºå¯¸å’ŒæŠ˜å°„ç‡</span></span><br><span class="line"><span class="comment">%&#123; </span></span><br><span class="line"><span class="comment">for ii = 1:12 textures&#123;ii&#125; = &#123;[-ii * grating_period / 13, 0], [1, 1.5]&#125;; end</span></span><br><span class="line"><span class="comment">% textures&#123;12&#125; = &#123;[-12 * grating_period / 13, -4,0], [3.2, 1,1.5]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;13&#125; = 1;textures&#123;14&#125; = 2.5;</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment"></span><span class="comment"></span></span><br><span class="line"><span class="comment">%&#123; </span></span><br><span class="line"><span class="comment">ii = 2;</span></span><br><span class="line"><span class="comment">textures&#123;1&#125; = &#123;[0,10,25], [1.5,1.7, 1.9]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;2&#125; = &#123;[0,10,15,25], [1.3,1.2, 1.4,1.1]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;ii+1&#125; = 1;</span></span><br><span class="line"><span class="comment">textures&#123;ii+2&#125; = 1.5;</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment">%&#123; 1</span></span><br><span class="line">ii = <span class="number">1</span>;</span><br><span class="line">textures&#123;<span class="number">1</span>&#125; = &#123;[<span class="number">0.25</span>,<span class="number">0.75</span>], [<span class="number">1</span>, <span class="number">2</span>]&#125;; </span><br><span class="line"><span class="comment">% textures&#123;2&#125; = &#123;[0,10,15,25], [1+3i,2, 1,2]&#125;; </span></span><br><span class="line">textures&#123;ii+<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line">textures&#123;ii+<span class="number">2</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%&#123; 1</span></span><br><span class="line"><span class="keyword">for</span> ix = <span class="number">20</span></span><br><span class="line">    fourier_series = ix;</span><br><span class="line">    T = <span class="built_in">zeros</span>(<span class="built_in">length</span>(wavelength_range), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> wave_num = <span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)</span><br><span class="line">        </span><br><span class="line">        aa = res1(wavelength_range(wave_num), grating_period, textures, fourier_series, beta0, parm);</span><br><span class="line">        profil = &#123;[<span class="number">0</span>,  (grating_height / <span class="number">1</span>), <span class="number">0</span>], [<span class="built_in">numel</span>(textures)<span class="number">-1</span>, <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-2</span>), <span class="built_in">numel</span>(textures)]&#125;;</span><br><span class="line">        ef = res2(aa, profil);</span><br><span class="line">        R(wave_num,<span class="number">1</span>) = sum(ef.inc_top_reflected.efficiency);</span><br><span class="line">        T(wave_num,<span class="number">1</span>) = sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Transmission_M(:,ix) = T;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment">%% ç»˜åˆ¶æŠ˜å°„ç‡</span></span><br><span class="line">wave_num = <span class="number">1</span>;</span><br><span class="line">aa = res1(wavelength_range(wave_num), grating_period, textures, fourier_series, beta0, parm);</span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, grating_period, <span class="number">100</span>); <span class="comment">% ç»˜åˆ¶çš„èŒƒå›´ ä¸¤ä¸ªå‘¨æœŸ </span></span><br><span class="line">parm.res3.cale = []; <span class="comment">% signifie que l&#x27;on ne calcule pas le champ</span></span><br><span class="line">profil = &#123;[<span class="number">2</span>,  grating_height, <span class="number">2</span>], [<span class="built_in">numel</span>(textures)<span class="number">-1</span>, <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-2</span>), <span class="built_in">numel</span>(textures)]&#125;;</span><br><span class="line">[tab1, z, o] = res3(x, aa, profil, <span class="number">1</span>, parm); </span><br><span class="line"></span><br><span class="line"><span class="comment">% plot_func(dimension,x,y,z,fontsize, linewidth, x_dis, y_dis, width, height,xlable, ylable, title)</span></span><br><span class="line">plot_func(<span class="number">3</span>,x,z,<span class="built_in">real</span>(o),<span class="number">25</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;X label range (Î¼m)&#x27;</span>,<span class="string">&#x27;Z label (Î¼m)&#x27;</span>,<span class="string">&#x27;æˆªé¢æŠ˜å°„ç‡&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% ç»˜åˆ¶é€å°„è°±</span></span><br><span class="line"><span class="comment">% plot_func(dimension,x,y,z,fontsize, linewidth, x_dis, y_dis, width, height,xlable, ylable, title)</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&#x27;Transmission_M&#x27;</span>) ~= <span class="number">0</span></span><br><span class="line">    plot_func(<span class="number">2</span>,wavelength_range,Transmission_M,  <span class="number">0</span>,<span class="number">25</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (Î¼m)&#x27;</span>,<span class="string">&#x27;Transmission&#x27;</span>,<span class="string">&#x27;é€å°„ç‡ä¸é˜¶æ•°çš„å…³ç³»&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t2 = clock; tc(t2,t1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="ä¸€ç»´å…‰æ …ç»“æ„-æ”¹ä¹‹å‰"><a href="#ä¸€ç»´å…‰æ …ç»“æ„-æ”¹ä¹‹å‰" class="headerlink" title="ä¸€ç»´å…‰æ …ç»“æ„-æ”¹ä¹‹å‰"></a>ä¸€ç»´å…‰æ …ç»“æ„-æ”¹ä¹‹å‰</h2><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230419103659141.png" srcset="/img/loading.gif" lazyload alt="image-20230419103659141" style="zoom:80%;" />



<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ä¸åŒåšåº¦ä»¿çœŸ exemple2_1D</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">addpath(<span class="string">&#x27;reticolo_allege_v9&#x27;</span>); addpath(<span class="string">&#x27;shuju&#x27;</span>);addpath(<span class="string">&#x27;script&#x27;</span>);addpath(<span class="string">&#x27;RCWA&#x27;</span>);</span><br><span class="line">t1 = clock;</span><br><span class="line">incident_angle = <span class="number">0</span>;</span><br><span class="line">wavelength_range(:,<span class="number">1</span>) = <span class="number">0.4</span>:<span class="number">0.001</span>:<span class="number">4</span>; <span class="comment">% æ³¢é•¿èŒƒå›´</span></span><br><span class="line"></span><br><span class="line">grating_period = <span class="number">1</span>; <span class="comment">% å…‰æ …å‘¨æœŸ</span></span><br><span class="line">incident_refractive_index = <span class="number">1</span>; <span class="comment">% å…¥å°„ä»‹è´¨çš„æŠ˜å°„ç‡</span></span><br><span class="line">k_parallel = incident_refractive_index * <span class="built_in">sin</span>(incident_angle * <span class="built_in">pi</span> / <span class="number">180</span>); <span class="comment">% å…¥å°„è§’çš„ç›¸ä½è§’</span></span><br><span class="line">polarization = <span class="number">-1</span>; <span class="comment">% -1:TM   1:TE   </span></span><br><span class="line">parm = res0(polarization); parm.not_io = <span class="number">1</span>; <span class="comment">% åˆå§‹åŒ–å‚æ•°</span></span><br><span class="line"><span class="comment">% parm.sym.x = 1; % åˆ©ç”¨å¯¹ç§°æ€§</span></span><br><span class="line">fourier_series_M = <span class="number">20</span>; <span class="comment">% Fourier series</span></span><br><span class="line">fourier_series = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 1  MgF2     % 11 W       % 21 VO2-hot</span></span><br><span class="line"><span class="comment">% 2  SiO2     % 12 Ti      % 22 VO2-cool</span></span><br><span class="line"><span class="comment">% 3  Al2O3    % 13 Fe      % 23 VO2-hot</span></span><br><span class="line"><span class="comment">% 4  Si3N4    % 14 Cr      % 24 DAST-Voltage</span></span><br><span class="line"><span class="comment">% 5  Si3N41ç›´ % 15 Mo*     % 25 ALON</span></span><br><span class="line"><span class="comment">% 6  TiO2     % 16 Au      % 26 ITO</span></span><br><span class="line"><span class="comment">% 7  SiN      % 17 Cu      % 27 Ag*</span></span><br><span class="line"><span class="comment">% 8  Ge       % 18 Al</span></span><br><span class="line"><span class="comment">% 9  PMMA     % 19 Ag </span></span><br><span class="line"><span class="comment">% 10 SiO2     % 20 VO2-cool</span></span><br><span class="line">nk_Martix = <span class="built_in">conj</span>(nk_data(wavelength_range*<span class="number">1000</span>));</span><br><span class="line"><span class="comment">%% ç»“æ„å°ºå¯¸å’ŒæŠ˜å°„ç‡</span></span><br><span class="line">struct.period = <span class="number">1</span>; </span><br><span class="line">struct.height(:,<span class="number">1</span>) =  [<span class="number">1.00</span>   <span class="number">1.00</span>   <span class="number">1</span>]; <span class="comment">% h1 h2 ...</span></span><br><span class="line">struct.width(:,<span class="number">1</span>) =  [<span class="number">0.4</span>    <span class="number">0.6</span>    <span class="number">0.8</span>];   <span class="comment">% w1 w2 ...</span></span><br><span class="line">struct.nkindex(:,<span class="number">1</span>) = [<span class="number">19</span>   <span class="number">19</span>      <span class="number">19</span>];</span><br><span class="line"><span class="comment">% FDTD</span></span><br><span class="line">struct.unit = <span class="number">1e-6</span>; <span class="comment">% 1e-6 Î¼m; 1e-9 nm</span></span><br><span class="line">struct.mesh = <span class="number">0.02</span>; <span class="comment">% mesh </span></span><br><span class="line">struct.mesh_M = <span class="number">0.01</span>;</span><br><span class="line">struct.wave_start = <span class="built_in">min</span>(wavelength_range);</span><br><span class="line">struct.wave_stop = <span class="built_in">max</span>(wavelength_range);</span><br><span class="line">struct.wave_step = wavelength_range(<span class="number">2</span>,<span class="number">1</span>)-wavelength_range(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% ç»“æ„çº¹ç† textures</span></span><br><span class="line">x_bloack = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">for</span> iz = <span class="number">1</span>:<span class="built_in">length</span>(struct.height)</span><br><span class="line">    textures&#123;iz&#125;(<span class="number">1</span>) = &#123;[-struct.width(iz,<span class="number">1</span>)/<span class="number">2</span>,struct.width(iz,<span class="number">1</span>)/<span class="number">2</span>]&#125;; <span class="comment">% è®¾ç½®ç»“æ„å®½åº¦</span></span><br><span class="line">    struct.nk(:,iz) = nk_Martix(:,struct.nkindex(iz,<span class="number">1</span>)); <span class="comment">% è®¾ç½®ç»“æ„æŠ˜å°„ç‡</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">scale_one = grating_period / x_bloack;</span><br><span class="line"><span class="keyword">for</span> io = <span class="number">1</span>:x_bloack</span><br><span class="line">    x_coordinate(io) = scale_one * (io - <span class="number">1</span>) - grating_period/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;(<span class="number">1</span>) = &#123;x_coordinate&#125;;</span><br><span class="line">textures&#123;iz+<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> method = <span class="number">1</span>:<span class="number">1</span>  <span class="comment">% 1: RCWA 2:FDTD</span></span><br><span class="line"><span class="keyword">switch</span> method    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="comment">%% 1 RCWA</span></span><br><span class="line">        <span class="keyword">for</span> ix = <span class="number">1</span>:<span class="built_in">length</span>(fourier_series_M)</span><br><span class="line">            fourier_series = fourier_series_M(ix);</span><br><span class="line">            R = <span class="built_in">zeros</span>(<span class="built_in">length</span>(wavelength_range), <span class="number">1</span>); T = R; A = R; </span><br><span class="line">            textures_local = textures; aa_save = &#123;&#125;; profil_save = &#123;&#125;; textures_save = &#123;<span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)&#125;;</span><br><span class="line">            <span class="keyword">parfor</span> wave_num = <span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)                 </span><br><span class="line">                textures = textures_local;</span><br><span class="line">                <span class="keyword">for</span> izz = <span class="number">1</span>:iz;textures&#123;izz&#125;(<span class="number">2</span>) = &#123;[<span class="number">1</span>, struct.nk(wave_num,izz)]&#125;;<span class="keyword">end</span>;</span><br><span class="line">                b_ix = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">length</span>(textures&#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;));</span><br><span class="line">                <span class="keyword">for</span> ia = <span class="number">1</span>:<span class="built_in">length</span>(textures&#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;)</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">rem</span>(ia, <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">                        b_ix(ia) = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                textures&#123;<span class="number">3</span>&#125;(<span class="number">2</span>) = &#123;b_ix&#125;;</span><br><span class="line"></span><br><span class="line">                aa = res1(wavelength_range(wave_num), struct.period, textures, fourier_series, k_parallel, parm);</span><br><span class="line">                profile = &#123;[<span class="number">0</span>,  struct.height&#x27;, <span class="number">0</span>], [<span class="built_in">length</span>(textures), <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-1</span>), <span class="built_in">length</span>(textures)]&#125;;</span><br><span class="line">                <span class="comment">% è®¡ç®—</span></span><br><span class="line">                ef = res2(aa, profile);</span><br><span class="line">                R(wave_num,<span class="number">1</span>) = sum(ef.inc_top_reflected.efficiency);</span><br><span class="line">                T(wave_num,<span class="number">1</span>) = sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">                A(wave_num,<span class="number">1</span>) = <span class="number">1</span> - sum(ef.inc_top_reflected.efficiency) - sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">                textures_save&#123;wave_num&#125; = textures; aa_save&#123;wave_num&#125; = aa; profil_save&#123;wave_num&#125; = profile;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            RCWA.R(:,ix) = R; RCWA.T(:,ix) = T; RCWA.A(:,ix) = A;</span><br><span class="line">            t2 = clock; tc(t2,t1);</span><br><span class="line">            RCWA.T_matrix(:,ix) = T;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        RCWA.RTA = [R T A]; RCWA.R = R; RCWA.T = T; RCWA.A = A; </span><br><span class="line"></span><br><span class="line">        textures = textures_save&#123;<span class="number">1</span>&#125;; aa = aa_save&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        profile = profil_save&#123;<span class="number">1</span>&#125;; profile&#123;<span class="number">1</span>&#125;(<span class="number">1</span>) = <span class="number">2</span>; profile&#123;<span class="number">1</span>&#125;(<span class="keyword">end</span>) = <span class="number">2</span>;</span><br><span class="line">        x = <span class="built_in">linspace</span>(-struct.period/<span class="number">2</span>, struct.period/<span class="number">2</span>, <span class="built_in">max</span>(x_bloack*<span class="number">2</span>, <span class="number">100</span>));</span><br><span class="line">        [e, z, o] = res3(x, aa, profile, <span class="number">1</span>, parm);         </span><br><span class="line">        plot_func(<span class="number">3</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span>],x,z,<span class="built_in">real</span>(o),<span class="number">15</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">900</span>,<span class="number">400</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;æˆªé¢æŠ˜å°„ç‡&#x27;</span>);      </span><br><span class="line">        <span class="comment">%% ç»˜åˆ¶é€å°„è°±</span></span><br><span class="line">        plot_func(<span class="number">2</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>],wavelength_range,RCWA.T_matrix,<span class="number">0</span>, <span class="number">15</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (Î¼m)&#x27;</span>,<span class="string">&#x27;Transmission&#x27;</span>,<span class="string">&#x27;RCWA é€å°„&#x27;</span>);</span><br><span class="line">        plot_func(<span class="number">3</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span>],x,z,e(:,:,<span class="number">1</span>).*<span class="built_in">conj</span>(e(:,:,<span class="number">1</span>)),<span class="number">15</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">900</span>,<span class="number">400</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;abs(E)^2&#x27;</span>);      </span><br><span class="line">        </span><br><span class="line">        t2 = clock; tc(t2,t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 2 FDTD</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> mesh_num = <span class="number">1</span>:<span class="built_in">length</span>(struct.mesh_M)</span><br><span class="line">            struct.mesh = struct.mesh_M(mesh_num); FDTD = fun_1D(struct); t2 = clock; tc(t2,t1);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        plot_func(<span class="number">2</span>, <span class="number">0</span>,FDTD.wave,FDTD.T,<span class="number">0</span>, <span class="number">25</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (Î¼m)&#x27;</span>,<span class="string">&#x27;R/T/A&#x27;</span>,<span class="string">&#x27;FDTD é€å°„&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;<span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">å­¦ä¹ </a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/RCWA/">#RCWA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RCWA ç›¸å…³1</div>
      <div>http://example.com/2023/11/08/RCWA/RCWAç›¸å…³/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>ä½œè€…</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>å‘å¸ƒäº</div>
          <div>2023å¹´11æœˆ8æ—¥</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>æ›´æ–°äº</div>
          <div>2023å¹´6æœˆ27æ—¥</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>è®¸å¯åè®®</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - ç½²å">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/08/RCWA/RCWA%E7%A8%8B%E5%BA%8F/" title="RCWA ç¨‹åº">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RCWA ç¨‹åº</span>
                        <span class="visible-mobile">ä¸Šä¸€ç¯‡</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/08/Python/Python%E5%B8%B8%E7%94%A8/" title="Pythonå¸¸ç”¨">
                        <span class="hidden-mobile">Pythonå¸¸ç”¨</span>
                        <span class="visible-mobile">ä¸‹ä¸€ç¯‡</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">æœç´¢</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">å…³é”®è¯</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        æ€»è®¿é—®é‡ 
        <span id="busuanzi_value_site_pv"></span>
         æ¬¡
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        æ€»è®¿å®¢æ•° 
        <span id="busuanzi_value_site_uv"></span>
         äºº
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- ä¸»é¢˜çš„å¯åŠ¨é¡¹ï¼Œå°†å®ƒä¿æŒåœ¨æœ€åº•éƒ¨ -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">åšå®¢åœ¨å…è®¸ JavaScript è¿è¡Œçš„ç¯å¢ƒä¸‹æµè§ˆæ•ˆæœæ›´ä½³</div>
  </noscript>
</body>
</html>
