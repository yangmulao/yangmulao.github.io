

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="RCWA1介绍$\boldsymbol{E}{top}^{inc}exp\left(i\big(k_x^{inc}x+k{z~top}^{inc}(z-h)\big)\right)$ $a&#x3D;a+b$ RCWA（Rigorous Coupled Wave Analysis）全名是严格耦合波分析，是一种用于设计、分析及优化周期性结构的数值计算方法。它可以用来模拟各种周期性结构，比如光学元器件">
<meta property="og:type" content="article">
<meta property="og:title" content="RCWA 相关1">
<meta property="og:url" content="http://example.com/2023/11/08/RCWA/RCWA%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RCWA1介绍$\boldsymbol{E}{top}^{inc}exp\left(i\big(k_x^{inc}x+k{z~top}^{inc}(z-h)\big)\right)$ $a&#x3D;a+b$ RCWA（Rigorous Coupled Wave Analysis）全名是严格耦合波分析，是一种用于设计、分析及优化周期性结构的数值计算方法。它可以用来模拟各种周期性结构，比如光学元器件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403163538201.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403164752176.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403165245428.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403170721968.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403230539759.png">
<meta property="og:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230419103659141.png">
<meta property="article:published_time" content="2023-11-08T01:57:50.071Z">
<meta property="article:modified_time" content="2023-06-27T02:26:51.575Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="RCWA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>RCWA 相关1 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wbupt</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">RCWA 相关1</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-08 09:57" pubdate>
          2023年11月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          66k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          548 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RCWA 相关1</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：10 个月前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="RCWA1"><a href="#RCWA1" class="headerlink" title="RCWA1"></a>RCWA1</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>$\boldsymbol{E}<em>{top}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z~top}^{inc}(z-h)\big)\right)$</p>
<p>$a&#x3D;a+b$</p>
<p>RCWA（Rigorous Coupled Wave Analysis）全名是<code>严格耦合波分析</code>，是一种用于设计、分析及优化周期性结构的数值计算方法。它可以用来模拟各种周期性结构，比如光学元器件中的光栅、光纤光栅、光子晶体等，也可以用于模拟电磁结构中的电磁波导、电磁障碍物、互联线等。</p>
<p>RCWA方法利用<code>傅里叶变换</code>将<strong>周期相干场</strong>分解为<strong>傅里叶变换</strong>的模式，然后利用模式的耦合关系求解出这些模式的反射、透射、散射等物理量。由于RCWA是一种严格的全波方法，因此它可以考虑各种效应，比如多次反射、全息效应等，对于对场分布有精细要求的问题有很好的解决方案。</p>
<p>RCWA具有高精度、高效能、灵活性等特点，因此它已经成为现代光学和电磁学中一种常用的设计和分析周期性结构的工具。</p>
<hr>
<h1 id="RETICOLO-网状的"><a href="#RETICOLO-网状的" class="headerlink" title="RETICOLO 网状的"></a>RETICOLO 网状的</h1><p>Authors: J.P. Hugonin and P. Lalanne</p>
<p>• Reticolo 1D代码用于分析传统安装中的1D光栅。</p>
<p>arXiv: 2101:00901</p>
<p>• Reticolo 1D-conical代码用于分析传统和锥形安装中的1D光栅。</p>
<p>• Reticolo 2D代码用于分析2D交叉光栅。</p>
<p>分析二维交叉光栅。</p>
<p>它们是在Matlab下运行的免费软件。要安装它们，请复制附带的文件夹“reticolo_allege”，并将文件夹添加到Matlab路径中。软件可以在此处下载。</p>
<h3 id="This-technical-note-is-composed-of-three-parts"><a href="#This-technical-note-is-composed-of-three-parts" class="headerlink" title="This technical note is composed of three parts:"></a>This technical note is composed of three parts:</h3><p>本技术说明由三部分组成:</p>
<ol>
<li>Reticolo code 1D for analyzing 1D gratings in classical mountings Reticolo 代码1D用于分析经典安装中的一维光栅</li>
<li>Reticolo code 1D-conical for analyzing 1D gratings in classical and conical mountings 用于分析经典和锥形装置中的一维光栅的 Reticolo 程序1D锥形</li>
<li>Reticolo code 2D for analyzing 2D crossed grating Reticolo 代码2D用于分析二维交叉光栅</li>
</ol>
<p>They are free software that operate under Matlab. To install them, copy the companion folder “reticolo_allege” and add the folder in the Matlab path. The software can be downloaded here.</p>
<p>它们是在 Matlab 下运行的自由软件。要安装它们，复制相关文件夹“ reticolo _ allege”，并将该文件夹添加到 Matlab 路径中。软件可以在这里下载</p>
<p>The version V9 launched in 01&#x2F;2021 features a few novelties:</p>
<p>2021年1月发布的 v9版本有一些新特性:</p>
<p>ü it includes a treatment of stacks of arbitrarily anisotropic multilayered thin-films.1 Be aware that the substrate and superstrate cannot be anisotropic. This part is documented in Reticolo codes 1D-conical (or identically 2D).</p>
<p>它包括对任意各向异性的多层薄膜堆叠的处理，1 Be 意识到衬底和上层不能是各向异性的。这部分记录在 Reticolo 代码1d-锥形(或同样的2d)中。</p>
<p>ü It features an option to visualize the Bloch modes.</p>
<p>它提供了一个可视化 Bloch 模式的选项。</p>
<p>ü Diagonal anisotropy (𝜺𝒙𝒙 ≠ 𝜺𝒚𝒚 ≠ 𝜺𝒛𝒛) can be incorporated in structured grating layers and gratings with uniform layers having arbitrary anisotropy (𝜺𝒙𝒚 ≠ 𝟎 …) can also be handled)</p>
<p>对角各向异性(εxx ≠ εy≠ εzz)可以被引入到结构光栅层中，具有任意各向异性的均匀层光栅(εxy ≠0…)也可以被处理</p>
<p>ü It is fully compatible with earlier versions.</p>
<p>它与早期版本完全兼容。</p>
<p>2021年1月发布的V9版本具有一些新功能： 它包括对任意各向异性多层薄膜堆的处理。请注意，基板和上置基底不能是各向异性的。本部分在Reticolo代码1D-conical（或2D相同）中有文档记录。 它具有可视化布洛赫模的选项。 对于具有对角各向异性（≠≠）的结构性光栅层以及具有任意各向异性（≠ …）的均匀光栅层的光栅也可以处理。 它与早期版本完全兼容。</p>
<p>2021年1月发展的 v9版本有一些新功能: 它包括它包括它对任意角层的光栅的意义，基础板和上基底性不能够是各向性的分部分别在 reticolo 码1d-锥形(或2d 相对)中有文档记录。它以及具有可视化布洛赫的选项对于有具体项目具有可视化布洛赫的选项。</p>
<p>This is simply achieved by retaining a single Fourier harmonics coefficient in the expansion (nn&#x3D;0). The extension is not optimal from numerical-efficiency perspectives, but has been provided on demand of several users who additionally complained of mistakes in available freeware packages on thin films.</p>
<p>这只是通过在展开式中保留一个单一的傅里叶谐波系数(nn &#x3D; 0)来实现。从数值效率的角度来看，这种扩展并不是最佳的，但它是根据一些用户的要求提供的，这些用户还抱怨可用的薄膜免费软件包中存在错误。</p>
<p>Note also that we have launched in 2013 the RETICOLOfilm-stack program, a freeware that computes the reflection and transmission of arbitrary stacks of anisotropic thin films. RETICOLOfilm-stack is vectorialized and thus treats several wavelengths and incidences in a single instruction (see <a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710">https://zenodo.org/record/7512710</a>).</p>
<p>请注意，我们在2013年发布了 RETICOLOfilm-stack 程序，这是一个计算任意堆叠各向异性薄膜的反射和透射的免费软件。RETICOLOfilm-stack 是矢量化的，因此在一条指令中处理多个波长和入射(见 <a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710)%E3%80%82">https://zenodo.org/record/7512710)。</a></p>
<p>通过在展开式中保留单个傅里叶谐波系数（nn&#x3D;0）即可轻松实现该目标。从计算效率的角度来看，扩展不是最优的，但是由于多个用户要求并提到了现有免费软件程序中的错误，因此我们提供了这个扩展。 此外，请注意，2013年我们推出了RETICOLOfilm-stack程序，它是一个免费软件，用于计算各向异性薄膜的任意堆栈的反射和透射。RETICOLOfilm-stack是矢量化的，因此可以在单个指令中处理多个波长和入射角度（请参见<a target="_blank" rel="noopener" href="https://zenodo.org/record/7512710%EF%BC%89%E3%80%82">https://zenodo.org/record/7512710）。</a></p>
<p>通过在此我们提出了 reticolofilm-stack，它是一个免费软件即可计算堆长和在各种轻向异射膜系统中的反射透射度角的设计</p>
<h1 id="RETICOLO-CODE-1D"><a href="#RETICOLO-CODE-1D" class="headerlink" title="RETICOLO CODE 1D"></a>RETICOLO CODE 1D</h1><p>for the diffraction by stacks of lamellar 1D gratings (classical diffraction) 用于分析分层1D光栅的衍射 （经典衍射）</p>
<p>对于层状一维光栅的衍射(经典衍射) ，用于分析层状一维光栅的衍射(经典衍射)</p>
<p>Reticolo code 1D is a free software for analyzing 1D gratings in classical mountings. It operates under Matlab. To install it, copy the companion folder “reticolo_allege” and add the folder in the Matlab path. Reticolo code 1D  是一款免费软件，用于分析经典安装的一维光栅。它在 Matlab 下运行。要安装它，复制伴随文件夹“ reticolo _ allege”，并将该文件夹添加到 Matlab 路径中。</p>
<h2 id="1-Generality-概述"><a href="#1-Generality-概述" class="headerlink" title="1. Generality 概述"></a>1. Generality 概述</h2><p>它可以计算由层状结构组成的光栅的衍射效率和衍射幅度。它包含用于计算和可视化光栅内部和外部的电磁场的例程。在此版本中，无法分析二维周期性的（交叉的）光栅。</p>
<p>RETICOLO is a code written in the language MATLAB 9.0. It computes the diffraction efficiencies and the diffracted amplitudes of gratings composed of stacks of lamellar structures. It incorporates routines for the calculation and visualisation of the electromagnetic fields inside and outside the grating. With this version, 2D periodic (crossed) gratings cannot be analysed.</p>
<p>RETICOLO是用MATLAB 9.0编写的代码。它计算由层状结构组成的光栅的衍射效率和衍射振幅。它包括计算和可视化光栅内外电磁场的例程。这个版本中，无法分析二维周期性（交叉）光栅。</p>
<p>As free alternative to MATLAB, RETICOLO can also be run in GNU Octave with minimal code changes. For further information, please contact <a href="mailto:&#116;&#105;&#110;&#97;&#x2e;&#x6d;&#105;&#116;&#x74;&#101;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#x74;">&#116;&#105;&#110;&#97;&#x2e;&#x6d;&#105;&#116;&#x74;&#101;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#x74;</a>.</p>
<p>作为MATLAB的免费替代品，RETICOLO也可以在GNU Octave中运行，只需进行最小程度的代码更改。欲了解更多信息，请联系<a href="mailto:&#x74;&#x69;&#110;&#x61;&#46;&#109;&#105;&#x74;&#x74;&#x65;&#114;&#x61;&#x6d;&#x73;&#107;&#x6f;&#103;&#108;&#x65;&#114;&#64;&#x70;&#114;&#111;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#116;">&#x74;&#x69;&#110;&#x61;&#46;&#109;&#105;&#x74;&#x74;&#x65;&#114;&#x61;&#x6d;&#x73;&#107;&#x6f;&#103;&#108;&#x65;&#114;&#64;&#x70;&#114;&#111;&#102;&#97;&#x63;&#116;&#111;&#x72;&#x2e;&#x61;&#116;</a>。</p>
<p>In brief, RETICOLO implements a frequency-domain modal method (known as the Rigorous Coupled wave Analysis&#x2F;RCWA). To get an overview of the RCWA, the interested readers may refer to the following articles:</p>
<p>简而言之，RETICOLO 实现了一种频域模态方法(称为严格耦合波分析&#x2F;RCWA)。为了得到 RCWA 的概述，感兴趣的读者可以参考以下文章:</p>
<p><code>1D-classical and conical diffraction</code> 1d-经典和圆锥衍射</p>
<ol>
<li><p>M.G. Moharam et al., JOSAA <strong>12</strong>, 1068 (1995),</p>
</li>
<li><p>M.G. Moharam et al, JOSAA <strong>12</strong>, 1077 (1995),</p>
</li>
<li><p>P. Lalanne and G.M. Morris, JOSAA <strong>13</strong>, 779 (1996),</p>
</li>
<li><p>G. Granet and B. Guizal, JOSAA <strong>13</strong>, 1019 (1996),</p>
</li>
<li><p>L. Li, JOSAA <strong>13</strong>, 1870 (1996), see also C. Sauvan et al., Opt. Quantum Electronics <strong>36</strong>, 271-284 (2004) which simply explains the raison of the convergence-rate improvement of the Fourier-Factorization rules without requiring advanced mathematics on Fourier series and generalizes to other kinds of expansions. 具体而言，关于傅里叶分解规则的收敛速率优化原因，可以参考李灵宏在1996年发表在JOSAA期刊上的文章“Efficient computation of diffraction in the Rayleigh-Sommerfeld region by exact use of the scalar wave equation”以及C. Sauvan等人在2004年出版的文章“Theory of the Fabry-Pérot resonator: A review”（Opt. Quantum Electronics 36, 271-284），两篇文章均不需要关于傅里叶级数和其他扩展方法的高级数学知识，可以简单地解释傅里叶分解规则的收敛速率优化原因，并推广至其他类型的展开方法。</p>
</li>
</ol>
<p><code>2D-crossed gratings</code> 2d 交叉光栅</p>
<ol>
<li>L. Li, JOSAA <strong>14</strong>, 2758-2767 (1997),</li>
<li>E. Popov and M. Nevière, JOSAA <strong>17</strong>, 1773 (2000)</li>
</ol>
<p>which describe the up-to-date formulation of the approach used in RETICOLO. Note that the formulation used in the last article (which proposes an improvement for analysing metallic gratings with continuous profiles like sinusoidal gratings) is not available in the RETICOLO version of the web. The RCWA relies on the computation of the eigenmodes in all the layers of the grating structure in a Fourier basis (plane-wave basis) and on a scattering matrix approach to recursively relate the mode amplitudes in the different layers.</p>
<p>描述了 RETICOLO 中使用的方法的最新公式。请注意，上一篇文章中使用的公式(其中提出了一种改进方案，用于分析具有连续剖面的金属光栅，如正弦光栅)在 RETICOLO 版本的 web 中是不可用的。RCWA 依赖于在傅里叶基(平面波基)上计算光栅结构各层的本征模，并利用散射矩阵方法将不同层的模振幅递推关联起来。</p>
<p><code>Eigenmode solver</code> For conical diffraction analysis of 1D gratings, the Bloch eigenmode solver used in Reticolo is based on the article “P. Lalanne and G.M. Morris, JOSAA <strong>13</strong>, 779 (1996)”.</p>
<p>本征模式求解器: 对于一维光栅的圆锥衍射分析，Reticolo 中使用的 Bloch 本征模式求解器是基于“ p. Lalanne 和 g.m. Morris，JOSAA 13,779(1996)”一文</p>
<p><code>Scattering matrix approach</code> The code incorporates many refinements that we have not published and that we do not plan to publish. For instance, although it is generally admitted that the S-matrix is inconditionnally stable, it is not always the case. We have developed an in-house transfer matrix method which is more stable and accurate. The new transfer matrix approach is also more general and can handle perfect metals. The essence of the method has been rapidly published in “J.-P. Hugonin, M. Besbes and P. Lalanne, Op. Lett. <strong>33</strong>, 1590 (2008)”.</p>
<p>散射矩阵方法: 该代码包含了许多我们没有发表过也不打算发表的改进。例如，尽管人们普遍承认 s 矩阵是无条件稳定的，但事实并非总是如此。我们开发了一种更稳定和准确的内部转移矩阵方法。新的转移矩阵方法也更加通用，可以处理完美的金属。这种方法的精髓已经在《日报》上迅速发表。作者: Hugonin，m. Besbes and p。莱特。33,1590(2008)”。</p>
<p><code>Field calculation</code> The calculation of the near-field electromagnetic fields everywhere in the grating is performed according to the method described in “P. Lalanne, M.P. Jurek, JMO <strong>45</strong>, 1357 (1998)” and to its generalization to crossed gratings (unpublished). Basically, no Gibbs phenomenon will be visible in the plots of the discontinuous electromagnetic quantities, but field singularities at corners will be correctly handled.</p>
<p><strong>场计算: 根据“ P.Lalanne，m.p. Jurek，JMO 45,1357(1998)”中描述的方法及其对交叉光栅的推广(未发表) ，计算了光栅内各处的近场电磁场。基本上，在不连续电磁量的图中不会看到吉布斯现象，但是在角落处的场奇异性将被正确处理。</strong></p>
<p><code>Acknowledging the use of RETICOLO</code> In publications and reports, acknowledgments have to be provided by referencing to J.P. Hugonin and P. Lalanne, RETICOLO software for grating analysis, Institut d’Optique, Orsay, France (2005), arXiv:2101:00901.</p>
<p>使用RETICOLO声明: 在出版物和报告中，承认必须参考 j.p. Hugonin 和 p. Lalanne，RETICOLO 光栅分析软件，法国 Orsay 光学研究所，arXiv: 2101:00901</p>
<p><strong>In addition, one may fairly quote the following references in journal publications</strong>:</p>
<p>此外，人们可以在期刊出版物中公正地引用以下参考文献:</p>
<p>-M.G. Moharam, E.B. Grann, D.A. Pommet and T.K. Gaylord, “Formulation for stable and efficient implementation of the rigorous coupled-wave analysis of binary gratings”, J. Opt. Soc. Am. A <strong>12</strong>, 1068-1076 (1995), if TE-polarization efficiency calculations are provided -P. Lalanne and G.M. Morris, “Highly improved convergence of the coupled-wave method for TM polarization”,</p>
<p>- m.g. Moharam，e.b. Grann，d.a. Pommet 和 t.k. Gaylord，“稳定和有效地实施严格的二元光栅耦合波分析的公式”，J.Opt。译注:。译注:。A 12,1068-1076(1995) ，如果提供 te 偏振效率的计算-p. Lalanne 和 gm. Morris，“极大地改进了 TM 偏振耦合波方法的收敛性”,</p>
<p>J. Opt. Soc. Am. A <strong>13</strong>, 779-789 (1996) and G. Granet and B. Guizal, “Efficient implementation of the coupled- wave method for metallic lamellar gratings in TM polarization”, J. Opt. Soc. Am. A <strong>13</strong>, 1019-1023 (1996), if TM- polarization efficiency calculations are provided, -P. Lalanne and M.P. Jurek, “Computation of the near-field pattern with the coupled-wave method for TM polarization”, J. Mod. Opt.45, 1357-1374 (1998), if near-field electromagnetic-field distributions are shown.</p>
<h2 id="2-The-diffraction-problem-considered"><a href="#2-The-diffraction-problem-considered" class="headerlink" title="2 The diffraction problem considered"></a>2 The diffraction problem considered</h2><p>颜色问题的考虑</p>
<p>In general terms, the code solves the diffraction problem by a grating defined by a stack of layers (in the z- direction) which have all identical periods in the x-direction and are invariant in the y direction, see Fig. 1. In the following, the (x,y) plane and the z-direction will be referred to as the transverse plane and the longitudinal direction, respectively. To define the grating structure, first we have to define a top and a bottom. This is rather arbitrary since the top or the bottom can be the substrate or the cover of a real structure. It is up to the user. Once the top and the bottom of the grating have been defined, the user can choose to illuminate the structure from the top or from the bottom. The z-axis is oriented from bottom to top.</p>
<p>通常情况下，该代码通过在z方向上具有相同周期的层数组成的光栅来求解衍射问题，该光栅在x方向上具有相同的周期并在y方向上不变，见图1。接下来，（x，y）平面和z方向将分别称为横向平面和纵向方向。为了定义光栅结构，首先我们需要定义其顶部和底部。这相当任意，因为顶部或底部可以是真实结构的衬底或覆盖层，根据用户的设定来选择。在定义了光栅的顶部和底部后，用户可以从顶部或底部照射光结构。z轴从下向上定向。</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png" srcset="/img/loading.gif" lazyload alt="image-20230403113229636" style="zoom: 67%;" />



<p> 图1. 衍射场的瑞利展开。 第m阶具有平行动量等于𝑘𝑥𝑖𝑛𝑐+ 𝑚𝐾𝑥。我们定义两个点Otop &#x3D; (0,0, h)在光栅顶部以及Obottom &#x3D; (0,0,0)在光栅底部。</p>
<p>RETICOLO is written with the convention for the complex notation of the fields. So, if the materials are absorbant, one expects that all indices have a positive imaginary part. The Maxwell’s equations are of the form<br>RETICOLO 是用约定书写的，用于字段的复杂符号。因此，如果材料是吸收性的，人们期望所有的指数都有一个正虚部分。麦克斯韦方程组是这种形式</p>
<p>其中，𝜀&#x3D; 𝑛2 是相对介电常数，为一个复数，𝜆是真空中的波长。</p>
<p>接下来，考虑了两种情况： </p>
<ol>
<li>TE极化：电场E与Oy平行； </li>
<li>TM极化：磁场H与Oy平行。</li>
</ol>
<p>RETICOLO returns the diffraction efficiencies of the transmitted and reflected orders for a plane wave incident from the top and from the bottom with the same calculation. Of course, these two incident plane waves must have identical x-component of the parallel wave vector: $k_{x}^{inc}$. This possibility which is not mentioned in the literature to our knowledge is important in practice since the user may get, with the same computational loads, the diffraction efficiencies of the grating component illuminated from the substrate or from the cover.</p>
<p>RETICOLO可以返回从顶部和底部入射的平面波的衍射效率的透射和反射阶数，并采用相同的计算。当然，这两个入射平面波的平行波矢量的x分量必须相同：$k_{x}^{inc}$。在我们所知的文献中未提到这一可能性，但在实践中非常重要，因为用户可以在同样的计算负载下获取从衬底或覆盖层照明的光栅组件的衍射效率。</p>
<p> RETICOLO-1D calculates the electric and magnetic fields diffracted by the grating for the following incident plane wave:</p>
<p>RETICOLO-1D 计算了以下入射平面波的光栅衍射的电场和磁场:</p>
<p>$\boldsymbol{E}<em>{top}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z~top}^{inc}(z-h)\big)\right)$</p>
<p>$\textbf{H}^{inc}<em>{top}\textit{exp}\left(i\left(k^{inc}</em>{x}x+k^{inc}_{ztop}(z-h)\right)\right)$ 如果从顶部层入射，</p>
<p>where $<del>k^{inc}_{z</del>top}&#x3D;-\sqrt{\left(2\pi n_{top}&#x2F;\lambda\right)^2-(k^{inc}_x)^2}$</p>
<p>$\boldsymbol{E}<em>{bottom}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z\text{bottom}}^{inc}(z-h)\big)\right)$</p>
<p>$\textbf{H}<em>{bottom}^{inc}exp\left(i\big(k_x^{inc}x+k</em>{z\textit{bottom}}^{inc}(z-h)\big)\right)$, 如果从底部层入射，</p>
<p>where $k_{Z\textit{bottom}}^{inc}&#x3D;\sqrt{(2\pi n_{bottom}&#x2F;\lambda)^2-(k_x^{inc})^2}$.</p>
<p>The z-component of the Poynting vector of the incident plane wave is ±0.5.</p>
<p>入射平面波的波矢量的z分量为±0.5。</p>
<p>The Rayleigh-expansion of the diffracted electric fields are shown in the following figure. </p>
<p>下图显示了衍射电场的瑞利展开结果：</p>
<p> $\boldsymbol{E}^{diff}<em>{top}&#x3D;\sum_m\boldsymbol{E}^{m}</em>{top}\exp\left[i((k^{inc}<em>x+mK_x)x+k^{m}</em>{z\text{top}}(z-h)\right]$</p>
<p>$\boldsymbol{H}<em>{top}^{d i f}&#x3D;\sum_m\boldsymbol{H}^{m}</em>{top}\exp\left[i((k^{inc}<em>x+mK_x)x+k^{m}</em>{ztop}(z-h)\right]$</p>
<p>where $k^m_{z~top}&#x3D;\sqrt{\left(2\pi n_{top}&#x2F;\lambda\right)^2-(k^inc_x+m K_x)^2}$</p>
<p>$\begin{array}{rcl}\boldsymbol{E}^{diff}<em>{bottom}&amp;&#x3D;\sum_m\boldsymbol{E}^{m}</em>{bottom}exp\left[i((k_x^{inc}+mK_x)x+k^{m}_{\text{z bottom}}z\right]\end{array}$</p>
<p>$\begin{array}{r l}\boldsymbol H_{bottom}^{diff}&amp;&#x3D;\sum_m\boldsymbol H_{bottom}^m exp[i((k_x^{inc}+mK_x)x+k_{z\text{bottom}}^m z]\end{array}$</p>
<p>where $k^m_z\text{bottom}&#x3D;\sqrt{(2\pi n_{bottom}&#x2F;\lambda)^2-(k^inc_x+mK_x)^2}$</p>
<p>They are shown in the following figure. 它们如图1所示。</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403113229636.png" srcset="/img/loading.gif" lazyload alt="image-20230403113229636" style="zoom: 67%;" />



<p>Fig. 1. Rayleigh expansion for the diffracted fields. $K_x&#x3D;(2\pi)&#x2F;period$. The $m^{\text{th}}$ order has a parallel momentum equal to $\quad k_{x}^{inc}+m K_{x}$. We define two points $\text{O}<em>{\text{top}}&#x3D;(0,0,\text{h})$ at the top of the grating, and $\text{O}</em>{\text{bottom}}&#x3D;(0,0,0)$ at the bottom of the grating .</p>
<p> 图1. 衍射场的瑞利展开。 𝐾𝑥&#x3D;(2𝜋)&#x2F;𝑝𝑒𝑟𝑖𝑜𝑑。第m阶具有平行动量等于𝑘𝑥𝑖𝑛𝑐+ 𝑚𝐾𝑥。我们定义两个点Otop &#x3D; (0,0, h)在光栅顶部以及Obottom &#x3D; (0,0,0)在光栅底部。</p>
<p>The following is organized so that one can straightforwardly write a code using the software 以下内容旨在帮助用户直接使用该软件编写代码.</p>
<h2 id="Preliminary-input-parameters-初步输入参数"><a href="#Preliminary-input-parameters-初步输入参数" class="headerlink" title="Preliminary input parameters 初步输入参数"></a>Preliminary input parameters 初步输入参数</h2><p>The name of the following parameters are given as examples. The user may define his own parameter vocabulary. 下列参数的名称作为示例给出。用户可以定义自己的参数词汇表。</p>
<p><strong>wavelength &#x3D; 3</strong>; % wavelength (l) in a vacuum. It might be 3 nm or 3 µm. You do not need to specify the unit but all other dimensions are of course in the same unit as the wavelength.</p>
<p>在真空中，wavelength &#x3D; 3;% wavelength ()。它可能是3 nm 或3 μm。你不需要指定单位，但所有其他维度当然是在同一个单位作为波长。</p>
<p>period &#x3D; in the x-direction.  周期 &#x3D; 在 x 方向</p>
<p><code>nn = 20</code>; % this define the set of Fourier harmonics retained for the computation. More specifically, 2´nn+1 represent the number of Fourier harmonics retained from –nn to nn. This is a very important parameter ; for large n values, a high accuracy for the calculated data is achieved, but the computational time and memory is also large. If all the textures are homogeneous (case of a thin-film stack), we may set nn&#x3D;1 and the period may be arbitrarily set to any value, 1 for example. NB: Because of our normalization (Poynting vector equal to 1), the computed reflected and transmitted amplitude coefficients are not identical to those provided by the classical Fresnel formulas found in textbooks.</p>
<p><code>nn = 20</code>  ％这定义了计算中保留的傅里叶谐波集合。更具体地说，2×nn+1代表从-nn到nn保留的傅里叶谐波数量。这是一个非常重要的参数；对于大的n值，可以实现计算数据的高精度，但计算时间和内存也很大。如果所有的纹理都是均匀的（如薄膜堆），我们可以将nn设置为1，周期可以任意设置为任何值，例如1。注意：由于我们的归一化（泊松矢量等于1），计算得到的反射和透射幅度系数与教科书中的经典Fresnel公式提供的系数不同。</p>
<p><code>parm = res0(1)</code> for TE polarization;  对于 TE 极化，parm &#x3D; res0(1) ;</p>
<p><code>parm = res0(-1)</code> for TM polarization; 对于 TM 极化，parm &#x3D; res0(- 1) ;</p>
<p>% res0.m is a function that set default values to all parameters used by the code and determine the polarisation. res0.m是一个函数，它为代码使用的所有参数设置默认值，并确定极化。</p>
<p><code>k_parallel</code> &#x3D;$\boldsymbol{k_x^{inc}}$(𝟐𝝅&#x2F;𝝀) is the normalised parallel momentum of the incident plane wave. 入射平面波的归一化平行动量. </p>
<p>If the grating is illuminated from the top region (or from the bottom region) under an incident angle θ, one has: 如果光栅在入射角为θ的情况下从顶部区域（或底部区域）照射，则有：</p>
<p><code>k_parallel=n_inc\*sin(θ)</code></p>
<p><code>K _ parallel = n _ inc \* sin (θ) </code></p>
<p>where n_inc is the refractive index of the top (or bottom) layer. One expects that it is a positive real number and that the texture (see Section 4.1) associated to the top (or the bottom) layer has a background with a uniform refractive index “n_inc”.</p>
<p>其中，n_inc是顶部（或底部）层的折射率。人们期望它是一个正实数，并且与顶部（或底部）层相关联的纹理（见第4.1节）具有具有均匀折射率“n_inc”的背景。 </p>
<p>(Note that the “k_parallel” variable is defined <strong>without</strong> the factor 𝟐𝝅&#x2F;𝝀.)  </p>
<p>（请注意，“k_parallel”变量的定义没有因子2π&#x2F;λ。）</p>
<p> It is very important to keep in mind that wether one defines the incident plane wave in the top layer or in the bottom layer, the calculation will be done for both an incident wave from the top and an incident wave from the bottom, with an identical parallel momentum k_parallel. </p>
<p>需要牢记的是，不管是在顶部层还是底部层中定义入射平面波，计算都将针对从顶部入射的波和从底部入射的波进行，并具有相同的平行动量k_parallel。</p>
<p>These 5 parameters (“wavelength, nn, parm and k_parallel) are required by the code. Some other parameters can additionally be defined. For example, the default parameters do not take the symmetry of the problem into account. So if one wants to use symmetries, a new parameter has to be defined: “parm.sym.x”, (see section 7). If one wants to calculate accurately the electromagnetics fields, one has to define: ” parm.res1.champ&#x3D;1”, but this increases the calculation time and memory loads (see section 8)</p>
<p>这5个参数（“波长、nn、parm和k_parallel)”是代码所需的。还可以定义其他一些参数。例如，缺省参数没有考虑问题的对称性。因此，如果想要使用对称性，需要定义一个新的参数：“parm.sym.x”（参见第7节）。如果想要精确计算电磁场，则必须定义：“parm.res1.champ&#x3D;1”，但这将增加计算时间和内存负载（请参见第8节）。</p>
<h2 id="Structure-definition-grating-parameters"><a href="#Structure-definition-grating-parameters" class="headerlink" title="Structure definition (grating parameters)"></a>Structure definition (grating parameters)</h2><p>结构定义（光栅参数）</p>
<p>The grating encompasses a uniform upperstrate, called the top in the following, a uniform substrate, called the bottom in the following, and many layers which define the grating, which is defined by a stack of layers. Every layer is defined by a “texture” and by its thickness. Two different layers may be identical (identical texture and thickness), may have different thicknesses with identical texture, may have different thicknesses and textures. To define the diffraction geometry, we need to define the different textures and then the different layers.</p>
<p>光栅包括一个统一的上层基板，以下称为顶部，在以下称为底部的统一基板上，以及定义光栅的许多层，它由一组层定义。每层由一个“纹理”和它的厚度来定义。两个不同的层可以相同（相同的纹理和厚度），可以具有不同厚度相同的纹理，也可以具有不同厚度和纹理。为了定义衍射几何，我们需要定义不同的纹理，然后是不同的层。</p>
<h3 id="How-to-define-a-texture"><a href="#How-to-define-a-texture" class="headerlink" title="How to define a texture?"></a>How to define a texture?</h3><p>如何定义纹理？</p>
<p> Every texture is defined by a cell-array composed of two line-vectors of identical length. The first vector, let us say [x1 x2 … xp …xN], contains all the x-values of the discontinuities. One <em>must</em> have :</p>
<p>每个纹理都由一个包含两个相同长度的行向量的单元数组定义。第一个向量，我们称之为 [x1 x2 … xp …xN]，包含所有不连续点的x值。必须满足以下条件：</p>
<ol>
<li>N&gt;1</li>
<li>$x_p&lt;x_{p+1}$ for any p</li>
<li>$x_N-x_1\leq\text{period}$.</li>
</ol>
<p>The second line-vector [n1 n2 … np … nN] contains the refractive indices of the material between the discontinuities. More explicitly, we have a refractive index np for xp-1&lt;x&lt;xp. Because of periodicity, note that the refractive index for xN&lt;x&lt;x1+period is equal to n1.</p>
<p>第二条线向量[ n1 n2… np… nN ]包含介于不连续面之间的材料的折射率。更明确地说，我们对 xp-1 &lt; x &lt; xp 有折射率 np。由于周期性，请注意 xN &lt; x &lt; x1 + 周期的折射率等于 n1。</p>
<p>The specific case of a uniform texture with a refractive index n is easily defined by texture{1}&#x3D;{n}. In that specific case, no need of a second vector since there is no discontinuity.</p>
<p>具有折射率 n 的均匀织构的特殊情况很容易由织构{1} &#x3D; { n }来定义。在这种情况下，不需要第二个矢量，因为没有不连续性。</p>
<p> The textures have all to be to be packed together in a cell array textures&#x3D;{textures{1}, textures{2}, textures{3}} prior calling subroutine <strong>res1.m.</strong></p>
<p>这些纹理必须在调用子例程 res1.m 之前被打包在一个单元格阵列纹理 &#x3D; {纹理{1} ，纹理{2} ，纹理{3}中。</p>
<p> Example : 例子:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">period=<span class="number">17</span>; # 周期 = <span class="number">17</span>; </span><br><span class="line">textures =cell(<span class="number">1</span>,<span class="number">2</span>); # 纹理 = 单元格(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line">textures&#123;<span class="number">1</span>&#125;=&#123;<span class="number">1.5</span>&#125;; <span class="comment">%uniform texture # 纹理&#123;1&#125; = &#123;1.5&#125; ;% 均匀纹理</span></span><br><span class="line">textures&#123;<span class="number">2</span>&#125;=&#123;[<span class="number">-5</span>,<span class="number">-3</span>,<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">1.3</span>,<span class="number">1.5</span>,<span class="number">3</span>]&#125;; <span class="comment">%texture composed of 4 different refractive indices ％由四个不同折射率组成的纹理</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>The following figure shows the refractive indices of the two textures.以下图显示了这两个纹理的折射率。</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403163538201.png" srcset="/img/loading.gif" lazyload alt="image-20230403163538201" style="zoom: 50%;" />

<p>Fig. 2. Textures{1} and {2}.  图2. 纹理{1}和{2}。</p>
<p><code>Slits in perfectly-conducting metallic textures</code>: 完美导体金属纹理中的缝隙: </p>
<p>Mixing perfectly-conducting metallic textures and dielectric textures in the same grating structure is possible. We have first to define a background by its refractive index “inf” (for infinity). In this uniform background, we can incorporate strip inclusions with a complex or real refractive index “ninclusion” defined by the position c of its center and its x-width L. The inclusions cannot overlap.</p>
<p>在同一光栅结构中混合完美导体金属纹理和介质纹理是可能的。首先，我们需要通过其折射率“inf”（表示无穷大）来定义一个背景。在这个统一的背景中，我们可以插入带有复杂或实折射率“ninclusion”的条形包含物，该包含物由其中心位置c和x宽度L来定义。这些包含物不能重叠。</p>
<p>For example: 例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textures &#123;3&#125;= &#123;inf, [c1,L1,ninclusion1],[c2,L2, ninclusion2]&#125;</span><br><span class="line"># 纹理&#123;3&#125; = &#123; inf，[ c1，L1，ninclusion 1] ，[ c2，L2，ninclusion 2]</span><br></pre></td></tr></table></figure>



<p><code>Anisotropic layers:</code> 各向异性层:</p>
<p>Grating layers (not the substrate nor the superstrate) can be anisotropic with diagonal tensors (𝜀𝑥𝑦 &#x3D; 𝜀𝑥𝑧 … &#x3D; 0). 光栅层(不是衬底也不是上层)可以是各向异性的对角张量(εxy &#x3D; εxz… &#x3D; 0)。</p>
<p>To implement diagonal anisotropy 实现对角各向异性</p>
<p>parm.res1.change_index&#x3D;${\left[n_{\text{prov}}^1,n_{x}^1,n_{y}^1,n_{z}^1\right],\left[n_{\text{prov}}^2,n_{x}^2,n_{y}^2,n_{z}^2\right]}$; % $\mathbf{n}<em>{\text{prov}}^1\neq\mathbf{n}</em>{\text{prov}}^2$</p>
<p>The refractive index nprov1 is then replaced <strong>in all textures</strong> by epsilon&#x3D;diag([(n 1)2, (n 1 )2, (nz1 )2]). Beware if the superstate (or substrate) has a refractive index nprov1, it will also be replaced and this is not allowed. Thus we recommend using an unusual value for nprov1 (e.g. 89.99999 or rand(1)).</p>
<p>然后，折射率 nprov1在所有纹理中被 epsilon &#x3D; diag ([(n1)2，(n1)2，(nz1)2])取代。当心，如果超态(或衬底)具有折射率 nprov1，它也将被替换，这是不允许的。因此，我们建议使用 nprov1的不寻常值(例如89.99999或兰特(1))。</p>
<p>The user may also diagonal permeability tensors 用户也可以使用对角渗透张量</p>
<p>parm.res1.change_index&#x3D;</p>
<p> ${<del>\left{\left[n_{\text{prov}}^1,</del>n_x^1,n_y^1,n_z^1,m_x^1,m_y^1,m_z^1\right],\left[n_{\text{prov}}^2,~n_x^2,n_y^2,n_z^2\right]\right}$;</p>
<p>​    </p>
<p>Parm.res1.change _ index &#x3D; {[ nprov1，n1，n1，nz1，m1，m1] ，[ nprov2，n2，n2，nz2] ;</p>
<p>The     refractive     index     nprov1  is   then   replaced   <strong>in   all   textures</strong>   by $\text{epsilon&#x3D;diag}([(n_x^1)^2,(n_y^1)^2,(n_z^1)^2]),\text{mu&#x3D;diag}([(m_x^1)^2,(m_y^1)^2,(m_z^1)^2]).$</p>
<p>在所有结构中，折射率 nprov1由 ε &#x3D; diag ([(n1)2，(n1)2，(n1)2]) ，mu &#x3D; diag ([(m1)2，(m1)2，(m1)2])取代。</p>
<p>For slits in perfectly-conducting metallic textures, anisotropy cannot be implemented. 对于完全导电金属织构中的缝隙，各向异性是不能实现的。</p>
<p> In order to check if the set of textures is correctly set up, the user can set the variable parm.res1.trace equal to 1: “parm.res1.trace &#x3D; 1;”. </p>
<p>Then a Matlab figure will show up the refractive-index distribution of all textures. Each</p>
<p>texture is represented with the coordinate x varying from –period&#x2F;2 to period&#x2F;2</p>
<p> 为了检查纹理集是否正确设置，用户可以将变量parm.res1.trace设置为1：“parm.res1.trace &#x3D; 1;”。然后，一个Matlab图将显示出所有纹理的折射率分布。每个纹理都用坐标x表示，其变化范围为-period&#x2F;2到period&#x2F;2。</p>
<h3 id="How-to-define-the-layers-如何定义图层？"><a href="#How-to-define-the-layers-如何定义图层？" class="headerlink" title="How to define the layers? 如何定义图层？"></a>How to define the layers? 如何定义图层？</h3><p>This is performed by defining the “Profile” variable which contains, starting from the top layer and finishing by the bottom layer, the successive information (thickness and texture-label) relative to every layer. Here is an example that illustrates how to set up the “Profile” variable:</p>
<p>这是通过定义“Profile”变量来实习的，该变量从顶部层开始，以底部层结束，相对于每个层，顺序包含连续的信息（厚度和纹理标签）。以下是一个示例，演示如何设置“Profile”变量：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile = &#123;[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]&#125;; </span><br></pre></td></tr></table></figure>

<p>It means that from the top to the bottom we have: the top layer is formed by a thickness 0 of texture 1, then we have twice textures 3, 2 and 4 with depth 1, 0.5 and 0.5 respectively, texture 6 with depth 2, and finally the bottom layer (formed by texture 2) with null thickness. Since textures 1 and 2 correspond to the top and bottom layers, they must be uniform. In this example, the top and bottom layers have a null thickness. However, one may set an arbitrary thickness. Especially, if one needs to plot the electromagnetic fields in the bottom and top layers, the thicknesses hb and hh (see Fig. 4) over which the fields have to be visualized has to be specified. For hb&#x3D;hh&#x3D;0, the Rayleigh expansions of the fields in the top and bottom layers are not plotted.  </p>
<p>这意味着从顶部到底部，我们有：顶部层由纹理1的厚度为0组成，然后我们有两次深度分别为1、0.5和0.5的纹理3、2和4，深度为2的纹理6，最后是由纹理2形成的底部层，厚度为零。由于纹理1和2对应于顶部和底部层，它们必须是均匀的。在这个例子中，顶部和底部层的厚度都为零。然而，可以设置任意厚度。特别地，如果需要绘制底部和顶部层中的电磁场，则必须指定要可视化场的厚度hb和hh（见图4）。对于hb&#x3D;hh&#x3D;0，不绘制顶部和底部层中场的Rayleigh展开。</p>
<p>In this particular Profile, the structure formed by texture 3 with thickness 1, texture 2 with thickness 0.5 and texture 4 with thickness 0.5 is repeated twice. It is possible to simplify the instruction defining the “Profile” variable in order to take into account the repetitions:  </p>
<p>在这个特定的“Profile”中，由纹理3（厚度为1）、纹理2（厚度为0.5）和纹理4（厚度为0.5）形成的结构重复了两次。可以简化定义“Profile”变量的指令，因为计算会考虑到重复性：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;[<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0.5</span>], [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], <span class="number">2</span>&#125;,&#123;[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">2</span>]&#125;&#125;;  </span><br></pre></td></tr></table></figure>

<p> If a structure is repeated many times, the above “factorized” instruction of Eq. 2 is better than the “expanded” one of Eq. 1, in terms off computational speed, because the calculation will take into account the repetitions.</p>
<p>The profile is shown below.  如果一个结构需要多次重复，那么上述式子2的“因式分解”指令比式子1的“展开”指令在计算速度上更好，因为计算将考虑到这些重复。</p>
<p> The profile is shown below. 以下是一个示例变量“Profile”的具体情况。</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403164752176.png" srcset="/img/loading.gif" lazyload alt="image-20230403164752176" style="zoom:50%;" />

<p> Fig. 3. Texture stacks. The example corresponds to a profile defined by Profile &#x3D;  {[hh,1,0.5,0.5,1,0.5,0.5,2, hb],[1,3,2,4,3,2,4,6,2]}; . The top and bottom layers have uniform textures.  </p>
<p>图3. 纹理堆栈。该示例对应于一个由Profile &#x3D; {[hh,1,0.5,0.5,1,0.5,0.5,2, hb],[1,3,2,4,3,2,4,6,2]}定义的配置文件。顶部和底部层具有均匀的纹理。</p>
<h3 id="Solving-the-eigenmode-problem-for-every-texture"><a href="#Solving-the-eigenmode-problem-for-every-texture" class="headerlink" title="Solving the eigenmode problem for every texture"></a>Solving the eigenmode problem for every texture</h3><p>求解每个纹理的特征模态问题</p>
<p>The first computation with the RCWA consists in calculating the eigenmodes associated to all textures. This is done by the subroutine “res1.m”, following the instruction:</p>
<p>RCWA 的第一个计算包括计算与所有纹理相关的特征模式。这是由子程序“ res1.m”按照指令完成的:</p>
<h3 id="res1程序"><a href="#res1程序" class="headerlink" title="res1程序"></a>res1程序</h3><p><code>计算纹理</code></p>
<p> aa &#x3D; res1(wavelength,period,textures,nn,k_parallel,parm);  </p>
<p>This subroutine has 6 input arguments: the wavelength “<strong>wavelength</strong>”, the period of the grating “<strong>period</strong>”, the “<strong>textures</strong>” variable, the number of Fourier harmonics “<strong>nn</strong>”, the normalized parallel incident wave vector “<strong>k_parallel</strong>, and the “<strong>parm</strong>” variable containing the values of all parameters used by the code and the selected the polarisation. If one has to study the diffraction by different gratings composed of the same textures, one needs to compute only once the eigenmodes. It is possible to save the “aa” variable in a “.mat” file and to reload it for the computation of the diffracted waves, see an example in Annex 10.3.</p>
<p>这个子程序有6个输入参数：</p>
<ol>
<li>波长“wavelength”，</li>
<li>光栅周期“period”，</li>
<li>“textures”变量，</li>
<li>傅里叶谐波的数量“nn”，</li>
<li>归一化的平行入射波矢“k_parallel”，</li>
<li>以及包含代码使用的所有参数值和所选偏振的“parm”变量。</li>
</ol>
<p>如果需要研究由同一纹理组成的不同光栅的衍射，则只需计算一次特征模式。可以将“aa”变量保存在一个“.mat”文件中，并重新加载以计算衍射波，见附录10.3中的示例。</p>
<h2 id="Computing-the-diffracted-waves"><a href="#Computing-the-diffracted-waves" class="headerlink" title="Computing the diffracted waves"></a>Computing the diffracted waves</h2><h3 id="res2程序"><a href="#res2程序" class="headerlink" title="res2程序"></a>res2程序</h3><p><code>计算衍射波</code> </p>
<p>This is the second step of the computation. This is done by the subroutine “res2.m”, following the instruction:</p>
<p>这是计算的第二步。这是通过子程序“res2.m”完成的，按照以下指示进行：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = res2(aa, Profile);</span><br></pre></td></tr></table></figure>

<p>This subroutine has 2 input arguments: the output “<strong>aa</strong>” of the subroutine “res1.m” and the “<strong>Profile</strong>” variable. The output argument “<strong>result</strong>” contains all the information on the diffracted fields. “<strong>result</strong>” is an object of class ‘reticolo’ that can be indexed as an usual structure with parentheses, or with the labels of the considered orders between curly braces. Examples will be given in the following.</p>
<p>这个子程序有两个<code>输入</code>参数：</p>
<ol>
<li>子程序“res1.m”的输出“aa”</li>
<li>“Profile”变量。</li>
</ol>
<p>输出参数“result”包含所有关于衍射场的信息。“result”是一个‘reticolo’类的对象，可以像普通结构体一样用括号进行索引，或使用大括号中的考虑阶级别的标签进行索引。示例将在接下来给出。</p>
<p>This information is divided into the following sub-structures fields :</p>
<p>这些信息分为以下子程序结构<code>输出</code>6个字段:</p>
<p>从<code>上方</code>入射</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- “result. inc_top”</span><br><span class="line">- “result. inc_top_reflected”</span><br><span class="line">- “result. inc_top_transmitted”</span><br></pre></td></tr></table></figure>

<p>从<code>下方</code>入射</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- “result. inc_bottom”</span><br><span class="line">- “result.inc_bottom_reflected”</span><br><span class="line">- “result. inc_bottom_transmitted”</span><br></pre></td></tr></table></figure>



<p>The sub-structure “<strong>result.inc_top_reflected</strong>” contains all the information concerning the propagative <em>reflected</em> waves <em>for an incident wave from the top layer</em> of the grating. The incident wave is described in the sub-structure “<strong>result.inc_top”</strong>.</p>
<p>子结构“result.inc_top_reflected”包含有关来自光栅顶层的入射波的传播反射波的所有信息。 入射波在子结构“result.inc_top”中描述。</p>
<img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403165245428.png" srcset="/img/loading.gif" lazyload alt="image-20230403165245428" style="zoom:50%;" />

<p>Fig. 4. The two obtained solutions.   图4. 获得的两个解决方案。</p>
<p>Each sub-structure of result is composed of the several fields. Each field is a Matlab column vector or matrix having the same number N of lines. N is the number of propagative orders considered and can be 0.  </p>
<p>result的每个子结构由多个字段组成。每个字段都是一个Matlab列向量或矩阵，具有相同的行数N。 N是考虑的传播阶数，可以为0。</p>
<table>
<thead>
<tr>
<th>Field name   字段名</th>
<th>Signification   意义</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>order  阶数</td>
<td>orders of the diffracted  propagative plane waves   衍射传播平面波的阶</td>
<td>N, 1</td>
</tr>
<tr>
<td>theta   Θ</td>
<td>angle $\theta$m of each diffracted order   每个衍射阶数的角 m</td>
<td>N, 1</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>normalised wave vector   归一化波矢</td>
<td>N, 3</td>
</tr>
<tr>
<td>efficiency效率</td>
<td>efficiency of each diffracted  order   每个衍射级数的效率</td>
<td>N, 1</td>
</tr>
<tr>
<td>amplitude   振幅</td>
<td>complexe amplitude in TE  polarization of every order   各阶 TE 极化中的复振幅</td>
<td>N, 1</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>electric field (Ex, Ey, Ez) of the diffracted orders  at O_top or O_bottom when the amplitude of the incident plane wave is one.   当入射平面波的振幅为1时，在 O _ 顶或 O _ 底的衍射级数的电场(Ex，Ey，Ez)</td>
<td>N, 3</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>magnetic field (Hx, Hy, Hz) of the diffracted orders  at O_top or O_bottom when the amplitude of the incident plane wave is one.   当入射平面波振幅为1时，在 o _ 顶或 o _ 底的衍射级磁场(Hx，Hy，Hz)。</td>
<td>N, 3</td>
</tr>
<tr>
<td>PlaneWave_E</td>
<td>E-vector  components of the $\overrightarrow{\text{PW}}$ ’s (in the Oxyz basis) <br /> PW 的 e 向量分量(在 Oxyz 基础上)</td>
<td>N, 3</td>
</tr>
<tr>
<td>PlaneWave_H</td>
<td>H-vector  components of the $\overrightarrow{\text{PW}}$ ’s (in the Oxyz basis)  <br />PW 的 h 向量分量(在 Oxyz 基础上)</td>
<td>N, 3</td>
</tr>
</tbody></table>
<p> (To use the same notations as in the conical code or in the crossed-grating code, set parm.res1.result&#x3D;-1 before calling res1.m).</p>
<p>(要使用与锥形代码或交叉光栅代码相同的符号，在调用 res1.m 之前设置 parm.res1.result &#x3D;-1)。</p>
<h3 id="Efficiencies-效率"><a href="#Efficiencies-效率" class="headerlink" title="Efficiencies 效率"></a>Efficiencies 效率</h3><p>For a given diffraction order n, the diffraction efficiency is defined as the ratio between the flux of the diffracted Poynting vector and the flux of the incident Poynting vector (flux through a period of the grating).</p>
<p>对于给定的衍射阶数n，衍射效率定义为衍射Poynting矢量通量和入射Poynting矢量通量（通过光栅一个周期的通量）之比。</p>
<p> The efficiencies of all propagative reflected and transmitted waves for an incident wave from the top of the grating are given by the two vectors “<strong>result.inc_top_reflected.efficiency</strong>” and “<strong>result.inc_top_transmitted.efficiency</strong>”. If all refractive indices are real, the sum of all elements of these two vectors is equal to one because of the energy conservation. The labels n of the corresponding orders are in “<strong>result.inc_top_reflected.order</strong>” (see below for a description of the other fields of this sub_structure).</p>
<p>对于来自光栅顶部的入射波的所有传播反射和透射波的效率分别由两个向量“result.inc_top_reflected.efficiency”和“result.inc_top_transmitted.efficiency”给出。 如果所有折射率都是实数，则这两个向量的所有元素之和等于1，因为能量守恒。 相应阶级别的标签n在“result.inc_top_reflected.order”中（有关此子结构的其他字段的描述，请参见下文）</p>
<p> <code>Some examples</code> 一些例子</p>
<ol>
<li>The efficiency of the reflected order -2 ($\quad\text{k}_{&#x2F;&#x2F;}\text{&#x3D;}\frac{\text{inc}}{\text{x}}-2\text{K}<em>X\quad$) when the grating is illuminated from the top is equal to result. inc_top_reflected.efficency{-2}. If this order is evanescent, the efficiency is 0.当光栅从顶部照射时，反射级$\quad\text{k}</em>{&#x2F;&#x2F;}\text{&#x3D;}\frac{\text{inc}}{\text{x}}-2\text{K}_X\quad$的效率等于结果。表面反射。效率{-2}。如果这个顺序是消失的，那么效率是0。</li>
</ol>
<p>It is important to have in mind the difference between : </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.inc_top_reflected.efficiency&#123;<span class="number">-2</span>&#125; : efficiency of order <span class="number">2</span></span><br><span class="line">result.inc_top_reflected.efficiency(<span class="number">-2</span>) : gives an error !</span><br><span class="line">result.inc_top_reflected.efficiency&#123;<span class="number">2</span>&#125; : efficiency of order <span class="number">2</span></span><br><span class="line">result.inc_top_reflected.efficiency(<span class="number">2</span>) : efficiency in order result. inc_top_reflected.order(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<ol>
<li>The orders of all the transmitted-propagative plane waves for an incident wave from the top of the grating are given by the vector “<strong>result.inc_top_transmitted.order</strong>”.</li>
</ol>
<p>来自光栅顶部的入射波的所有传播透射平面波的级别可以在向量“result.inc_top_transmitted.order”中找到。</p>
<ol>
<li>The efficiencies of all propagative reflected waves for an incident wave from the bottom in TM polarization are given by the vector “<strong>result.inc_bottom_reflected.efficiency</strong>”.</li>
</ol>
<p>对于在TM偏振下从底部入射的入射波，所有传播反射波的效率由向量“result.inc_bottom_ reflected.efficiency”给出。</p>
<h3 id="Rayleigh-expansion-for-propagatives-modes"><a href="#Rayleigh-expansion-for-propagatives-modes" class="headerlink" title="Rayleigh expansion for propagatives modes"></a>Rayleigh expansion for propagatives modes</h3><p>传播模式的瑞利展开</p>
<p>The coefficients of the Rayleigh expansion of Fig. 1 can be obtained from the structure <strong>result</strong>. For instance, when the grating is illuminated from the bottom with a TE polarised mode, we have :</p>
<p>图1的瑞利展开系数可由结构计算结果得到。例如，当光栅从底部用 TE 偏振模式照明时，我们有:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Ebottom =result.inc_bottom_reflected.E&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Hbottom =result inc_bottom_reflected.H&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Etop =result.inc_bottom_transmitted.E&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br><span class="line">m</span><br><span class="line">Htop =result.inc_bottom_ transmitted.H&#123;m&#125; (<span class="number">3</span> components in Oxyz)</span><br></pre></td></tr></table></figure>

<p>and the incident plane wave defined in page 4 is given by :</p>
<p>第4页中定义的入射平面波由以下人员给出:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ebottom =result inc_bottom.E (<span class="number">3</span> components in Oxyz)</span><br><span class="line">inc</span><br><span class="line">Hbottom =result.inc_bottom.H (<span class="number">3</span> components in Oxyz).</span><br></pre></td></tr></table></figure>

<h3 id="Amplitude-of-diffracted-propagative-waves"><a href="#Amplitude-of-diffracted-propagative-waves" class="headerlink" title="Amplitude of diffracted propagative waves"></a>Amplitude of diffracted propagative waves</h3><p>衍射传播波的振幅</p>
<h4 id="入射角度-Angle-theta-m"><a href="#入射角度-Angle-theta-m" class="headerlink" title="入射角度 Angle $\theta_m$"></a>入射角度 Angle $\theta_m$</h4><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403170721968.png" srcset="/img/loading.gif" lazyload alt="image-20230403170721968" style="zoom:50%;" />



<p>Fig. 5 qm angles. 图5m 角。</p>
<p>The angle qm related to order m is varying between –90 and 90. It is oriented in such a way that the k-parallel momentum of the corresponding wave vector (incident or diffracted) is</p>
<p>与阶数m相关的角度θm在-90度至90度之间变化。它的方向安排是这样的，使得相应波矢（入射或衍射）的k-parallel动量为：</p>
<p>$\text{k_x}^{\text{inc}}+\text{mk_x}&#x3D;(2\pi&#x2F;\lambda)\text{n_top}\sin(\Theta_\text{m})\text or (2\pi&#x2F;\lambda)\text{n_bottom_}\sin(\Theta_\text{m})$ 有点错误</p>
<p>$$</p>
<p>&#x3D; (2π&#x2F;λ) n_top sin(qm) or (2π&#x2F;λ) n_bottom_sin(qm).</p>
<h3 id="O-top-and-O-bottom-points-最高点和最低点"><a href="#O-top-and-O-bottom-points-最高点和最低点" class="headerlink" title="$O_{top}$ and $O_{bottom}$ points 最高点和最低点"></a>$O_{top}$ and $O_{bottom}$ points 最高点和最低点</h3><p>Otop and Obottom are 2 important points (see Fig. 1). In the Cartesian coordinates system Oxyz , they are defined by: Otop&#x3D;(0,0,h) at the top of the grating, and Obottom&#x3D;(0,0,0) at the bottom of the grating.</p>
<p>Otop和Obottom是两个重要点（见图1）。 在笛卡尔坐标系Oxyz中，它们分别定义为：</p>
<p>Otop &#x3D;（0,0，h）在光栅顶部， Obottom &#x3D;（0,0,0）在光栅底部。</p>
<p>In addition, let us consider an arbitrary point M&#x3D;(x,y,z) in the 3D space in Oxyz. Associated to this point, we define the two vectors :</p>
<p>另外，让我们考虑Oxyz中三维空间中的任意点M &#x3D;（x，y，z）。 与此点相关联，我们定义两个向量：</p>
<p>$\quad\mathbf{r}<em>{\text{top}&#x3D;}\overline{\mathrm{O}</em>{\text{top}}{\text{M}}}$, and</p>
<p>$\quad\mathbf{r}<em>{\text{bottom}&#x3D;}\overline{\mathrm{O}</em>{\text{bottom}}{\text{M}}}$.</p>
<h3 id="Jones’-coefficient-琼斯系数"><a href="#Jones’-coefficient-琼斯系数" class="headerlink" title="Jones’ coefficient 琼斯系数"></a>Jones’ coefficient 琼斯系数</h3><p>Let us assume that the grating is illuminated from the top layer and let us consider a diffracted order m in the bottom layer. Any other diffraction situation is straighforwardly deduced.</p>
<p>让我们假设光栅是从顶层照明，让我们考虑一个衍射阶数 m 在底层。任何其他衍射情况都是直接推导出来的。</p>
<p>Let α be a given complex number. The incident electromagnetic field (6 components of <strong>E</strong> and <strong>H</strong> in every points of the 3D space) can be written :</p>
<p>设 α 是给定的复数。入射电磁场(三维空间中每个点上的 e 和 h 的6个分量)可以写成:</p>
<p>$\mathbf{W}^{\text{inc}}&#x3D;\alpha\overrightarrow{\mathbf{PW}}$</p>
<p>where PW is a plane wave defined in every point by PW&#x3D;A exp(ikinc top rtop), A being the electromagnetic fields (6 components) of the plane wave at M&#x3D;Otop, and kinc top is the incident wave vector. A and K&#x3D;kinc top &#x2F; kinc top are given by the structure “result“ as will be defined later.</p>
<p>Similarly, the diffracted electromagnetic field in the m bottom order can be written :</p>
<p>其中，PW是由PW &#x3D; A exp（ikinc top rtop）在每个点定义的平面波，其中A是平面波在M &#x3D; Otop处的电磁场（6个分量），而kinc top是入射波矢量。向量A和K &#x3D; kinc top &#x2F; kinc top由结构“result”给出，稍后将进行定义。</p>
<p>同样地，m级别的衍射电磁场可以写成：</p>
<p>$\mathbf{W}_\mathrm{m}^{\mathrm{dif}}&#x3D;\gamma\overline{\mathbf{PW^m}}$</p>
<p>where $\gamma$ is a complex number, PWm is a plane wave defined in every point by PWm&#x3D;Am exp (ikm bottom rbottom ), Am is the electromagnetic fields (6 components) of the plane wave at M&#x3D;Obottom, and km bottom is the wave vector of the mth transmitted order. Am and, Km&#x3D;kmbottom &#x2F; kmbottom are given by the structure “result“ as will be defined later.</p>
<p>We define the Jones’coefficient J, associated to the order m by</p>
<p>其中，γ是一个复数，PWm是由PWm &#x3D; Am exp（ikm bottom rbottom）在每个点定义的平面波，其中Am是平面波在M &#x3D; Obottom处的电磁场（6个分量），而km bottom是第m个透射级别的波矢量。向量Am和Km &#x3D; kmbottom &#x2F; kmbottom由结构“result”给出，稍后将进行定义。</p>
<p>我们通过定义与阶数m相关联的Jones系数J来完成：</p>
<p>待添加</p>
<p>​                 </p>
<h2 id="Using-symmetries-to-accelerate-the-computational-speed"><a href="#Using-symmetries-to-accelerate-the-computational-speed" class="headerlink" title="Using symmetries to accelerate the computational speed"></a>Using symmetries to accelerate the computational speed</h2><p><code>使用对称性来加快计算速度</code></p>
<p>When the grating possesses some mirror symmetry for the plane x&#x3D;x0, one may define “parm.sym.x&#x3D; x0. Then</p>
<p>when k_parallel &#x3D;0, the code will use the symmetry property for speeding up the calculation.</p>
<p>当光栅在x &#x3D; x0平面处具有某些镜像对称性时，可以定义“parm.sym.x &#x3D; x0”。然后，当k_parallel &#x3D; 0时，代码将使用对称性属性加快计算速度。</p>
<p>Note that the code does not verify if the symmetries of the grating defined by the user are in agreement with the “textures” parameters. It is up to the user to define carefully the parameters parm.sym.x. All textures used in the calculation must possess the same symmetry.</p>
<p>请注意，代码不验证用户定义的光栅的对称性是否与“textures”参数一致。用户必须仔细定义参数parm.sym.x。计算中使用的所有纹理必须具有相同的对称性。</p>
<h2 id="Plotting-the-electromagnetic-field-and-calculating-the-absorption-loss"><a href="#Plotting-the-electromagnetic-field-and-calculating-the-absorption-loss" class="headerlink" title="Plotting the electromagnetic field and calculating the absorption loss"></a>Plotting the electromagnetic field and calculating the absorption loss</h2><h3 id="res3程序"><a href="#res3程序" class="headerlink" title="res3程序"></a>res3程序</h3><p><code>绘制电磁场并计算吸收损耗</code></p>
<p>Computation of the electromagnetic fields 计算电磁场</p>
<p>Once the eigenmodes associated to all textures are known, the calculation of the electromagnetic fields everywhere in the grating can be performed. This calculation is done by the function “<strong>res3.m</strong>”, following the instruction:</p>
<p>一旦知道了所有纹理的本征模式，就可以计算光栅中各处的电磁场。这个计算是由函数“ res3.m”按照指令完成的:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[e,z,index] = res3(x,aa,Profile, inc,parm);</span><br></pre></td></tr></table></figure>

<p>The function“res3.m” can be called without calling “res2.m”. This subroutine has 5 input arguments:<br>-the “x” variable is a vector containing the locations where the fields will be calculated in the x-direction [for<br>instance we may set x &#x3D; linspace(-period_x&#x2F;2, period_x&#x2F;2, 51); for allocating 51 sampling points in the xdirection],<br>the “aa” variable contains all the information on the eigenmodes of all textures and is computed by the subroutine<br>res1.m,<br>-the variable “Profile” is defined in Section 4.2; note that it can be redefined,<br>-the variable “inc” defines the y component of the complex amplitude of the incident electric (in TE polarisation)<br>or magnetic field (in TM polarisation) field at O_top or O_bottom .<br>For illuminating the grating exactly by the TE-polarized incident PW defined above, one should set:<br>einc&#x3D; result.inc_top PlaneWave_E(2) for TE polarisation; einc&#x3D; result.inc_top PlaneWave_H(2) for TM<br>polarisation.<br>-the “parm” variable, already mentioned is discussed in the following.<br>There are three possible output arguments for the subroutine “res3.m”. The variable “e” contains all the<br>electromagnetic field quantities:  </p>
<p>函数“res3.m”可以在不调用“res2.m”的情况下调用。该子程序具有<code>5个输入</code>参数： </p>
<ol>
<li><p>“x”变量是一个向量，其中包含在x方向上计算场的位置[例如，我们可以将x &#x3D; linspace（- period_x &#x2F; 2，period_x &#x2F; 2，51）;分配51个采样点以在x方向进行采样]，</p>
</li>
<li><p>“aa”变量包含所有纹理的特征模式信息，并由子程序res1.m计算</p>
</li>
<li><p>变量“Profile”在第4.2节中定义。请注意，它可以重新定义</p>
</li>
<li><p>变量“inc”定义入射电场的复振幅的y分量（在TE偏振中）或磁场（在TM偏振中）在O_top或O_bottom处。 为了精确地用上述TE偏振入射PW照明光栅，应设置： 对于TE偏振，einc &#x3D; result.inc_top PlaneWave_E（2）;对于TM偏振，einc &#x3D; result.inc_top PlaneWave_H（2）。 </p>
</li>
<li><p>“parm”变量是已经提到的，在下面进行了讨论。</p>
</li>
</ol>
<p>子程序“res3.m”有<code>三个</code>输出变量。</p>
<ul>
<li>“e”变量包含所有电磁场量：</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ey=e(:,:,<span class="number">1</span>); Hx=e(:,:,<span class="number">2</span>); Hz=e(:,:,<span class="number">3</span>); in TE polarization.</span><br><span class="line">Hy=e(:,:,<span class="number">1</span>); Ex=e(:,:,<span class="number">2</span>); Ez=e(:,:,<span class="number">3</span>); in TM polarization.</span><br></pre></td></tr></table></figure>

<p>The second variable “z” is the vector containing the z-coordinate of the sampling points. Note that in the matrix Ex&#x3D;e(:,:,1), the first index refer to the z coordinate, and the second to the x-coordinate. Thus Ex(i,j) is the Ex field component at the location {z(i), x(j)}. The third variable “index” is the complex refractive index of the considered grating. index(i,j) is the refractive index at the location {z(i), x(j)}. It can be useful to test the profile of the grating.</p>
<ul>
<li>第二个变量“z”是包含采样点z坐标的向量。请注意，在矩阵Ex &#x3D; e（：，：，1）中，第一个索引是z坐标，第二个是x坐标。 因此，Ex（i，j）是位于{z（i），x（j）}位置处的Ex场分量。第三个变量“index”是所考虑光栅的复折射率。 index（i，j）是在{z（i），x（j）}位置处的折射率。它可以用于测试光栅的轮廓。</li>
</ul>
<p>Some <strong>important</strong> comments on the <strong>parm</strong>” variable : 关于“parm”变量的一些重要注释：</p>
<ol>
<li>For calculating precisely the electromagnetics fields, one has to set : ”<strong>parm.res1.champ&#x3D;1”</strong> before calling <strong>res1.m.</strong> This increases the calculation time and memory load, but it is highly recommended. If not, the computation of the field will be correct only in homogenous textures (for example in the top layer and in the bottom layer). 1.为了精确计算电磁场，必须在调用res1.m之前设置：“parm.res1.champ&#x3D;1”。这会增加计算时间和内存负荷，但强烈建议这样做。否则，在均匀纹理（例如在顶层和底层）中才能正确计算场。</li>
<li>Illuminating the grating from the top or the bottom layer : As mentioned earlier, the code compute the diffraction efficiencies of the transmitted and reflected orders for an incident plane wave from the top and for an incident plane wave from the bottom at the same time. When plotting the field, the user must specify the direction of the incident plane wave. This is specified with variable <strong>parm.res3.sens</strong>. For <strong>parm.res3.sens&#x3D;1</strong>, the grating is illuminated from the top and for <strong>parm.res3.sens&#x3D;-1</strong>, the grating is illuminated from the bottom (default is <strong>parm.res3.sens&#x3D;1)</strong>. 2.从顶层或底层照射光栅：如前所述，该代码同时计算从顶部和从底部入射平面波的透射和反射阶数的衍射效率。在绘制场时，用户必须指定入射平面波的方向。这是使用变量parm.res3.sens指定的。对于parm.res3.sens &#x3D; 1，从顶部照亮光栅，而parm.res3.sens &#x3D; -1则从底部照亮光栅（默认值为parm.res3.sens &#x3D; 1）。</li>
<li>Specifying the z locations of the computed fields: This is provided by the variable <strong>parm.res3.npts</strong>. <strong>parm.res3.npts</strong> is a vector whose length is equal to the number of layers. For instance let us imagine, a grating defined by <strong>Profile</strong> &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}. Setting <strong>parm.res3.npts&#x3D;[2,3,4,5]</strong> implies that the field will be computed in two z&#x3D;constant plans in the top layer, in three z&#x3D;constant plans in the first layer (texture 2), in four z&#x3D;constant plans in the second layer (texture 3), and in five z&#x3D;constant plans in the bottom layer. Default for <strong>parm.res3.npts</strong> is 10 z&#x3D;constant plans per layer. 指定计算场的z位置：这由变量parm.res3.npts提供。parm.res3.npts是一个向量，其长度等于层数。例如，假设存在一个由Profile &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}定义的光栅。设置parm.res3.npts&#x3D;[2,3,4,5]意味着将在顶层的两个z &#x3D; constant平面中计算场，在第一层（纹理2）中的三个z &#x3D; constant平面中计算场，在第二层（纹理3）中的四个z &#x3D; constant平面中计算场，并在底层的五个z &#x3D; constant平面中计算场。parm.res3.npts的默认值是每层10个z &#x3D; constant平面。</li>
</ol>
<p><code>VERY IMPORTANT</code> 非常重要</p>
<p>where is the z&#x3D;0 plan and what are the z-coordinates of the z&#x3D;constant plan? The z&#x3D;0 plan is defined at the bottom of the bottom layer. Thus, the field calculation is performed only for z&gt;0 values. For the example <strong>Profile</strong> &#x3D; {[0.5,1,2,0.6],[1,2,3,4]}, and if we refer to texture 4 as the substrate, the z&#x3D;0 plan is located in the substrate at a distance 0.6 under the grating. The z&#x3D;constant plans are located by an equidistant sampling in every layer. Always referring to the previous example, it implies that the five z&#x3D;constant plans in the substrate are located at coordinate z&#x3D;(p-0.5) 0.6&#x2F;5, where p&#x3D;1,2,…5. Note that the z coordinates for the z&#x3D;constant plans are always given by the second output variable of res3.m.</p>
<p>z&#x3D;0平面在底层底部定义。因此，场计算仅在z&gt; 0值时执行。对于示例Profile &#x3D; {[0.5,1,2,0.6]，[1,2,3,4]}，如果将纹理4称为基板，则z &#x3D; 0平面位于光栅下0.6的距离处的基板上。 z &#x3D; constant平面是在每个层中通过等距采样来定位的。始终参考之前的例子，意味着底层中的五个z &#x3D; constant平面位于z &#x3D;（p-0.5）0.6&#x2F;5的坐标处，其中p &#x3D; 1,2，… 5。请注意，z &#x3D; constant平面的z坐标始终由res3.m的第二个输出变量给出。</p>
<ol start="4">
<li><p>How can one specify a given z&#x3D;constant plan? First, one has to redefine the variable <strong>Profile</strong>. For the grating example with the two layers discussed above, let us imagine that one wants to plot the field at z&#x3D;z0+0.6+0.2 in layer 2. Then one has to set: <strong>Profile</strong> &#x3D; {[0.5,1-z0,0,z0,0.2,0.6],[1,2,2,2,3,4]} and set <strong>parm.res3.npts&#x3D;[0,0,1,0,0,0]</strong>. Note that it is not necessary to redefine the variable <strong>Profile</strong> at the beginning of the program. One just needs to redefine this variable before calling subroutine res3.m. 如何指定给定的z &#x3D; constant平面？首先，必须重新定义变量Profile。对于上面讨论的两个层的光栅示例，假设想要在第2层的z &#x3D; z0 + 0.6 + 0.2处绘制场。然后，必须设置：Profile &#x3D; {[0.5,1-z0,0,z0,0.2,0.6]，[1,2,2,2,3,4]}，并设置parm.res3.npts &#x3D; [0,0,1,0,0,0]。请注意，在程序开头重新定义变量Profile是不必要的。只需要在调用子程序res3.m之前重新定义此变量即可。</p>
</li>
<li><p>Automatic plots: an automatic plot (showing all the components of the electromagnetic fields and the grating refractive index distribution) is provided by setting <strong>parm.res3.trace</strong>&#x3D;1. If one wants to plot only some components of the fields, one can set for instance in TE polarization: <strong>parm.res3.champs</strong>&#x3D;[1,0] to plot Ey and the objet, <strong>parm.res3.champs</strong>&#x3D;[2] to plot only Hx. 自动绘图：通过设置parm.res3.trace &#x3D; 1，可以提供自动绘图（显示电磁场和光栅折射率分布的所有组件）。如果只想绘制场的某些组件，则可以在TE偏振中设置例如parm.res3.champs &#x3D; [1,0]绘制Ey和物体，parm.res3.champs &#x3D; [2]只绘制Hx。</p>
</li>
</ol>
<h3 id="Computation-of-the-absorption-loss"><a href="#Computation-of-the-absorption-loss" class="headerlink" title="Computation of the absorption loss"></a>Computation of the absorption loss</h3><p>吸收损失的计算</p>
<p>Loss computation is performed with the subroutine “<strong>res3.m</strong>”.</p>
<p>损耗计算使用子程序“ res3.m”执行。</p>
<p>First approach based on integrals (not valid for homogeneous layers with non-diagonal anisotropy): The absorption loss in a surface 𝑆 is given by:</p>
<p>第一种基于积分的方法（不适用于具有非对角各向同性的均匀层）：</p>
<p>表面𝑆的吸收损耗由以下公式给出：</p>
<p> 𝐿 &#x3D; 𝜋 ∫ 𝐼𝑚 𝜀(𝑀) |𝐸 (𝑀)|2 𝑑𝑆 for TE polarization.</p>
<p>𝐿 &#x3D; 𝜋 ∫ 𝐼𝑚 (𝜀𝑋𝑋(𝑀)|𝐸𝑋(𝑀)|2 + 𝜀𝑍𝑍(𝑀)|𝐸𝑧(𝑀)|2) 𝑑𝑆 for TM polarization.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[e, Z, index, wZ, loss_per_layer, loss_of_Z, loss_of_Z_X, X, wX] = res3(x,aa,Profile,einc,parm);</span><br></pre></td></tr></table></figure>

<p>The important ouput arguments are: 重要的输出参数是:</p>
<p><strong>loss_per_layer</strong>: the loss in every layer defined by <strong>Profile</strong>, <strong>loss_per_layer</strong>(1) is the loss in the top layer, loss_per_layer(2) is the loss in layer 2, … and loss_per_layer(end) is the loss in the bottom layer </p>
<p>loss_of_Z: the absorption loss density (integrated over X) as a function of Z (like for X, the sampling points Z are not equidistant. You may plot this loss density as follows: plot(Z, loss_of_Z), xlabel(‘Z’), ylabel(‘absorption’) </p>
<p>loss_of_Z_X(Z,X) &#x3D; π&#x2F;λ Im(index(Z,X).^2) |e(Z,X,1)|2 in TE polarization </p>
<p>loss_of_Z_X(Z,X) &#x3D; π&#x2F;λ Im(index(Z,X).^2) ( e(Z,X,2)|2+|e(Z,X,3)|2) in TM polarization </p>
<p>index: index(i,j) is the complex refractive index at the location {z(i), x(j)}.</p>
<p>每层损耗: 由 Profile 定义的每层损耗，每层损耗(1)是顶层损耗，每层损耗(2)是第2层损耗，… 每层损耗(末端)是底层损耗(z) : 吸收损耗密度(在 x 上积分)与 z 的函数关系(如 x，取样点 z 不等距)。您可以将这个损失密度绘制如下: 绘图(z，_ z 的损失) ，xlabel (‘ z’) ，ylabel (‘吸收’) _ z _ x (z，x)的损失 _ &#x3D; π&#x2F;λim (指数(z，x)。_ z _ x (z，x) &#x3D; π&#x2F;λim (index (z，x)的 TE 偏振损耗 _ 中的 ^ 2) | e (z，x，1) | 2。TM 偏振指数中的 ^ 2)(e (z，x，2) | 2 + | e (z，x，3) | 2) : 指数(i，j)是{ z (i) ，x (j)}处的复折射率。</p>
<p>Second approach based on Poynting theorem (always valid, even for homogeneous layers with non-diagonal anisotropy):</p>
<p>基于 Poynting 定理的第二种方法(总是有效的，即使对于非对角各向异性的均匀层) :</p>
<p>An alternative approach to compute the losses in the layers consists in calculating the difference in the flux of the incoming and outgoing Poynting vectors. This approach is faster, but in some cases, the computation of the integral can be more accurate. In homogeneous layers with non-diagonal anisotropy, only this approach is possible.</p>
<p>另一种计算各层损耗的方法是计算输入和输出 Poynting 向量的通量差。这种方法更快，但在某些情况下，积分的计算可以更精确。在非对角各向异性的均匀层中，只有这种方法是可行的。</p>
<p>To specify which approach used per layer, we define a vector parm.res3.pertes_poynting &#x3D; [0,0,0,1,0]; % for instance for a 5-layer grating with “0”, the integral approach is used (default option) and with “1”, the Poynting approach is used. The length of parm.res3.pertes_poynting is equal to the number of layers. We may set parm.res3.pertes_poynting &#x3D; 0 or 1; the scalar is then repeated for all layers.</p>
<p>为了指定每层使用的方法，我们定义了一个向量 parm.res3.pertes _ Poynting &#x3D; [0,0,0,1,0] ; 例如，对于5层光栅，使用“0”，使用积分方法(默认选项) ，对于“1”，使用 Poynting 方法。Parm.res3.pertes _ poynting 的长度等于层数。我们可以设置 parm.res3.pertes _ poynting &#x3D; 0或1; 然后对所有层重复标量。</p>
<p>We may then compute the flux of the Poynting vector in the layer-boundary planes [e, Z, index, wZ,loss_per_layer,loss_of_Z,loss_of_Z_X,X,wX,Flux_Poynting] &#x3D; res3(x,aa,Profile,einc,parm);</p>
<p>然后我们可以计算 Poynting 向量在层边界面[ e，z，index，wz，loss _ per _ layer，loss _ z，loss _ of _ zx，x，wx，flux _ Poynting ] &#x3D; res3(x，aa，Profile，einc，parm)中的通量;</p>
<p><strong>Flux_Poynting</strong> is a vector. <strong>Flux_Poynting(1)</strong> corresponds to the upper interface of the top layer. The flux is computed for a normal vector equal to the 𝐳̂vector. If <strong>Flux_Poynting(p)</strong> &gt; 0, the energy flows toward the top and if it is negative, the energy flows toward the bottom.</p>
<p><strong>Flux _ poynting 是一个矢量。Flux _ poynting (1)对应于顶层的上层界面。通量是针对一个等于 something 矢量的法向量计算的。如果 Flux _ poynting (p) &gt; 0，能量流向顶部，如果它是负的，能量流向底部。</strong></p>
<p>For an illumination from the top and a lossy substrate, the substrate absorption is **-**<strong>Flux_Poynting (end)&#x2F;(0.5*period)</strong>. For an illumination from the bottom and a lossy superstrate, the superstrate absorption is <strong>Flux_Poynting (1)&#x2F;(0.5*period)</strong>.</p>
<p>对于来自顶部和有耗基板的照明，基板的吸收是 Flux _ poynting (end)&#x2F;(0.5 * period)。对于来自底部和有耗上层的照明，上层吸收是 Flux _ poynting (1)&#x2F;(0.5 * period)。</p>
<p><code>Note on the computation accuracy of the integral approach</code> 关于积分法计算精度的注意事项</p>
<p>To compute integrals like the loss or the electromagnetic energy, RETICOLO uses a Gauss-Legendre integration method. This method, which is very powerful for ‘regular’ functions, becomes inaccurate for discontinuous functions. Thus, the integration domain should be divided into subdomains where the electric field <strong>E</strong> is continuous. For the integration in <strong>X</strong>, this difficult task is performed by the program, so that the user should only define the limits of integration: the input “<strong>x</strong>” argument is now a vector of length 2, which represent the limits of the x interval (to compute the loss over the entire period, we may take <strong>x</strong>(2)&#x3D;<strong>x</strong>(1)+<strong>period</strong>. The integration domain is then divided into subintervals where the permittivity is continuous, each subinterval having a length less than l&#x2F;(2p). For every subinterval, a Gauss-Legendre integration method of degree 10 is used. This default value can be changed by setting <strong>parm.res3.gauss_x</strong>&#x3D;. The actual points of computation of the field are returned in the output argument</p>
<p>为了计算像损耗或电磁能这样的积分，RETICOLO 使用了 Gauss-Legendre 积分法。这种方法对于“正则”函数非常有效，但是对于不连续的函数就不准确了。因此，积分域应该被划分为电场 e 是连续的子域。对于 x 中的积分，这个困难的任务是由程序执行的，因此用户只需要定义积分的极限: 输入“ x”参数现在是一个长度为2的向量，它表示 x 区间的极限(为了计算整个周期的损失，我们可以采用 x (2) &#x3D; x (1) + 周期)。然后将积分域划分为介电常数连续的子区间，每个子区间的长度小于&#x2F;(2)。对于每个子区间，使用10度的 Gauss-Legendre 积分方法。这个默认值可以通过设置 parm.res3.gauss _ x &#x3D; 来改变。字段的实际计算点在输出参数中返回X.</p>
<p>For the z integration, the discontinuity points are more easily determined by the variable ‘Profile’. The user</p>
<p>may choose the number of subintervals and the degree in every layer using the parameter parm.res3.npts, which is now an array with two lines (in subsection 8.1 this variable is a line vector): the first line defines the degree and the second line the numbers of subintervals of every layer. For example: parm.res3.npts &#x3D; [ [10,0,12] ; [3,1,5] ]; means that 3 subintervals with 10-degree points are used in the first layer, 1 subintervals with 0 point in the second layer, 5 subintervals with 12degree points in the third layer.</p>
<p>对于z积分，不连续点可以更轻松地通过变量“Profile”确定。用户可以使用参数parm.res3.npts选择每个层中的子区间数和度数，该参数现在是一个带有两行的数组（在第8.1小节中，此变量是线向量）：第一行定义度数，第二行定义每个层的子区间数。例如：parm.res3.npts &#x3D;[ [10,0,12];[3,1,5]]; 表示在第一层中使用3个子区间和10度点，第二层中使用1个子区间和0点，第三层中使用5个子区间和12度点。</p>
<p>The actual z-points of computation of the field are returned in the output variable <strong>Z</strong>, and the vector <strong>wZ</strong> represents the weights and we have sum(<strong>loss_of_Z</strong>.*<strong>wZ</strong>)&#x3D;sum(<strong>loss_per_layer</strong>). Although the maximum degree that can be handled by reticolo is 1000, it is recommended to limit the degree values to modest numbers (10-30 maximum) and to increase the number of subintervals (the larger the degree, the denser the sampling points in the vicinity of the subinterval boundaries).</p>
<p>字段计算的实际 z 点在输出变量 z 中返回，向量 wZ 表示权重，我们有 _ z 的总和(损失 _)。wZ) &#x3D; 总和(每层损失)。尽管 reticolo 可以处理的最大程度是1000，但建议将程度值限制为适度数(最大10-30) ，并增加子区间的数目(程度越大，子区间边界附近的采样点越密集)。</p>
<p>Note that if <strong>einc</strong>&#x3D; <strong>result. inc_top PlaneWave_E(2)</strong>, in TE ploarization, or <strong>einc</strong>&#x3D; <strong>result. inc_top PlaneWave_H(2)</strong>, in TE ploarization <strong>,</strong> the energie conservation test for an incident plane wave from the top is sum(result. inc_top_reflected.efficiency)+ sum(result. inc_top_transmitted.efficiency)+ sum(loss_per_layer) &#x2F; (.5*period) &#x3D; 1.</p>
<p>注意，如果 einc &#x3D; result。Inc _ top PlaneWave _ e (2) ，TE 极化，或 einc &#x3D; result。在 TE 极化条件下，从顶部入射的平面波的能量守恒实验是求和(结果)。反射。效率) + 总和(结果)。传输。效率) + 总和(每层损失)&#x2F;(. 5周期) &#x3D; 1。</p>
<p>Usually, this equality is achieved with an absolute error of &lt;10-5.</p>
<p>通常，这种等式是在绝对误差 &lt; 105时实现的。</p>
<p><code> For specialists: 对于专家</code>:</p>
<ol>
<li>-loss_of_Z_X &#x3D;pi&#x2F; wavelength<em>imag(index.^2).</em> abs(e(:,:,1)).^2; in TE polarization</li>
<li>-loss_of_Z_X &#x3D;pi&#x2F; wavelength*imag(index.^2).*sum(abs(e(:,:,2:3)).^2,3); in TM polarization</li>
<li>-loss_of_Z &#x3D;(loss_of_Z_X*wX(:)).’;</li>
<li>-by setting index(index ~&#x3D; index_chosen)&#x3D;0 in the previous formulas, one may calculate the absorption loss in the medium of refractive index index_chosen.</li>
</ol>
<p>通过在先前的公式中设置index（index〜&#x3D;index_chosen）&#x3D; 0，可以计算折射率为index_chosen的介质中的吸收损耗。</p>
<h2 id="Bloch-mode-effective-indices"><a href="#Bloch-mode-effective-indices" class="headerlink" title="Bloch-mode effective indices"></a>Bloch-mode effective indices</h2><p><code>Bloch模式有效指数</code></p>
<p>RETICOLO gives access to another output: the Bloch mode associated to all textures. The Bloch mode k of the</p>
<p>texture l can be written</p>
<p>RETICOLO提供了另一种输出：与所有纹理相关联的布洛赫模。纹理l的布洛赫模k可以写成：</p>
<p>$\left|\Phi_k{}^l\right\rangle&#x3D;\sum_m a_m^{k,l}exp\left[i(k_x^{inc}+mK_x)x\right]exp\left(i\frac{2\pi}{\lambda}n_{eff}^{k,l}z\right)$,</p>
<p>where $n_{\textit{eff}}^{k,l}$ is the effective index of the Bloch mode <em>k</em> of the texture <em>l</em>.</p>
<p>其中，$n_{\textit{eff}}^{k,l}$是纹理l的布洛赫模k的有效指数。</p>
<p><code>Instruction:</code>说明:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aa, n_eff] = res1(wavelength,period,textures,nn,kparallel, parm);</span><br></pre></td></tr></table></figure>

<p>Note that the “n_eff” variable is a Matlab cell array: “n_eff{ii}” is a column vector containing all the Bloch-mode effective indices associated to the texture “textures{ii}”. The element number 5 of this vector, for example, is called by the instruction “n_eff{ii}(5);”. An attenuated Bloch-mode has a complex effective index.</p>
<p>请注意，“n_eff”变量是Matlab单元数组：“n_eff {ii}”是包含所有与纹理“textures {ii}”相关联的布洛赫模有效指数的列向量。例如，此向量的第5个元素由指令“n_eff {ii}（5）;”调用。衰减的布洛赫模具有复有效指数。</p>
<p><code>Bloch mode profile visualization</code> Bloch 模式剖面可视化:</p>
<p>To plot the profile of Bloch mode Num_mode of the texture Num_texture:</p>
<p>要绘制纹理Num_texture的Bloch模Num_mode的轮廓：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1(aa, neff, Num_texture, Num_mode);</span><br></pre></td></tr></table></figure>

<p>To obtain the profile datas in the format given by res3:</p>
<p>要以res3给出的格式获取轮廓数据：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[e,o,x] = res1(aa, neff, Num_texture, Num_mode); <span class="comment">% by default, |x| &lt; period/2</span></span><br><span class="line">[e,o] = res1(aa, neff, Num_texture, Num_mode, x); <span class="comment">% by specifying the x vector, x=linspace(0, 3*period(1),100)</span></span><br><span class="line"><span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure>

<h2 id="10-Annex-附件"><a href="#10-Annex-附件" class="headerlink" title="10 Annex 附件"></a>10 Annex 附件</h2><h3 id="10-1-Checking-that-the-textures-are-correctly-set-up"><a href="#10-1-Checking-that-the-textures-are-correctly-set-up" class="headerlink" title="10.1 Checking that the textures are correctly set up"></a>10.1 Checking that the textures are correctly set up</h3><p>检查纹理设置是否正确</p>
<p>Setting “<strong>parm.res1.trace &#x3D; 1</strong>;” generates a Matlab figure which represents the refractive-index distribution of all the textures.</p>
<p>设置“ parm.res1.trace &#x3D; 1;”生成一个代表所有纹理折射率分布的 Matlab 图形。</p>
<h3 id="10-2-The-“retio”-“retefface”-instructions"><a href="#10-2-The-“retio”-“retefface”-instructions" class="headerlink" title="10.2 The “retio” &amp; “retefface” instructions"></a>10.2 The “retio” &amp; “retefface” instructions</h3><p>RETICOLO automatically creates temporary files in order to save memory. These temporary files are of the form “abcd0.mat”, “abcd1.mat” … with abcd are randomly chosen) .They are created in the current directory. In general RETICOLO automatically erases these files when they are no longer needed, but it is recommended to finish all programs by the instruction “retio;”, which erases all temporary files. Also, if a program anormally stopsone may execute the instruction “retio” before restarting the program.</p>
<p>RETICOLO会自动创建临时文件以节省内存。这些临时文件的格式为“abcd0.mat”，“abcd1.mat”……其中abcd是随机选择的）。它们在当前目录中创建。一般情况下，RETICOLO在不再需要这些文件时会自动删除它们，但建议通过指令“retio;”结束所有程序，该指令将删除所有临时文件。此外，如果程序异常停止，可以在重新启动程序之前执行指令“retio”。</p>
<p>The “retefface” instruction allows to know all the “abcd0.mat” files and to erase them if wanted.</p>
<p>“ reteface”指令允许知道所有“ abcd0.mat”文件，并在需要时删除它们。</p>
<p>If we are not limited by memory (this is often the case with modern computers), we can prevent the writing of intermediate files on the hard disk by the setting</p>
<p>如果我们不受内存的限制(现代计算机通常就是这种情况) ，我们可以通过设置来防止在硬盘上写入中间文件</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parm.not_io = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>before the call to res1. Then it is no longer necessary to use the retio instruction at the end of the programs to erase the files.</p>
<p>在调用 res1之前。然后就不再需要在程序结束时使用 retio 指令来删除文件了。</p>
<p><code>Important</code>: to use parfor loops, it is imperative to take the option parm.not_io &#x3D; 1.</p>
<p>重要提示: 要使用 parfor 循环，必须使用选项 parm.not _ io &#x3D; 1。</p>
<h3 id="10-3-How-to-save-and-to-reload-the-“aa”-variable"><a href="#10-3-How-to-save-and-to-reload-the-“aa”-variable" class="headerlink" title="10.3.   How to save and to reload the “aa” variable"></a><strong>10.3.</strong>   How to save and to reload the “aa” variable</h3><p>如何保存和重新加载“ aa”变量</p>
<p>To save the “<strong>aa</strong>” variable in a “.mat” file, the user has to define a new parameter containing the name of the file he or she wants to create : “<strong>parm.res1.fperm &#x3D; ‘file_name’</strong>;”. field_name is a char string with at least one letter. The program will automatically save “<strong>aa</strong>” in the file “<strong>file_name.mat</strong>”. In a new utilisation it is sufficient to write aa&#x3D;<strong>&#x3D; ‘file_name’</strong>;.</p>
<p>将“ aa”变量保存到“。在 mat”文件中，用户必须定义一个新参数，其中包含他或她想要创建的文件的名称: “ parm.res1.fperm &#x3D; ‘ file _ name’;”。Field _ name 是一个至少有一个字母的字符串。程序会自动将“ aa”保存到文件“ file _ name”中。马特。在一个新的应用程序中，写 aa &#x3D; &#x3D; ‘ file _ name’就足够了;。</p>
<p>Example of a program which calculates and saves the “aa” variable […] % Definition of the input parameters, see Section 3 <strong>parm.res1.fperm &#x3D; ‘toto’</strong>;</p>
<p>计算并保存输入参数的“ aa”变量[ … ]% 定义的程序示例，参见第3节 parm.res1.fperm &#x3D; ‘ toto’;</p>
<p>[…] % Definition of the textures, see Section 4.1</p>
<p>[ … ]% 纹理的定义，参见第4.1节</p>
<p><strong>aa &#x3D; res1(wavelength,period,textures,nn,k_parallel,parm)</strong>;</p>
<p><strong>Aa &#x3D; res1(波长，周期，纹理，nn，k 平行，parm) ;</strong></p>
<p>Example of a program which uses the “aa” variable and then calculates the diffracted waves […]  % Definition of the profile, see Section 4.2. Note that the textures used to define the profile argument have to correspond to the textures defined in the program which has previously calculated the “aa” variable. aa&#x3D;’toto’;</p>
<p>程序使用“ aa”变量，然后计算衍射波[ … ]% 轮廓的定义，参见第4.2节。注意，用于定义配置文件参数的纹理必须与之前计算“ aa”变量的程序中定义的纹理相对应。Aa &#x3D;’toto’;</p>
<h3 id="10-4-Asymmetry-of-the-Fourier-harmonics-retained-in-the-computation"><a href="#10-4-Asymmetry-of-the-Fourier-harmonics-retained-in-the-computation" class="headerlink" title="10.4.   Asymmetry of the Fourier harmonics retained in the computation"></a><strong>10.4.</strong>   Asymmetry of the Fourier harmonics retained in the computation</h3><p> nn &#x3D; [-15;20]; % this defines the set of non-symmetric Fourier harmonics retained for the computation. In this</p>
<p>case, the Fourier harmonics from –15 to +20 are retained.</p>
<p>The instructions “nn &#x3D; 10;” and “nn &#x3D; [-10;10];” are equivalent.</p>
<p>Take care that the use of symmetry imposes symmetric Fourier harmonics if not the computation will be done</p>
<p>without any symmetry consideration.</p>
<p>nn &#x3D; [-15; 20];% 这定义了计算中保留的非对称傅里叶谐波集。在这种情况下，保留从-15到+20的傅里叶谐波。 “nn &#x3D; 10;”和“nn &#x3D; [-10; 10];”指令是等价的。请注意，如果不使用对称性，则使用对称傅里叶谐波进行计算，否则将完全没有考虑对称性。</p>
<h2 id="11-Summary"><a href="#11-Summary" class="headerlink" title="11  Summary"></a>11  Summary</h2><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230403230539759.png" srcset="/img/loading.gif" lazyload alt="image-20230403230539759" style="zoom:50%;" />

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parm = res0( <span class="number">1</span>) <span class="keyword">for</span> TE polarisation;</span><br><span class="line">parm = res0(<span class="number">-1</span>) <span class="keyword">for</span> TM polarisation;</span><br><span class="line">aa = res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">result = res2(aa,Profile);</span><br><span class="line">J = result.Jones.inc_top_transmitted &#123;m&#125;</span><br><span class="line">[e,z,o] = res3(x,aa,Profile, inc,parm);</span><br></pre></td></tr></table></figure>

<h2 id="12-Examples-例子"><a href="#12-Examples-例子" class="headerlink" title="12 Examples  例子"></a>12 Examples  例子</h2><p> The following example can be copied and executed in Matlab ：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% EXAMPLE 1D (TE or TM) %</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">wavelength=<span class="number">8</span>;</span><br><span class="line">period=<span class="number">10</span>;<span class="comment">% same unit as wavelength</span></span><br><span class="line">n_incident_medium=<span class="number">1</span>;<span class="comment">% refractive index of the top layer</span></span><br><span class="line">n_transmitted_medium=<span class="number">1.5</span>;<span class="comment">% refractive index of the bottom layer</span></span><br><span class="line">angle_theta0=<span class="number">-10</span>;k_parallel=n_incident_medium*<span class="built_in">sin</span>(angle_theta0*<span class="built_in">pi</span>/<span class="number">180</span>);</span><br><span class="line">parm=res0(<span class="number">1</span>);<span class="comment">% TE polarization. For TM : parm=res0(-1)</span></span><br><span class="line">parm.res1.champ=<span class="number">1</span>;<span class="comment">% the electromagnetic field is calculated accurately</span></span><br><span class="line">nn=<span class="number">40</span>;<span class="comment">% Fourier harmonics run from [-40,40]</span></span><br><span class="line"><span class="comment">% textures for all layers including the top and bottom layers</span></span><br><span class="line">texture=cell(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">textures&#123;<span class="number">1</span>&#125;= n_incident_medium; <span class="comment">% uniform texture</span></span><br><span class="line">textures&#123;<span class="number">2</span>&#125;= n_transmitted_medium; <span class="comment">% uniform texture</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;=&#123;[<span class="number">-2.5</span>,<span class="number">2.5</span>],[n_incident_medium,n_transmitted_medium] &#125;;</span><br><span class="line"></span><br><span class="line">aa=res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">Profile=&#123;[<span class="number">4.1</span>,<span class="number">5.2</span>,<span class="number">4.1</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]&#125;;</span><br><span class="line">one_D_TE=res2(aa,Profile)</span><br><span class="line">eff=one_D_TE.inc_top_reflected.efficiency&#123;<span class="number">-1</span>&#125;</span><br><span class="line">J=one_D_TE.Jones.inc_top_reflected&#123;<span class="number">-1</span>&#125;;<span class="comment">% Jones’coefficients</span></span><br><span class="line"><span class="built_in">abs</span>(J)^<span class="number">2</span> <span class="comment">% first order efficiency for an illumination from the top layer</span></span><br><span class="line"><span class="comment">% field calculation</span></span><br><span class="line">x=<span class="built_in">linspace</span>(-period/<span class="number">2</span>,period/<span class="number">2</span>,<span class="number">51</span>);<span class="comment">% x coordinates(z-coordinates are determined by</span></span><br><span class="line">res3.m)</span><br><span class="line">einc=<span class="number">1</span>;</span><br><span class="line">parm.res3.trace=<span class="number">1</span>; <span class="comment">% plotting automatically</span></span><br><span class="line">parm.res3.npts=[<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>];</span><br><span class="line">[e,z,index]=res3(x,aa,Profile,einc,parm);</span><br><span class="line"><span class="built_in">figure</span>;pcolor(x,z,<span class="built_in">real</span>(<span class="built_in">squeeze</span>(e(:,:,<span class="number">1</span>)))); <span class="comment">% user plotting</span></span><br><span class="line">shading flat;xlabel(<span class="string">&#x27;x&#x27;</span>);ylabel(<span class="string">&#x27;y&#x27;</span>);axis equal;title(<span class="string">&#x27;Real(Ey)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Loss calculation</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;=&#123;[<span class="number">-2.5</span>,<span class="number">2.5</span>],[n_incident_medium,<span class="number">.1</span>+<span class="number">5</span><span class="built_in">i</span>] &#125;;</span><br><span class="line">aa_loss=res1(wavelength,period,textures,nn,k_parallel,parm);</span><br><span class="line">one_D_loss=res2(aa_loss,Profile)</span><br><span class="line">parm.res3.npts=[[<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>];[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>]];</span><br><span class="line">einc=one_D_loss.inc_top.PlaneWave_E(<span class="number">2</span>);</span><br><span class="line">[e,z,index,wZ,loss_per_layer,loss_of_Z,loss_of_Z_X,X,wX]=res3([-</span><br><span class="line">period/<span class="number">2</span>,period/<span class="number">2</span>],aa_loss,Profile,einc,parm);</span><br><span class="line">Energie_conservation=sum(one_D_loss.inc_top_reflected.efficiency)+sum(one_D_loss.in</span><br><span class="line">c_top_transmitted.efficiency)+sum(loss_per_layer)/(<span class="number">.5</span>* period)<span class="number">-1</span></span><br><span class="line">retio <span class="comment">% erase temporary files</span></span><br></pre></td></tr></table></figure>












<h1 id="for-the-analysis-of-the-diffraction-by-stacks-of-lamellar-1D-gratings-conical-diffraction"><a href="#for-the-analysis-of-the-diffraction-by-stacks-of-lamellar-1D-gratings-conical-diffraction" class="headerlink" title="for the analysis of the diffraction by stacks of lamellar 1D gratings (conical diffraction)"></a>for the analysis of the diffraction by stacks of lamellar 1D gratings (conical diffraction)</h1><p><code>用于分析层状一维光栅的衍射(锥形衍射)</code></p>
<p>Reticolo code 1D-conical is a free software for analyzing 1D gratings in classical and conical mountings. It operates under Matlab. To install it, copy the companion folder “reticolo_allege” and add the folder in the Matlab path. The code may also be used to analyze thin-film stacks with homogeneous and anisotropic materials, see the end of Section 3.1.</p>
<p>Reticolo 代码1d-锥是一个免费的软件，用于分析一维光栅在经典和锥形安装。它在 Matlab 下运行。要安装它，复制伴随文件夹“ reticolo _ allege”，并将该文件夹添加到 Matlab 路径中。该代码也可用于分析均质和各向异性材料的薄膜堆栈，参见第3.1节的结尾。</p>
<h2 id="Outline-大纲"><a href="#Outline-大纲" class="headerlink" title="Outline 大纲"></a>Outline 大纲</h2><h2 id="Generality-概括"><a href="#Generality-概括" class="headerlink" title="Generality 概括"></a>Generality 概括</h2><p>RETICOLO is a code written in the language MATLAB 9.0. It computes the diffraction efficiencies and the diffracted amplitudes of gratings composed of stacks of lamellar structures. It incorporates routines for the calculation and visualisation of the electromagnetic fields inside and outside the grating. With this version, 2D periodic (crossed) gratings cannot be analysed.</p>
<p>RETICOLO 是用 MATLAB 9.0语言编写的代码。它计算由层状结构堆叠组成的光栅的衍射效率和衍射振幅。它包含了用于计算和可视化光栅内外电磁场的例程。有了这个版本，二维周期(交叉)光栅不能被分析。</p>
<p>As free alternative to MATLAB, RETICOLO can also be run in GNU Octave with minimal code changes. For further information, please contact <a href="mailto:&#x74;&#x69;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#x74;&#116;&#x65;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#x72;&#x40;&#112;&#114;&#x6f;&#x66;&#97;&#99;&#116;&#111;&#114;&#46;&#97;&#x74;">&#x74;&#x69;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#x74;&#116;&#x65;&#x72;&#x61;&#109;&#115;&#x6b;&#111;&#103;&#108;&#101;&#x72;&#x40;&#112;&#114;&#x6f;&#x66;&#97;&#99;&#116;&#111;&#114;&#46;&#97;&#x74;</a>.</p>
<p>作为 MATLAB 的免费替代品，RETICOLO 也可以在 GNU Octave 中运行，代码变化很小。欲了解更多信息，请联系 <a href="mailto:&#116;&#105;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#116;&#x74;&#101;&#114;&#x61;&#109;&#x73;&#107;&#111;&#103;&#108;&#x65;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#99;&#x74;&#x6f;&#114;&#x2e;&#97;&#x74;">&#116;&#105;&#x6e;&#x61;&#x2e;&#x6d;&#x69;&#116;&#x74;&#101;&#114;&#x61;&#109;&#x73;&#107;&#111;&#103;&#108;&#x65;&#114;&#x40;&#112;&#x72;&#x6f;&#102;&#97;&#99;&#x74;&#x6f;&#114;&#x2e;&#97;&#x74;</a>。</p>
<p>In brief, RETICOLO implements a frequency-domain modal method (known as the Rigorous Coupled wave Analysis&#x2F;RCWA). To get an overview of the RCWA, the interested readers may refer to the following articles:</p>
<p>简而言之，RETICOLO 实现了一种频域模态方法(称为严格耦合波分析&#x2F;RCWA)。为了得到 RCWA 的概述，感兴趣的读者可以参考以下文章:</p>
<p>1D-classical and conical diffraction</p>
<p>1d-经典和圆锥衍射</p>
<p><strong>Scattering matrix approach:</strong> The code incorporates many refinements that we have not published and that we do not plan to publish. For instance, although it is generally admitted that the S-matrix is inconditionnally stable, it is not always the case. We have developed an in-house transfer matrix method which is more stable and accurate. The new transfer matrix approach is also more general and can handle perfect metals. The essence of the method has been rapidly published in “J.-P. Hugonin, M. Besbes and P. Lalanne, Op. Lett. <strong>33</strong>, 1590 (2008)”.</p>
<p><strong>散射矩阵方法: 该代码包含了许多我们没有发表过也不打算发表的改进。例如，尽管人们普遍承认 s 矩阵是无条件稳定的，但事实并非总是如此。我们开发了一种更稳定和准确的内部转移矩阵方法。新的转移矩阵方法也更加通用，可以处理完美的金属。这种方法的精髓已经在《日报》上迅速发表。作者: Hugonin，m. Besbes and p。莱特。33,1590(2008)”。</strong></p>
<p><strong>Field calculation:</strong> The calculation of the near-field electromagnetic fields everywhere in the grating is performed according to the method described in “P. Lalanne, M.P. Jurek, JMO <strong>45</strong>, 1357 (1998)” and to its generalization to crossed gratings (unpublished). Basically, no Gibbs phenomenon will be visible in the plots of the discontinuous electromagnetic quantities, but field singularities at corners will be correctly handled.</p>
<p><strong>场计算: 根据“ P.Lalanne，m.p. Jurek，JMO 45,1357(1998)”中描述的方法及其对交叉光栅的推广(未发表) ，计算了光栅内各处的近场电磁场。基本上，在不连续电磁量的图中不会看到吉布斯现象，但是在角落处的场奇异性将被正确处理。</strong></p>
<p><strong>Acknowledging the use of RETICOLO</strong>: In publications and reports, acknowledgments have to be provided by referencing to J.P. Hugonin and P. Lalanne, RETICOLO software for grating analysis, Institut d’Optique, Orsay, France (2005), arXiv:2101:00901.</p>
<p><strong>承认 RETICOLO 的使用: 在出版物和报告中，承认必须参考 j.p. Hugonin 和 p. Lalanne，RETICOLO 光栅分析软件，法国 Orsay 光学研究所，arXiv: 2101:00901。</strong></p>
<p>In journal publications and in addition, one may fairly quote the following references:</p>
<p>在期刊出版物和另外，人们可以公正地引用下列参考文献:</p>
<p>-P. Lalanne and G.M. Morris, “Highly improved convergence of the coupled-wave method for TM polarization”, J. Opt. Soc. Am. A <strong>13</strong>, 779-789 (1996).</p>
<p>拉兰内和莫里斯，“ TM 极化的耦合波方法的高度改进的收敛性”，J.Opt。Soc.译注:。13,779-789(1996).</p>
<p>-P. Lalanne and M.P. Jurek, “Computation of the near-field pattern with the coupled-wave method for TM polarization”, J. Mod. Opt.<strong>45</strong>, 1357-1374 (1998), if near-field electromagnetic-field distributions are shown.</p>
<p>- P.Lalanne 和 m.p. Jurek，“用 TM 极化的耦合波方法计算近场模式”，J.Mod。如果显示近场电磁场分布，则为 Opt. 45,1357-1374(1998)。</p>
<h2 id="The-diffraction-problem-considered"><a href="#The-diffraction-problem-considered" class="headerlink" title="The diffraction problem considered"></a>The diffraction problem considered</h2><p>考虑了衍射问题</p>
<p>In general terms, the code solves the diffraction problem by a grating defined by a stack of layers which have all identical periods in the x- directions and are invariant in the y direction see the following figure. In the following, the (x,y) plane and the z-direction will be referred to as the transverse plane and the longitudinal direction, respectively. To define the grating structure, first we have to define a top and a bottom. This is rather arbitrary since the top or the bottom can be the substrate or the cover of a real structure. It is up to the user. Once the top</p>
<p>一般来说，该代码通过一个光栅来解决衍射问题，这个光栅由一堆在 x 方向上具有相同周期且在 y 方向上不变的层所定义，如下图所示。接下来，(x，y)平面和 z 方向分别称为横向平面和纵向平面。为了定义光栅结构，首先我们必须定义一个顶部和一个底部。这是相当武断的，因为顶部或底部可以是一个真实结构的衬底或覆盖物。这取决于用户。一旦登顶</p>
<p> and the bottom of the grating have been defined, the user can choose to illuminate the structure from the top or from the bottom. The z-axis is oriented from bottom to top.</p>
<p>光栅的底部已经确定，用户可以选择从顶部或从底部照明结构。Z 轴是从下到上定向的。</p>
<p>RETICOLO is written with the 𝑒𝑥𝑝(−𝑖𝜔𝑡) convention for the complex notation of the fields. So, if the materials are absorbant, one expects that all indices have a positive imaginary part. The Maxwell’s equations are of the form</p>
<p>RETICOLO 是用 exp (- iωt)约定书写的，用于字段的复杂符号。因此，如果材料是吸收性的，人们期望所有的指数都有一个正虚部分。麦克斯韦方程组是这种形式</p>
<p>where 𝜀 &#x3D; 𝑛2 is the relative permittivity, a complex number, and 𝜆 is the wavelength in a vacuum.</p>
<p>其中 ε &#x3D; n2是相对电容率，一个复数 λ 是真空中的波长。</p>
<p>RETICOLO-1D returns the diffraction efficiencies of the transmitted and reflected orders for an incident plane wave from the top and for an incident plane wave from the bottom, both for TM and TE polarizations. The four results are obtained by the same calculation (incident TE wave from the top, incident TM wave from the top, incident TE wave from the bottom and incident TM wave from the bottom). Of course, the two incident plane waves must have identical parallel wave vector in the transverse plane [ kinc , kinc ]. This possibility which is not</p>
<p>RETICOLO-1D 返回了 TM 和 TE 偏振情况下从顶部入射的平面波和从底部入射的平面波的透射和反射阶的衍射效率。四个结果是通过相同的计算(从顶部入射的 TE 波，从顶部入射的 TM 波，从底部入射的 TE 波和从底部入射的 TM 波)得到的。当然，两个入射平面波在横向平面上必须有相同的平行波向量[ kinc，kinc ]。这种可能性不是</p>
<h2 id="跑的通"><a href="#跑的通" class="headerlink" title="跑的通"></a>跑的通</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%   1  D    exemple10_1D</span></span><br><span class="line"><span class="comment">% 不同厚度仿真 exemple2_1D</span></span><br><span class="line"><span class="comment">% 不同波长仿真 exemple5_1D</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">addpath(<span class="string">&#x27;reticolo_allege_v9&#x27;</span>);</span><br><span class="line">t1 = clock;</span><br><span class="line">incident_angle = <span class="number">0</span>;</span><br><span class="line">wavelength_range(:,<span class="number">1</span>) = <span class="number">0.4</span>:<span class="number">0.010</span>:<span class="number">2</span>; <span class="comment">% 波长范围</span></span><br><span class="line">grating_period = <span class="number">1</span>; <span class="comment">% 光栅周期</span></span><br><span class="line">grating_height = <span class="number">1</span>;</span><br><span class="line">incident_refractive_index = <span class="number">1</span>; <span class="comment">% 入射介质的折射率</span></span><br><span class="line">beta0 = incident_refractive_index * <span class="built_in">sin</span>(incident_angle * <span class="built_in">pi</span> / <span class="number">180</span>); <span class="comment">% 入射角的相位角</span></span><br><span class="line">polarization = <span class="number">-1</span>; <span class="comment">% -1:TM   1:TE   </span></span><br><span class="line">parm = res0(polarization); parm.not_io = <span class="number">1</span>; <span class="comment">% 初始化参数</span></span><br><span class="line">parm.sym.x = <span class="number">0</span>; <span class="comment">% 利用对称性</span></span><br><span class="line">fourier_series = <span class="number">20</span>; <span class="comment">% Fourier series</span></span><br><span class="line"><span class="comment">%% 结构尺寸和折射率</span></span><br><span class="line"><span class="comment">%&#123; </span></span><br><span class="line"><span class="comment">for ii = 1:12 textures&#123;ii&#125; = &#123;[-ii * grating_period / 13, 0], [1, 1.5]&#125;; end</span></span><br><span class="line"><span class="comment">% textures&#123;12&#125; = &#123;[-12 * grating_period / 13, -4,0], [3.2, 1,1.5]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;13&#125; = 1;textures&#123;14&#125; = 2.5;</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment"></span><span class="comment"></span></span><br><span class="line"><span class="comment">%&#123; </span></span><br><span class="line"><span class="comment">ii = 2;</span></span><br><span class="line"><span class="comment">textures&#123;1&#125; = &#123;[0,10,25], [1.5,1.7, 1.9]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;2&#125; = &#123;[0,10,15,25], [1.3,1.2, 1.4,1.1]&#125;; </span></span><br><span class="line"><span class="comment">textures&#123;ii+1&#125; = 1;</span></span><br><span class="line"><span class="comment">textures&#123;ii+2&#125; = 1.5;</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment">%&#123; 1</span></span><br><span class="line">ii = <span class="number">1</span>;</span><br><span class="line">textures&#123;<span class="number">1</span>&#125; = &#123;[<span class="number">0.25</span>,<span class="number">0.75</span>], [<span class="number">1</span>, <span class="number">2</span>]&#125;; </span><br><span class="line"><span class="comment">% textures&#123;2&#125; = &#123;[0,10,15,25], [1+3i,2, 1,2]&#125;; </span></span><br><span class="line">textures&#123;ii+<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line">textures&#123;ii+<span class="number">2</span>&#125; = <span class="number">1</span>;</span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">%&#123; 1</span></span><br><span class="line"><span class="keyword">for</span> ix = <span class="number">20</span></span><br><span class="line">    fourier_series = ix;</span><br><span class="line">    T = <span class="built_in">zeros</span>(<span class="built_in">length</span>(wavelength_range), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> wave_num = <span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)</span><br><span class="line">        </span><br><span class="line">        aa = res1(wavelength_range(wave_num), grating_period, textures, fourier_series, beta0, parm);</span><br><span class="line">        profil = &#123;[<span class="number">0</span>,  (grating_height / <span class="number">1</span>), <span class="number">0</span>], [<span class="built_in">numel</span>(textures)<span class="number">-1</span>, <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-2</span>), <span class="built_in">numel</span>(textures)]&#125;;</span><br><span class="line">        ef = res2(aa, profil);</span><br><span class="line">        R(wave_num,<span class="number">1</span>) = sum(ef.inc_top_reflected.efficiency);</span><br><span class="line">        T(wave_num,<span class="number">1</span>) = sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    Transmission_M(:,ix) = T;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"><span class="comment">%% 绘制折射率</span></span><br><span class="line">wave_num = <span class="number">1</span>;</span><br><span class="line">aa = res1(wavelength_range(wave_num), grating_period, textures, fourier_series, beta0, parm);</span><br><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, grating_period, <span class="number">100</span>); <span class="comment">% 绘制的范围 两个周期 </span></span><br><span class="line">parm.res3.cale = []; <span class="comment">% signifie que l&#x27;on ne calcule pas le champ</span></span><br><span class="line">profil = &#123;[<span class="number">2</span>,  grating_height, <span class="number">2</span>], [<span class="built_in">numel</span>(textures)<span class="number">-1</span>, <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-2</span>), <span class="built_in">numel</span>(textures)]&#125;;</span><br><span class="line">[tab1, z, o] = res3(x, aa, profil, <span class="number">1</span>, parm); </span><br><span class="line"></span><br><span class="line"><span class="comment">% plot_func(dimension,x,y,z,fontsize, linewidth, x_dis, y_dis, width, height,xlable, ylable, title)</span></span><br><span class="line">plot_func(<span class="number">3</span>,x,z,<span class="built_in">real</span>(o),<span class="number">25</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;X label range (μm)&#x27;</span>,<span class="string">&#x27;Z label (μm)&#x27;</span>,<span class="string">&#x27;截面折射率&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘制透射谱</span></span><br><span class="line"><span class="comment">% plot_func(dimension,x,y,z,fontsize, linewidth, x_dis, y_dis, width, height,xlable, ylable, title)</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&#x27;Transmission_M&#x27;</span>) ~= <span class="number">0</span></span><br><span class="line">    plot_func(<span class="number">2</span>,wavelength_range,Transmission_M,  <span class="number">0</span>,<span class="number">25</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (μm)&#x27;</span>,<span class="string">&#x27;Transmission&#x27;</span>,<span class="string">&#x27;透射率与阶数的关系&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t2 = clock; tc(t2,t1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="一维光栅结构-改之前"><a href="#一维光栅结构-改之前" class="headerlink" title="一维光栅结构-改之前"></a>一维光栅结构-改之前</h2><img src="https://cdn.staticaly.com/gh/yangmulao/blogcdn@master/img/image-20230419103659141.png" srcset="/img/loading.gif" lazyload alt="image-20230419103659141" style="zoom:80%;" />



<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 不同厚度仿真 exemple2_1D</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">addpath(<span class="string">&#x27;reticolo_allege_v9&#x27;</span>); addpath(<span class="string">&#x27;shuju&#x27;</span>);addpath(<span class="string">&#x27;script&#x27;</span>);addpath(<span class="string">&#x27;RCWA&#x27;</span>);</span><br><span class="line">t1 = clock;</span><br><span class="line">incident_angle = <span class="number">0</span>;</span><br><span class="line">wavelength_range(:,<span class="number">1</span>) = <span class="number">0.4</span>:<span class="number">0.001</span>:<span class="number">4</span>; <span class="comment">% 波长范围</span></span><br><span class="line"></span><br><span class="line">grating_period = <span class="number">1</span>; <span class="comment">% 光栅周期</span></span><br><span class="line">incident_refractive_index = <span class="number">1</span>; <span class="comment">% 入射介质的折射率</span></span><br><span class="line">k_parallel = incident_refractive_index * <span class="built_in">sin</span>(incident_angle * <span class="built_in">pi</span> / <span class="number">180</span>); <span class="comment">% 入射角的相位角</span></span><br><span class="line">polarization = <span class="number">-1</span>; <span class="comment">% -1:TM   1:TE   </span></span><br><span class="line">parm = res0(polarization); parm.not_io = <span class="number">1</span>; <span class="comment">% 初始化参数</span></span><br><span class="line"><span class="comment">% parm.sym.x = 1; % 利用对称性</span></span><br><span class="line">fourier_series_M = <span class="number">20</span>; <span class="comment">% Fourier series</span></span><br><span class="line">fourier_series = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 1  MgF2     % 11 W       % 21 VO2-hot</span></span><br><span class="line"><span class="comment">% 2  SiO2     % 12 Ti      % 22 VO2-cool</span></span><br><span class="line"><span class="comment">% 3  Al2O3    % 13 Fe      % 23 VO2-hot</span></span><br><span class="line"><span class="comment">% 4  Si3N4    % 14 Cr      % 24 DAST-Voltage</span></span><br><span class="line"><span class="comment">% 5  Si3N41直 % 15 Mo*     % 25 ALON</span></span><br><span class="line"><span class="comment">% 6  TiO2     % 16 Au      % 26 ITO</span></span><br><span class="line"><span class="comment">% 7  SiN      % 17 Cu      % 27 Ag*</span></span><br><span class="line"><span class="comment">% 8  Ge       % 18 Al</span></span><br><span class="line"><span class="comment">% 9  PMMA     % 19 Ag </span></span><br><span class="line"><span class="comment">% 10 SiO2     % 20 VO2-cool</span></span><br><span class="line">nk_Martix = <span class="built_in">conj</span>(nk_data(wavelength_range*<span class="number">1000</span>));</span><br><span class="line"><span class="comment">%% 结构尺寸和折射率</span></span><br><span class="line">struct.period = <span class="number">1</span>; </span><br><span class="line">struct.height(:,<span class="number">1</span>) =  [<span class="number">1.00</span>   <span class="number">1.00</span>   <span class="number">1</span>]; <span class="comment">% h1 h2 ...</span></span><br><span class="line">struct.width(:,<span class="number">1</span>) =  [<span class="number">0.4</span>    <span class="number">0.6</span>    <span class="number">0.8</span>];   <span class="comment">% w1 w2 ...</span></span><br><span class="line">struct.nkindex(:,<span class="number">1</span>) = [<span class="number">19</span>   <span class="number">19</span>      <span class="number">19</span>];</span><br><span class="line"><span class="comment">% FDTD</span></span><br><span class="line">struct.unit = <span class="number">1e-6</span>; <span class="comment">% 1e-6 μm; 1e-9 nm</span></span><br><span class="line">struct.mesh = <span class="number">0.02</span>; <span class="comment">% mesh </span></span><br><span class="line">struct.mesh_M = <span class="number">0.01</span>;</span><br><span class="line">struct.wave_start = <span class="built_in">min</span>(wavelength_range);</span><br><span class="line">struct.wave_stop = <span class="built_in">max</span>(wavelength_range);</span><br><span class="line">struct.wave_step = wavelength_range(<span class="number">2</span>,<span class="number">1</span>)-wavelength_range(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结构纹理 textures</span></span><br><span class="line">x_bloack = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">for</span> iz = <span class="number">1</span>:<span class="built_in">length</span>(struct.height)</span><br><span class="line">    textures&#123;iz&#125;(<span class="number">1</span>) = &#123;[-struct.width(iz,<span class="number">1</span>)/<span class="number">2</span>,struct.width(iz,<span class="number">1</span>)/<span class="number">2</span>]&#125;; <span class="comment">% 设置结构宽度</span></span><br><span class="line">    struct.nk(:,iz) = nk_Martix(:,struct.nkindex(iz,<span class="number">1</span>)); <span class="comment">% 设置结构折射率</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">scale_one = grating_period / x_bloack;</span><br><span class="line"><span class="keyword">for</span> io = <span class="number">1</span>:x_bloack</span><br><span class="line">    x_coordinate(io) = scale_one * (io - <span class="number">1</span>) - grating_period/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">textures&#123;<span class="number">3</span>&#125;(<span class="number">1</span>) = &#123;x_coordinate&#125;;</span><br><span class="line">textures&#123;iz+<span class="number">1</span>&#125; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> method = <span class="number">1</span>:<span class="number">1</span>  <span class="comment">% 1: RCWA 2:FDTD</span></span><br><span class="line"><span class="keyword">switch</span> method    </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="comment">%% 1 RCWA</span></span><br><span class="line">        <span class="keyword">for</span> ix = <span class="number">1</span>:<span class="built_in">length</span>(fourier_series_M)</span><br><span class="line">            fourier_series = fourier_series_M(ix);</span><br><span class="line">            R = <span class="built_in">zeros</span>(<span class="built_in">length</span>(wavelength_range), <span class="number">1</span>); T = R; A = R; </span><br><span class="line">            textures_local = textures; aa_save = &#123;&#125;; profil_save = &#123;&#125;; textures_save = &#123;<span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)&#125;;</span><br><span class="line">            <span class="keyword">parfor</span> wave_num = <span class="number">1</span>:<span class="built_in">length</span>(wavelength_range)                 </span><br><span class="line">                textures = textures_local;</span><br><span class="line">                <span class="keyword">for</span> izz = <span class="number">1</span>:iz;textures&#123;izz&#125;(<span class="number">2</span>) = &#123;[<span class="number">1</span>, struct.nk(wave_num,izz)]&#125;;<span class="keyword">end</span>;</span><br><span class="line">                b_ix = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">length</span>(textures&#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;));</span><br><span class="line">                <span class="keyword">for</span> ia = <span class="number">1</span>:<span class="built_in">length</span>(textures&#123;<span class="number">1</span>, <span class="number">3</span>&#125;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;)</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">rem</span>(ia, <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">                        b_ix(ia) = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                textures&#123;<span class="number">3</span>&#125;(<span class="number">2</span>) = &#123;b_ix&#125;;</span><br><span class="line"></span><br><span class="line">                aa = res1(wavelength_range(wave_num), struct.period, textures, fourier_series, k_parallel, parm);</span><br><span class="line">                profile = &#123;[<span class="number">0</span>,  struct.height&#x27;, <span class="number">0</span>], [<span class="built_in">length</span>(textures), <span class="number">1</span>:(<span class="built_in">numel</span>(textures)<span class="number">-1</span>), <span class="built_in">length</span>(textures)]&#125;;</span><br><span class="line">                <span class="comment">% 计算</span></span><br><span class="line">                ef = res2(aa, profile);</span><br><span class="line">                R(wave_num,<span class="number">1</span>) = sum(ef.inc_top_reflected.efficiency);</span><br><span class="line">                T(wave_num,<span class="number">1</span>) = sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">                A(wave_num,<span class="number">1</span>) = <span class="number">1</span> - sum(ef.inc_top_reflected.efficiency) - sum(ef.inc_top_transmitted.efficiency);</span><br><span class="line">                textures_save&#123;wave_num&#125; = textures; aa_save&#123;wave_num&#125; = aa; profil_save&#123;wave_num&#125; = profile;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            RCWA.R(:,ix) = R; RCWA.T(:,ix) = T; RCWA.A(:,ix) = A;</span><br><span class="line">            t2 = clock; tc(t2,t1);</span><br><span class="line">            RCWA.T_matrix(:,ix) = T;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        RCWA.RTA = [R T A]; RCWA.R = R; RCWA.T = T; RCWA.A = A; </span><br><span class="line"></span><br><span class="line">        textures = textures_save&#123;<span class="number">1</span>&#125;; aa = aa_save&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        profile = profil_save&#123;<span class="number">1</span>&#125;; profile&#123;<span class="number">1</span>&#125;(<span class="number">1</span>) = <span class="number">2</span>; profile&#123;<span class="number">1</span>&#125;(<span class="keyword">end</span>) = <span class="number">2</span>;</span><br><span class="line">        x = <span class="built_in">linspace</span>(-struct.period/<span class="number">2</span>, struct.period/<span class="number">2</span>, <span class="built_in">max</span>(x_bloack*<span class="number">2</span>, <span class="number">100</span>));</span><br><span class="line">        [e, z, o] = res3(x, aa, profile, <span class="number">1</span>, parm);         </span><br><span class="line">        plot_func(<span class="number">3</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span>],x,z,<span class="built_in">real</span>(o),<span class="number">15</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">900</span>,<span class="number">400</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;截面折射率&#x27;</span>);      </span><br><span class="line">        <span class="comment">%% 绘制透射谱</span></span><br><span class="line">        plot_func(<span class="number">2</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>],wavelength_range,RCWA.T_matrix,<span class="number">0</span>, <span class="number">15</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (μm)&#x27;</span>,<span class="string">&#x27;Transmission&#x27;</span>,<span class="string">&#x27;RCWA 透射&#x27;</span>);</span><br><span class="line">        plot_func(<span class="number">3</span>,[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span>],x,z,e(:,:,<span class="number">1</span>).*<span class="built_in">conj</span>(e(:,:,<span class="number">1</span>)),<span class="number">15</span>, <span class="number">1.5</span>, <span class="number">-1000</span>,<span class="number">500</span>,<span class="number">900</span>,<span class="number">400</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;abs(E)^2&#x27;</span>);      </span><br><span class="line">        </span><br><span class="line">        t2 = clock; tc(t2,t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 2 FDTD</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> mesh_num = <span class="number">1</span>:<span class="built_in">length</span>(struct.mesh_M)</span><br><span class="line">            struct.mesh = struct.mesh_M(mesh_num); FDTD = fun_1D(struct); t2 = clock; tc(t2,t1);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        plot_func(<span class="number">2</span>, <span class="number">0</span>,FDTD.wave,FDTD.T,<span class="number">0</span>, <span class="number">25</span>,<span class="number">1.5</span>,  <span class="number">-500</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="string">&#x27;Wavelength (μm)&#x27;</span>,<span class="string">&#x27;R/T/A&#x27;</span>,<span class="string">&#x27;FDTD 透射&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;<span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/RCWA/">#RCWA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RCWA 相关1</div>
      <div>http://example.com/2023/11/08/RCWA/RCWA相关/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月8日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年6月27日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/08/RCWA/RCWA%E7%A8%8B%E5%BA%8F/" title="RCWA 程序">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RCWA 程序</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/08/Python/Python%E5%B8%B8%E7%94%A8/" title="Python常用">
                        <span class="hidden-mobile">Python常用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
